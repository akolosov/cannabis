<?php final class Doctrine { const VERSION = '1.0.4'; const ERR = -1; const ERR_SYNTAX = -2; const ERR_CONSTRAINT = -3; const ERR_NOT_FOUND = -4; const ERR_ALREADY_EXISTS = -5; const ERR_UNSUPPORTED = -6; const ERR_MISMATCH = -7; const ERR_INVALID = -8; const ERR_NOT_CAPABLE = -9; const ERR_TRUNCATED = -10; const ERR_INVALID_NUMBER = -11; const ERR_INVALID_DATE = -12; const ERR_DIVZERO = -13; const ERR_NODBSELECTED = -14; const ERR_CANNOT_CREATE = -15; const ERR_CANNOT_DELETE = -16; const ERR_CANNOT_DROP = -17; const ERR_NOSUCHTABLE = -18; const ERR_NOSUCHFIELD = -19; const ERR_NEED_MORE_DATA = -20; const ERR_NOT_LOCKED = -21; const ERR_VALUE_COUNT_ON_ROW = -22; const ERR_INVALID_DSN = -23; const ERR_CONNECT_FAILED = -24; const ERR_EXTENSION_NOT_FOUND = -25; const ERR_NOSUCHDB = -26; const ERR_ACCESS_VIOLATION = -27; const ERR_CANNOT_REPLACE = -28; const ERR_CONSTRAINT_NOT_NULL = -29; const ERR_DEADLOCK = -30; const ERR_CANNOT_ALTER = -31; const ERR_MANAGER = -32; const ERR_MANAGER_PARSE = -33; const ERR_LOADMODULE = -34; const ERR_INSUFFICIENT_DATA = -35; const ERR_CLASS_NAME = -36; const CASE_LOWER = 2; const CASE_NATURAL = 0; const CASE_UPPER = 1; const CURSOR_FWDONLY = 0; const CURSOR_SCROLL = 1; const ERRMODE_EXCEPTION = 2; const ERRMODE_SILENT = 0; const ERRMODE_WARNING = 1; const FETCH_ASSOC = 2; const FETCH_BOTH = 4; const FETCH_BOUND = 6; const FETCH_CLASS = 8; const FETCH_CLASSTYPE = 262144; const FETCH_COLUMN = 7; const FETCH_FUNC = 10; const FETCH_GROUP = 65536; const FETCH_INTO = 9; const FETCH_LAZY = 1; const FETCH_NAMED = 11; const FETCH_NUM = 3; const FETCH_OBJ = 5; const FETCH_ORI_ABS = 4; const FETCH_ORI_FIRST = 2; const FETCH_ORI_LAST = 3; const FETCH_ORI_NEXT = 0; const FETCH_ORI_PRIOR = 1; const FETCH_ORI_REL = 5; const FETCH_SERIALIZE = 524288; const FETCH_UNIQUE = 196608; const NULL_EMPTY_STRING = 1; const NULL_NATURAL = 0; const NULL_TO_STRING = NULL; const PARAM_BOOL = 5; const PARAM_INPUT_OUTPUT = -2147483648; const PARAM_INT = 1; const PARAM_LOB = 3; const PARAM_NULL = 0; const PARAM_STMT = 4; const PARAM_STR = 2; const ATTR_AUTOCOMMIT = 0; const ATTR_PREFETCH = 1; const ATTR_TIMEOUT = 2; const ATTR_ERRMODE = 3; const ATTR_SERVER_VERSION = 4; const ATTR_CLIENT_VERSION = 5; const ATTR_SERVER_INFO = 6; const ATTR_CONNECTION_STATUS = 7; const ATTR_CASE = 8; const ATTR_CURSOR_NAME = 9; const ATTR_CURSOR = 10; const ATTR_ORACLE_NULLS = 11; const ATTR_PERSISTENT = 12; const ATTR_STATEMENT_CLASS = 13; const ATTR_FETCH_TABLE_NAMES = 14; const ATTR_FETCH_CATALOG_NAMES = 15; const ATTR_DRIVER_NAME = 16; const ATTR_STRINGIFY_FETCHES = 17; const ATTR_MAX_COLUMN_LEN = 18; const ATTR_LISTENER = 100; const ATTR_QUOTE_IDENTIFIER = 101; const ATTR_FIELD_CASE = 102; const ATTR_IDXNAME_FORMAT = 103; const ATTR_SEQNAME_FORMAT = 104; const ATTR_SEQCOL_NAME = 105; const ATTR_CMPNAME_FORMAT = 118; const ATTR_DBNAME_FORMAT = 117; const ATTR_TBLCLASS_FORMAT = 119; const ATTR_TBLNAME_FORMAT = 120; const ATTR_EXPORT = 140; const ATTR_DECIMAL_PLACES = 141; const ATTR_PORTABILITY = 106; const ATTR_VALIDATE = 107; const ATTR_COLL_KEY = 108; const ATTR_QUERY_LIMIT = 109; const ATTR_DEFAULT_TABLE_TYPE = 112; const ATTR_DEF_TEXT_LENGTH = 113; const ATTR_DEF_VARCHAR_LENGTH = 114; const ATTR_DEF_TABLESPACE = 115; const ATTR_EMULATE_DATABASE = 116; const ATTR_USE_NATIVE_ENUM = 117; const ATTR_DEFAULT_SEQUENCE = 133; const ATTR_FETCHMODE = 118; const ATTR_NAME_PREFIX = 121; const ATTR_CREATE_TABLES = 122; const ATTR_COLL_LIMIT = 123; const ATTR_CACHE = 150; const ATTR_RESULT_CACHE = 150; const ATTR_CACHE_LIFESPAN = 151; const ATTR_RESULT_CACHE_LIFESPAN = 151; const ATTR_LOAD_REFERENCES = 153; const ATTR_RECORD_LISTENER = 154; const ATTR_THROW_EXCEPTIONS = 155; const ATTR_DEFAULT_PARAM_NAMESPACE = 156; const ATTR_QUERY_CACHE = 157; const ATTR_QUERY_CACHE_LIFESPAN = 158; const ATTR_AUTOLOAD_TABLE_CLASSES = 160; const ATTR_MODEL_LOADING = 161; const ATTR_RECURSIVE_MERGE_FIXTURES = 162; const ATTR_USE_DQL_CALLBACKS = 164; const ATTR_AUTO_ACCESSOR_OVERRIDE = 165; const LIMIT_ROWS = 1; const QUERY_LIMIT_ROWS = 1; const LIMIT_RECORDS = 2; const QUERY_LIMIT_RECORDS = 2; const PORTABILITY_NONE = 0; const PORTABILITY_FIX_CASE = 1; const PORTABILITY_RTRIM = 2; const PORTABILITY_DELETE_COUNT = 4; const PORTABILITY_EMPTY_TO_NULL = 8; const PORTABILITY_FIX_ASSOC_FIELD_NAMES = 16; const PORTABILITY_EXPR = 32; const PORTABILITY_ALL = 63; const LOCK_OPTIMISTIC = 0; const LOCK_PESSIMISTIC = 1; const EXPORT_NONE = 0; const EXPORT_TABLES = 1; const EXPORT_CONSTRAINTS = 2; const EXPORT_PLUGINS = 4; const EXPORT_ALL = 7; const HYDRATE_RECORD = 2; const HYDRATE_ARRAY = 3; const HYDRATE_NONE = 4; const VALIDATE_NONE = 0; const VALIDATE_LENGTHS = 1; const VALIDATE_TYPES = 2; const VALIDATE_CONSTRAINTS = 4; const VALIDATE_ALL = 7; const IDENTIFIER_AUTOINC = 1; const IDENTIFIER_SEQUENCE = 2; const IDENTIFIER_NATURAL = 3; const IDENTIFIER_COMPOSITE = 4; const MODEL_LOADING_AGGRESSIVE = 1; const MODEL_LOADING_CONSERVATIVE= 2; private static $_path; private static $_debug = false; private static $_loadedModelFiles = array(); private static $_validators = array(); public function __construct() { throw new Doctrine_Exception('Doctrine is static class. No instances can be created.'); } public static function getLoadedModelFiles() { return self::$_loadedModelFiles; } public static function debug($bool = null) { if ($bool !== null) { self::$_debug = (bool) $bool; } return self::$_debug; } public static function getPath() { if ( ! self::$_path) { self::$_path = dirname(__FILE__); } return self::$_path; } public static function loadModel($className, $path = null) { self::$_loadedModelFiles[$className] = $path; } public static function loadModels($directory, $modelLoading = null) { $manager = Doctrine_Manager::getInstance(); $modelLoading = $modelLoading === null ? $manager->getAttribute(Doctrine::ATTR_MODEL_LOADING):$modelLoading; $loadedModels = array(); if ($directory !== null) { foreach ((array) $directory as $dir) { if ( ! is_dir($dir)) { throw new Doctrine_Exception('You must pass a valid path to a directory containing Doctrine models'); } $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($it as $file) { $e = explode('.', $file->getFileName()); if (end($e) === 'php' && strpos($file->getFileName(), '.inc') === false) { $className = $e[0]; if ($modelLoading == Doctrine::MODEL_LOADING_CONSERVATIVE) { self::loadModel($className, $file->getPathName()); $loadedModels[$className] = $className; } else { $declaredBefore = get_declared_classes(); require_once($file->getPathName()); $declaredAfter = get_declared_classes(); $foundClasses = array_slice($declaredAfter, count($declaredBefore) - 1); if ($foundClasses) { foreach ($foundClasses as $className) { if (self::isValidModelClass($className)) { $loadedModels[$className] = $className; self::loadModel($className, $file->getPathName()); } } } } } } } } return $loadedModels; } public static function getLoadedModels($classes = null) { if ($classes === null) { $classes = get_declared_classes(); $classes = array_merge($classes, array_keys(self::$_loadedModelFiles)); } return self::filterInvalidModels($classes); } public static function initializeModels($models) { $models = self::filterInvalidModels($models); foreach ($models as $model) { $declaredBefore = get_declared_classes(); Doctrine::getTable($model); $declaredAfter = get_declared_classes(); $foundClasses = array_slice($declaredAfter, count($declaredBefore) - 1); foreach ($foundClasses as $class) { if (self::isValidModelClass($class)) { $models[] = $class; } } } $models = self::filterInvalidModels($models); return $models; } public static function filterInvalidModels($classes) { $validModels = array(); foreach ((array) $classes as $name) { if (self::isValidModelClass($name) && ! in_array($name, $validModels)) { $validModels[] = $name; } } return $validModels; } public static function isValidModelClass($class) { if ($class instanceof Doctrine_Record) { $class = get_class($class); } if (is_string($class) && class_exists($class)) { $class = new ReflectionClass($class); } if ($class instanceof ReflectionClass) { if ( ! $class->isAbstract() && $class->isSubClassOf('Doctrine_Record')) { return true; } } return false; } public static function getConnectionByTableName($tableName) { $loadedModels = self::getLoadedModels(); foreach ($loadedModels as $name) { $table = Doctrine::getTable($name); if ($table->getTableName() == $tableName) { return $table->getConnection(); } } return Doctrine_Manager::connection(); } public static function generateModelsFromDb($directory, array $databases = array(), array $options = array()) { return Doctrine_Manager::connection()->import->importSchema($directory, $databases, $options); } public static function generateYamlFromDb($yamlPath, array $databases = array(), array $options = array()) { $directory = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'tmp_doctrine_models'; $options['generateBaseClasses'] = isset($options['generateBaseClasses']) ? $options['generateBaseClasses']:false; $result = Doctrine::generateModelsFromDb($directory, $databases, $options); if ( empty($result) && ! is_dir($directory)) { throw new Doctrine_Exception('No models generated from your databases'); } $export = new Doctrine_Export_Schema(); $result = $export->exportSchema($yamlPath, 'yml', $directory); Doctrine_Lib::removeDirectories($directory); return $result; } public static function generateModelsFromYaml($yamlPath, $directory, $options = array()) { $import = new Doctrine_Import_Schema(); $import->setOptions($options); return $import->importSchema($yamlPath, 'yml', $directory); } public static function createTablesFromModels($directory = null) { return Doctrine_Manager::connection()->export->exportSchema($directory); } public static function createTablesFromArray($array) { return Doctrine_Manager::connection()->export->exportClasses($array); } public static function generateSqlFromArray($array) { return Doctrine_Manager::connection()->export->exportClassesSql($array); } public static function generateSqlFromModels($directory = null) { $conn = Doctrine_Manager::connection(); $sql = $conn->export->exportSql($directory); $build = ''; foreach ($sql as $query) { $build .= $query.$conn->sql_file_delimiter; } return $build; } public static function generateYamlFromModels($yamlPath, $directory) { $export = new Doctrine_Export_Schema(); return $export->exportSchema($yamlPath, 'yml', $directory); } public static function createDatabases($specifiedConnections = array()) { return Doctrine_Manager::getInstance()->createDatabases($specifiedConnections); } public static function dropDatabases($specifiedConnections = array()) { return Doctrine_Manager::getInstance()->dropDatabases($specifiedConnections); } public static function dumpData($yamlPath, $individualFiles = false) { $data = new Doctrine_Data(); return $data->exportData($yamlPath, 'yml', array(), $individualFiles); } public static function loadData($yamlPath, $append = false) { $data = new Doctrine_Data(); return $data->importData($yamlPath, 'yml', array(), $append); } public static function migrate($migrationsPath, $to = null) { $migration = new Doctrine_Migration($migrationsPath); return $migration->migrate($to); } public static function generateMigrationClass($className, $migrationsPath) { $builder = new Doctrine_Migration_Builder($migrationsPath); return $builder->generateMigrationClass($className); } public static function generateMigrationsFromDb($migrationsPath) { $builder = new Doctrine_Migration_Builder($migrationsPath); return $builder->generateMigrationsFromDb(); } public static function generateMigrationsFromModels($migrationsPath, $modelsPath = null, $modelLoading = null) { $builder = new Doctrine_Migration_Builder($migrationsPath); return $builder->generateMigrationsFromModels($modelsPath, $modelLoading); } public static function getTable($componentName) { return Doctrine_Manager::getInstance()->getConnectionForComponent($componentName)->getTable($componentName); } public static function compile($target = null, $includedDrivers = array()) { return Doctrine_Compiler::compile($target, $includedDrivers); } public static function autoload($className) { if (class_exists($className, false) || interface_exists($className, false)) { return false; } $class = self::getPath() . DIRECTORY_SEPARATOR . str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php'; if (file_exists($class)) { require $class; return true; } $loadedModels = self::$_loadedModelFiles; if (isset($loadedModels[$className]) && file_exists($loadedModels[$className])) { require $loadedModels[$className]; return true; } return false; } public static function dump($var, $output = true, $indent = "") { $ret = array(); switch (gettype($var)) { case 'array': $ret[] = 'Array('; $indent .= "    "; foreach ($var as $k => $v) { $ret[] = $indent . $k . ' : ' . self::dump($v, false, $indent); } $indent = substr($indent,0, -4); $ret[] = $indent . ")"; break; case 'object': $ret[] = 'Object(' . get_class($var) . ')'; break; default: $ret[] = var_export($var, true); } if ($output) { print implode("\n", $ret); } return implode("\n", $ret); } }class Doctrine_Compiler { public static function compile($target = null, $includedDrivers = array()) { if ( ! is_array($includedDrivers)) { $includedDrivers = array($includedDrivers); } $excludedDrivers = array(); if ( ! empty($includedDrivers)) { $drivers = array('db2', 'firebird', 'informix', 'mssql', 'mysql', 'oracle', 'pgsql', 'sqlite'); $excludedDrivers = array_diff($drivers, $includedDrivers); } $path = Doctrine::getPath(); $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($it as $file) { $e = explode('.', $file->getFileName()); if (end($e) === 'php' && strpos($file->getFileName(), '.inc') === false) { require_once $file->getPathName(); } } $classes = array_merge(get_declared_classes(), get_declared_interfaces()); $ret = array(); foreach ($classes as $class) { $e = explode('_', $class); if ($e[0] !== 'Doctrine') { continue; } if ( ! empty($excludedDrivers)) { foreach ($excludedDrivers as $excludedDriver) { $excludedDriver = ucfirst($excludedDriver); if (in_array($excludedDriver, $e)) { continue(2); } } } $refl = new ReflectionClass($class); $file = $refl->getFileName(); $lines = file($file); $start = $refl->getStartLine() - 1; $end = $refl->getEndLine(); $ret = array_merge($ret, array_slice($lines, $start, ($end - $start))); } if ($target == null) { $target = $path . DIRECTORY_SEPARATOR . 'Doctrine.compiled.php'; } $fp = @fopen($target, 'w'); if ($fp === false) { throw new Doctrine_Compiler_Exception("Couldn't write compiled data. Failed to open $target"); } fwrite($fp, "<?php ". implode('', $ret)); fclose($fp); $stripped = php_strip_whitespace($target); $fp = @fopen($target, 'w'); if ($fp === false) { throw new Doctrine_Compiler_Exception("Couldn't write compiled data. Failed to open $file"); } fwrite($fp, $stripped); fclose($fp); return $target; } } class Doctrine_Cli_Formatter { protected $_size = 65; function __construct($maxLineSize = 65) { $this->_size = $maxLineSize; } public function format($text = '', $parameters = array(), $stream = STDOUT) { return $text; } public function formatSection($section, $text, $size = null) { return sprintf(">> %-$9s %s", $section, $this->excerpt($text, $size)); } public function excerpt($text, $size = null) { if ( ! $size) { $size = $this->_size; } if (strlen($text) < $size) { return $text; } $subsize = floor(($size - 3) / 2); return substr($text, 0, $subsize).'...'.substr($text, -$subsize); } public function setMaxLineSize($size) { $this->_size = $size; } }class Doctrine_Exception extends Exception { protected static $_errorMessages = array( Doctrine::ERR => 'unknown error', Doctrine::ERR_ALREADY_EXISTS => 'already exists', Doctrine::ERR_CANNOT_CREATE => 'can not create', Doctrine::ERR_CANNOT_ALTER => 'can not alter', Doctrine::ERR_CANNOT_REPLACE => 'can not replace', Doctrine::ERR_CANNOT_DELETE => 'can not delete', Doctrine::ERR_CANNOT_DROP => 'can not drop', Doctrine::ERR_CONSTRAINT => 'constraint violation', Doctrine::ERR_CONSTRAINT_NOT_NULL=> 'null value violates not-null constraint', Doctrine::ERR_DIVZERO => 'division by zero', Doctrine::ERR_INVALID => 'invalid', Doctrine::ERR_INVALID_DATE => 'invalid date or time', Doctrine::ERR_INVALID_NUMBER => 'invalid number', Doctrine::ERR_MISMATCH => 'mismatch', Doctrine::ERR_NODBSELECTED => 'no database selected', Doctrine::ERR_NOSUCHFIELD => 'no such field', Doctrine::ERR_NOSUCHTABLE => 'no such table', Doctrine::ERR_NOT_CAPABLE => 'Doctrine backend not capable', Doctrine::ERR_NOT_FOUND => 'not found', Doctrine::ERR_NOT_LOCKED => 'not locked', Doctrine::ERR_SYNTAX => 'syntax error', Doctrine::ERR_UNSUPPORTED => 'not supported', Doctrine::ERR_VALUE_COUNT_ON_ROW => 'value count on row', Doctrine::ERR_INVALID_DSN => 'invalid DSN', Doctrine::ERR_CONNECT_FAILED => 'connect failed', Doctrine::ERR_NEED_MORE_DATA => 'insufficient data supplied', Doctrine::ERR_EXTENSION_NOT_FOUND=> 'extension not found', Doctrine::ERR_NOSUCHDB => 'no such database', Doctrine::ERR_ACCESS_VIOLATION => 'insufficient permissions', Doctrine::ERR_LOADMODULE => 'error while including on demand module', Doctrine::ERR_TRUNCATED => 'truncated', Doctrine::ERR_DEADLOCK => 'deadlock detected', ); public function errorMessage($value = null) { if (is_null($value)) { return self::$_errorMessages; } return isset(self::$_errorMessages[$value]) ? self::$_errorMessages[$value] : self::$_errorMessages[Doctrine::ERR]; } } class Doctrine_Cli_Exception extends Doctrine_Exception { }class Doctrine_Cli_AnsiColorFormatter extends Doctrine_Cli_Formatter { protected $_styles = array( 'HEADER' => array('fg' => 'black', 'bold' => true), 'ERROR' => array('bg' => 'red', 'fg' => 'white', 'bold' => true), 'INFO' => array('fg' => 'green', 'bold' => true), 'COMMENT' => array('fg' => 'yellow'), ), $_options = array('bold' => 1, 'underscore' => 4, 'blink' => 5, 'reverse' => 7, 'conceal' => 8), $_foreground = array('black' => 30, 'red' => 31, 'green' => 32, 'yellow' => 33, 'blue' => 34, 'magenta' => 35, 'cyan' => 36, 'white' => 37), $_background = array('black' => 40, 'red' => 41, 'green' => 42, 'yellow' => 43, 'blue' => 44, 'magenta' => 45, 'cyan' => 46, 'white' => 47); public function setStyle($name, $options = array()) { $this->_styles[$name] = $options; } public function format($text = '', $parameters = array(), $stream = STDOUT) { if ( ! $this->supportsColors($stream)) { return $text; } if ( ! is_array($parameters) && 'NONE' == $parameters) { return $text; } if ( ! is_array($parameters) && isset($this->_styles[$parameters])) { $parameters = $this->_styles[$parameters]; } $codes = array(); if (isset($parameters['fg'])) { $codes[] = $this->_foreground[$parameters['fg']]; } if (isset($parameters['bg'])) { $codes[] = $this->_background[$parameters['bg']]; } foreach ($this->_options as $option => $value) { if (isset($parameters[$option]) && $parameters[$option]) { $codes[] = $value; } } return "\033[".implode(';', $codes).'m'.$text."\033[0m"; } public function formatSection($section, $text, $size = null) { $width = 9 + strlen($this->format('', 'INFO')); return sprintf(">> %-${width}s %s", $this->format($section, 'INFO'), $this->excerpt($text, $size)); } public function excerpt($text, $size = null) { if ( ! $size) { $size = $this->size; } if (strlen($text) < $size) { return $text; } $subsize = floor(($size - 3) / 2); return substr($text, 0, $subsize) . $this->format('...', 'INFO').substr($text, -$subsize); } public function supportsColors($stream) { return DIRECTORY_SEPARATOR != '\\' && function_exists('posix_isatty') && @posix_isatty($stream); } }class Doctrine_Log_Filter_Priority implements Doctrine_Log_Filter_Interface { protected $_priority; protected $_operator; public function __construct($priority, $operator = '<=') { if (! is_integer($priority)) { throw new Doctrine_Log_Exception('Priority must be an integer'); } $this->_priority = $priority; $this->_operator = $operator; } public function accept($event) { return version_compare($event['priority'], $this->_priority, $this->_operator); } }class Doctrine_Log_Filter_Message implements Doctrine_Log_Filter_Interface { protected $_regexp; public function __construct($regexp) { if (@preg_match($regexp, '') === false) { throw new Doctrine_Log_Exception("Invalid regular expression '$regexp'"); } $this->_regexp = $regexp; } public function accept($event) { return preg_match($this->_regexp, $event['message']) > 0; } }class Doctrine_Log_Filter_Suppress implements Doctrine_Log_Filter_Interface { protected $_accept = true; public function suppress($suppress) { $this->_accept = (! $suppress); } public function accept($event) { return $this->_accept; } }class Doctrine_Log_Formatter_Xml implements Doctrine_Log_Formatter_Interface { protected $_rootElement; protected $_elementMap; public function __construct($rootElement = 'logEntry', $elementMap = null) { $this->_rootElement = $rootElement; $this->_elementMap = $elementMap; } public function format($event) { if ($this->_elementMap === null) { $dataToInsert = $event; } else { $dataToInsert = array(); foreach ($this->_elementMap as $elementName => $fieldKey) { $dataToInsert[$elementName] = $event[$fieldKey]; } } $dom = new DOMDocument(); $elt = $dom->appendChild(new DOMElement($this->_rootElement)); foreach ($dataToInsert as $key => $value) { $elt->appendChild(new DOMElement($key, $value)); } $xml = $dom->saveXML(); $xml = preg_replace('/<\?xml version="1.0"( encoding="[^\"]*")?\?>\n/u', '', $xml); return $xml . PHP_EOL; } }class Doctrine_Log_Formatter_Simple implements Doctrine_Log_Formatter_Interface { protected $_format; public function __construct($format = null) { if ($format === null) { $format = '%timestamp% %priorityName% (%priority%): %message%' . PHP_EOL; } if (! is_string($format)) { throw new Doctrine_Log_Exception('Format must be a string'); } $this->_format = $format; } public function format($event) { $output = $this->_format; foreach ($event as $name => $value) { $output = str_replace("%$name%", $value, $output); } return $output; } }abstract class Doctrine_Log_Writer_Abstract { protected $_filters = array(); protected $_formatter; public function addFilter($filter) { if (is_integer($filter)) { $filter = new Doctrine_Log_Filter_Priority($filter); } $this->_filters[] = $filter; } public function write($event) { foreach ($this->_filters as $filter) { if (! $filter->accept($event)) { return; } } $this->_write($event); } public function setFormatter($formatter) { $this->_formatter = $formatter; } public function shutdown() {} abstract protected function _write($event); }class Doctrine_Log_Writer_Db extends Doctrine_Log_Writer_Abstract { private $_table; private $_columnMap; public function __construct($table, $columnMap = null) { if (!$table instanceof Doctrine_Table) { $table = Doctrine::getTable($table); } $this->_table = $table; $this->_columnMap = $columnMap; } public function setFormatter($formatter) { throw new Doctrine_Log_Exception(get_class() . ' does not support formatting'); } public function shutdown() { $this->_table = null; } protected function _write($event) { if ($this->_table === null) { throw new Doctrine_Log_Exception('Database adapter instance has been removed by shutdown'); } if ($this->_columnMap === null) { $dataToInsert = $event; } else { $dataToInsert = array(); foreach ($this->_columnMap as $columnName => $fieldKey) { $dataToInsert[$columnName] = $event[$fieldKey]; } } $record = $this->_table->create($dataToInsert); $record->save(); } }class Doctrine_Log_Writer_Stream extends Doctrine_Log_Writer_Abstract { protected $_stream = null; public function __construct($streamOrUrl, $mode = 'a') { if (is_resource($streamOrUrl)) { if (get_resource_type($streamOrUrl) != 'stream') { throw new Doctrine_Log_Exception('Resource is not a stream'); } if ($mode != 'a') { throw new Doctrine_Log_Exception('Mode cannot be changed on existing streams'); } $this->_stream = $streamOrUrl; } else { if (! $this->_stream = @fopen($streamOrUrl, $mode, false)) { $msg = "\"$streamOrUrl\" cannot be opened with mode \"$mode\""; throw new Doctrine_Log_Exception($msg); } } $this->_formatter = new Doctrine_Log_Formatter_Simple(); } public function shutdown() { if (is_resource($this->_stream)) { fclose($this->_stream); } } protected function _write($event) { $line = $this->_formatter->format($event); if (false === @fwrite($this->_stream, $line)) { throw new Doctrine_Log_Exception("Unable to write to stream"); } } }class Doctrine_Log_Writer_Null extends Doctrine_Log_Writer_Abstract { protected function _write($event) { } }class Doctrine_Log_Writer_Mock extends Doctrine_Log_Writer_Abstract { public $events = array(); public $shutdown = false; public function _write($event) { $this->events[] = $event; } public function shutdown() { $this->shutdown = true; } }class Doctrine_Log_Exception extends Doctrine_Exception { }abstract class Doctrine_Parser { abstract public function loadData($array); abstract public function dumpData($array, $path = null); static public function getParser($type) { $class = 'Doctrine_Parser_'.ucfirst($type); return new $class; } static public function load($path, $type = 'xml') { $parser = self::getParser($type); return (array) $parser->loadData($path); } static public function dump($array, $type = 'xml', $path = null) { $parser = self::getParser($type); return $parser->dumpData($array, $path); } public function doLoad($path) { ob_start(); if ( ! file_exists($path)) { $contents = $path; $path = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'dparser_' . microtime(); file_put_contents($path, $contents); } include($path); $contents = ob_get_clean(); return $contents; } public function doDump($data, $path = null) { if ($path !== null) { return file_put_contents($path, $data); } else { return $data; } } }class Doctrine_Data { protected $_formats = array('csv', 'yml', 'xml'); protected $_format = 'yml'; protected $_directory = null; protected $_models = array(); protected $_exportIndividualFiles = false; public function setFormat($format) { $this->_format = $format; } public function getFormat() { return $this->_format; } public function getFormats() { return $this->_formats; } public function setDirectory($directory) { $this->_directory = $directory; } public function getDirectory() { return $this->_directory; } public function setModels($models) { $this->_models = $models; } public function getModels() { return $this->_models; } public function exportIndividualFiles($bool = null) { if ($bool !== null) { $this->_exportIndividualFiles = $bool; } return $this->_exportIndividualFiles; } public function exportData($directory, $format = 'yml', $models = array(), $_exportIndividualFiles = false) { $export = new Doctrine_Data_Export($directory); $export->setFormat($format); $export->setModels($models); $export->exportIndividualFiles($_exportIndividualFiles); return $export->doExport(); } public function importData($directory, $format = 'yml', $models = array(), $append = false) { $import = new Doctrine_Data_Import($directory); $import->setFormat($format); $import->setModels($models); return $import->doImport($append); } public function isRelation(Doctrine_Record $record, $fieldName) { $relations = $record->getTable()->getRelations(); foreach ($relations as $relation) { $relationData = $relation->toArray(); if ($relationData['local'] === $fieldName) { return $relationData; } } return false; } public function purge($models = null) { if ($models) { $models = Doctrine::filterInvalidModels($models); } else { $models = Doctrine::getLoadedModels(); } foreach ($models as $model) { Doctrine::getTable($model)->createQuery()->delete()->execute(); } } }class Doctrine_Data_Import extends Doctrine_Data { protected $_importedObjects = array(); protected $_rows = array(); public function __construct($directory = null) { if ($directory !== null) { $this->setDirectory($directory); } } public function doParsing() { $recursiveMerge = Doctrine_Manager::getInstance()->getAttribute('recursive_merge_fixtures'); $mergeFunction = $recursiveMerge === true ? 'array_merge_recursive':'array_merge'; $directory = $this->getDirectory(); $array = array(); if ($directory !== null) { foreach ((array) $directory as $dir) { $e = explode('.', $dir); if (end($e) == 'yml') { $array = $mergeFunction($array, Doctrine_Parser::load($dir, $this->getFormat())); } else if(is_dir($dir)) { $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($it as $file) { $e = explode('.', $file->getFileName()); if (in_array(end($e), $this->getFormats())) { $array = $mergeFunction($array, Doctrine_Parser::load($file->getPathName(), $this->getFormat())); } } } } } return $array; } public function doImport($append = false) { $array = $this->doParsing(); if ( ! $append) { $this->purge(array_reverse(array_keys($array))); } $this->_loadData($array); } protected function _buildRows($className, $data) { foreach ($data as $rowKey => $row) { $this->_rows[$className][$rowKey] = $row; foreach ((array) $row as $key => $value) { if (Doctrine::getTable($className)->hasRelation($key) && is_array($value)) { $keys = array_keys($value); if ( ! isset($keys[0])) { $this->_buildRows(Doctrine::getTable($className)->getRelation($key)->getTable()->getOption('name'), $value); } } } } } protected function _buildNestedSetRows($className, $data) { foreach ($data as $rowKey => $row) { $children = isset($row['children']) ? $row['children']:array(); unset($row['children']); $this->_rows[$className][$rowKey] = $row; $this->_buildNestedSetRows($className, $children); } } protected function _getImportedObject($rowKey, Doctrine_Record $record, $relationName, $referringRowKey) { if ( ! isset($this->_importedObjects[$rowKey])) { throw new Doctrine_Data_Exception('Invalid row key specified: ' . $rowKey); } $relatedRowKeyObject = $this->_importedObjects[$rowKey]; $relation = $record->getTable()->getRelation($relationName); if ($relation->getClass() !== get_class($relatedRowKeyObject)) { if ( ! is_subclass_of($relatedRowKeyObject, $relation->getClass())) { throw new Doctrine_Data_Exception(sprintf( 'Class referred to in "%s" is expected to be "%s" and "%s" was given', $referringRowKey, $relation->getClass(), get_class($relatedRowKeyObject))); } } return $relatedRowKeyObject; } protected function _processRow($rowKey, $row) { $obj = $this->_importedObjects[$rowKey]; foreach ((array) $row as $key => $value) { if (method_exists($obj, 'set' . Doctrine_Inflector::classify($key))) { $func = 'set' . Doctrine_Inflector::classify($key); $obj->$func($value); } else if ($obj->getTable()->hasField($key)) { $obj->set($key, $value); } else if ($obj->getTable()->hasRelation($key)) { if (is_array($value)) { if (isset($value[0]) && ! is_array($value[0])) { foreach ($value as $link) { if ($obj->getTable()->getRelation($key)->getType() === Doctrine_Relation::ONE) { $obj->set($key, $this->_getImportedObject($link, $obj, $key, $rowKey)); } else if ($obj->getTable()->getRelation($key)->getType() === Doctrine_Relation::MANY) { $relation = $obj->$key; $relation[] = $this->_getImportedObject($link, $obj, $key, $rowKey); } } } else { $obj->$key->fromArray($value); } } else { $obj->set($key, $this->_getImportedObject($value, $obj, $key, $rowKey)); } } else { throw new Doctrine_Data_Exception('Invalid fixture element "'. $key . '" under "' . $rowKey . '"'); } } } protected function _loadData(array $array) { $nestedSets = array(); $specifiedModels = $this->getModels(); $rows = array(); foreach ($array as $className => $data) { if ( ! empty($specifiedModels) && !in_array($className, $specifiedModels)) { continue; } if (Doctrine::getTable($className)->isTree()) { $first = current($data); if (isset($first['children'])) { $nestedSets[$className][] = $data; $this->_buildNestedSetRows($className, $data); } else { $this->_buildRows($className, $data); } } else { $this->_buildRows($className, $data); } } $buildRows = array(); foreach ($this->_rows as $className => $classRows) { foreach ($classRows as $rowKey => $row) { $buildRows[$rowKey] = $row; $this->_importedObjects[$rowKey] = new $className(); $this->_importedObjects[$rowKey]->state('TDIRTY'); } } foreach($buildRows as $rowKey => $row) { $this->_processRow($rowKey, $row); } $objects = array(); foreach ($this->_importedObjects as $object) { $className = get_class($object); $objects[$className] = $className; } $manager = Doctrine_Manager::getInstance(); foreach ($manager as $connection) { $tree = $connection->unitOfWork->buildFlushTree($objects); foreach ($tree as $model) { foreach ($this->_importedObjects as $obj) { $templates = array_keys($obj->getTable()->getTemplates()); if ($obj instanceof $model && ! $obj->getTable()->isTree()) { $obj->save(); } } } } foreach ($nestedSets as $className => $sets) { foreach ($sets as $data) { $this->_loadNestedSetData($className, $data); } } } protected function _loadNestedSetData($model, $nestedSetData, $parent = null) { foreach($nestedSetData AS $rowKey => $nestedSet) { $children = array(); $data = array(); if (array_key_exists('children', $nestedSet)) { $children = $nestedSet['children']; $children = array_reverse($children, true); unset($nestedSet['children']); } $record = $this->_importedObjects[$rowKey]; if( ! $parent) { $record->save(); Doctrine::getTable($model)->getTree()->createRoot($record); } else { $parent->getNode()->addChild($record); } if (is_array($children) AND !empty($children)) { $this->_loadNestedSetData($model, $children, $record); } } } }class Doctrine_Data_Exception extends Doctrine_Exception { }class Doctrine_Data_Export extends Doctrine_Data { public function __construct($directory) { $this->setDirectory($directory); } public function doExport() { $models = Doctrine::getLoadedModels(); $specifiedModels = $this->getModels(); $data = array(); if (empty($models)) { $models = $specifiedModels; } $models = Doctrine::initializeModels($models); $originalIndexBy = array(); foreach ($models AS $name) { $table = Doctrine::getTable($name); if (!is_null($indexBy = $table->getBoundQueryPart('indexBy'))) { $originalIndexBy[$name] = $indexBy; $table->bindQueryPart('indexBy', null); } } foreach ($models AS $name) { if ( ! empty($specifiedModels) AND ! in_array($name, $specifiedModels)) { continue; } $results = Doctrine::getTable($name)->findAll(); if ($results->count() > 0) { $data[$name] = $results; } } foreach($originalIndexBy AS $name => $indexBy) { Doctrine::getTable($name)->bindQueryPart('indexBy', $indexBy); } $data = $this->prepareData($data); return $this->dumpData($data); } public function dumpData(array $data) { $directory = $this->getDirectory(); $format = $this->getFormat(); if ($this->exportIndividualFiles()) { if (is_array($directory)) { throw new Doctrine_Data_Exception('You must specify a single path to a folder in order to export individual files.'); } else if ( ! is_dir($directory) && is_file($directory)) { $directory = dirname($directory); } foreach ($data as $className => $classData) { if ( ! empty($classData)) { Doctrine_Parser::dump(array($className => $classData), $format, $directory.DIRECTORY_SEPARATOR.$className.'.'.$format); } } } else { if (is_dir($directory)) { $directory .= DIRECTORY_SEPARATOR . 'data.' . $format; } if ( ! empty($data)) { return Doctrine_Parser::dump($data, $format, $directory); } } } public function prepareData($data) { $preparedData = array(); foreach ($data AS $className => $classData) { $preparedData[$className] = array(); foreach ($classData as $record) { $className = get_class($record); $recordKey = $className . '_' . implode('_', $record->identifier()); $preparedData[$className][$recordKey] = array(); $recordData = $record->toArray(false); foreach ($recordData as $key => $value) { $keys = $record->getTable()->getIdentifier(); if ( ! is_array($keys)) { $keys = array($keys); } if (count($keys) <= 1 && in_array($key, $keys)) { continue; } if ($relation = $this->isRelation($record, $key)) { $relationAlias = $relation['alias']; $relationRecord = $record->$relationAlias; if ($relationRecord instanceof Doctrine_Collection) { $relationRecord = $relationRecord->getFirst(); } if ($relationRecord instanceof Doctrine_Null || !$relationRecord) { continue; } $relationClassName = get_class($relationRecord); $relationValue = $relationClassName . '_' . $value; $preparedData[$className][$recordKey][$relationAlias] = $relationValue; } else if ($record->getTable()->hasField($key)) { $preparedData[$className][$recordKey][$key] = $value; } } $record->free(); } } return $preparedData; } }class Doctrine_I18n_Exception extends Doctrine_Exception { }class Doctrine_Locator_Injectable { protected $_locator; protected $_resources = array(); protected static $_null; public function setLocator(Doctrine_Locator $locator) { $this->_locator = $locator; return $this; } public function getLocator() { if ( ! isset($this->_locator)) { $this->_locator = Doctrine_Locator::instance(); } return $this->_locator; } public function locate($name) { if (isset($this->_resources[$name])) { if (is_object($this->_resources[$name])) { return $this->_resources[$name]; } else { $concreteImpl = $this->_resources[$name]; return $this->getLocator()->locate($concreteImpl); } } else { return $this->getLocator()->locate($name); } } public function bind($name, $resource) { $this->_resources[$name] = $resource; return $this; } public static function initNullObject(Doctrine_Null $null) { self::$_null = $null; } public static function getNullObject() { return self::$_null; } }abstract class Doctrine_Access extends Doctrine_Locator_Injectable implements ArrayAccess { public function setArray(array $array) { foreach ($array as $k => $v) { $this->set($k, $v); } return $this; } public function __set($name, $value) { $this->set($name, $value); } public function __get($name) { return $this->get($name); } public function __isset($name) { return $this->contains($name); } public function __unset($name) { return $this->remove($name); } public function offsetExists($offset) { return $this->contains($offset); } public function offsetGet($offset) { return $this->get($offset); } public function offsetSet($offset, $value) { if ( ! isset($offset)) { $this->add($value); } else { $this->set($offset, $value); } } public function offsetUnset($offset) { return $this->remove($offset); } public function remove($offset) { throw new Doctrine_Exception('Remove is not supported for ' . get_class($this)); } public function get($offset) { throw new Doctrine_Exception('Get is not supported for ' . get_class($this)); } public function set($offset, $value) { throw new Doctrine_Exception('Set is not supported for ' . get_class($this)); } public function contains($offset) { throw new Doctrine_Exception('Contains is not supported for ' . get_class($this)); } public function add($value) { throw new Doctrine_Exception('Add is not supported for ' . get_class($this)); } }abstract class Doctrine_Record_Abstract extends Doctrine_Access { protected $_table; public function setTableDefinition() { } public function setUp() { } public function getTable() { return $this->_table; } public function addListener($listener, $name = null) { $this->_table->addRecordListener($listener, $name = null); return $this; } public function getListener() { return $this->_table->getRecordListener(); } public function setListener($listener) { $this->_table->setRecordListener($listener); return $this; } public function index($name, array $definition = array()) { if ( ! $definition) { return $this->_table->getIndex($name); } else { return $this->_table->addIndex($name, $definition); } } public function setAttribute($attr, $value) { $this->_table->setAttribute($attr, $value); } public function setTableName($tableName) { $this->_table->setTableName($tableName); } public function setInheritanceMap($map) { $this->_table->setOption('inheritanceMap', $map); } public function setSubclasses($map) { if (isset($map[get_class($this)])) { $mapFieldNames = $map[get_class($this)]; $mapColumnNames = array(); foreach ($mapFieldNames as $fieldName => $val) { $mapColumnNames[$this->getTable()->getColumnName($fieldName)] = $val; } $this->_table->setOption('inheritanceMap', $mapColumnNames); return; } $this->_table->setOption('subclasses', array_keys($map)); } public function attribute($attr, $value) { if ($value == null) { if (is_array($attr)) { foreach ($attr as $k => $v) { $this->_table->setAttribute($k, $v); } } else { return $this->_table->getAttribute($attr); } } else { $this->_table->setAttribute($attr, $value); } } public function option($name, $value = null) { if ($value === null) { if (is_array($name)) { foreach ($name as $k => $v) { $this->_table->setOption($k, $v); } } else { return $this->_table->getOption($name); } } else { $this->_table->setOption($name, $value); } } public function hasOne() { $this->_table->bind(func_get_args(), Doctrine_Relation::ONE); return $this; } public function hasMany() { $this->_table->bind(func_get_args(), Doctrine_Relation::MANY); return $this; } public function hasColumn($name, $type, $length = 2147483647, $options = "") { $this->_table->setColumn($name, $type, $length, $options); } public function hasColumns(array $definitions) { foreach ($definitions as $name => $options) { $length = isset($options['length']) ? $options['length']:null; $this->hasColumn($name, $options['type'], $length, $options); } } public function bindQueryParts(array $queryParts) { $this->_table->bindQueryParts($queryParts); return $this; } public function loadGenerator(Doctrine_Record_Generator $generator) { $generator->initialize($this->_table); $this->_table->addGenerator($generator, get_class($generator)); } public function actAs($tpl, array $options = array()) { if ( ! is_object($tpl)) { $className = 'Doctrine_Template_' . $tpl; if (class_exists($className, true)) { $tpl = new $className($options); } else if (class_exists($tpl, true)) { $tpl = new $tpl($options); } else { throw new Doctrine_Record_Exception('Could not load behavior named: "' . $tpl . '"'); } } if ( ! ($tpl instanceof Doctrine_Template)) { throw new Doctrine_Record_Exception('Loaded behavior class is not an instance of Doctrine_Template.'); } $className = get_class($tpl); $this->_table->addTemplate($className, $tpl); $tpl->setTable($this->_table); $tpl->setUp(); $tpl->setTableDefinition(); return $this; } public function check($constraint, $name = null) { if (is_array($constraint)) { foreach ($constraint as $name => $def) { $this->_table->addCheckConstraint($def, $name); } } else { $this->_table->addCheckConstraint($constraint, $name); } return $this; } } abstract class Doctrine_Record extends Doctrine_Record_Abstract implements Countable, IteratorAggregate, Serializable { const STATE_DIRTY = 1; const STATE_TDIRTY = 2; const STATE_CLEAN = 3; const STATE_PROXY = 4; const STATE_TCLEAN = 5; const STATE_LOCKED = 6; const STATE_TLOCKED = 7; protected $_node; protected $_id = array(); protected $_data = array(); protected $_values = array(); protected $_state; protected $_modified = array(); protected $_errorStack; protected $_references = array(); protected $_pendingDeletes = array(); protected static $_customAccessors = array(); protected static $_customMutators = array(); private static $_index = 1; private $_oid; public function __construct($table = null, $isNewEntry = false) { if (isset($table) && $table instanceof Doctrine_Table) { $this->_table = $table; $exists = ( ! $isNewEntry); } else { $class = get_class($this); $this->_table = Doctrine::getTable($class); $exists = false; } if ( ! $this->_table->getConnection()->hasTable($this->_table->getComponentName())) { return; } $this->_oid = self::$_index; self::$_index++; $this->_data = $this->_table->getData(); $count = count($this->_data); $this->_values = $this->cleanData($this->_data); $this->prepareIdentifiers($exists); if ( ! $exists) { if ($count > count($this->_values)) { $this->_state = Doctrine_Record::STATE_TDIRTY; } else { $this->_state = Doctrine_Record::STATE_TCLEAN; } $this->assignDefaultValues(); } else { $this->_state = Doctrine_Record::STATE_CLEAN; if ($count < $this->_table->getColumnCount()) { $this->_state = Doctrine_Record::STATE_PROXY; } } $repository = $this->_table->getRepository(); $repository->add($this); $this->construct(); } public static function _index() { return self::$_index; } public function setUp() { } public function construct() { } public function getOid() { return $this->_oid; } public function oid() { return $this->_oid; } public function isValid() { if ( ! $this->_table->getAttribute(Doctrine::ATTR_VALIDATE)) { return true; } $this->getErrorStack()->clear(); $event = new Doctrine_Event($this, Doctrine_Event::RECORD_VALIDATE); $this->preValidate($event); $this->getTable()->getRecordListener()->preValidate($event); if ( ! $event->skipOperation) { $validator = new Doctrine_Validator(); $validator->validateRecord($this); $this->validate(); if ($this->_state == self::STATE_TDIRTY || $this->_state == self::STATE_TCLEAN) { $this->validateOnInsert(); } else { $this->validateOnUpdate(); } } $this->getTable()->getRecordListener()->postValidate($event); $this->postValidate($event); return $this->getErrorStack()->count() == 0 ? true : false; } protected function validate() { } protected function validateOnUpdate() { } protected function validateOnInsert() { } public function preSerialize($event) { } public function postSerialize($event) { } public function preUnserialize($event) { } public function postUnserialize($event) { } public function preSave($event) { } public function postSave($event) { } public function preDelete($event) { } public function postDelete($event) { } public function preUpdate($event) { } public function postUpdate($event) { } public function preInsert($event) { } public function postInsert($event) { } public function preValidate($event) { } public function postValidate($event) { } public function preDqlSelect($event) { } public function preDqlUpdate($event) { } public function preDqlDelete($event) { } public function getErrorStack() { if ( ! $this->_errorStack) { $this->_errorStack = new Doctrine_Validator_ErrorStack(get_class($this)); } return $this->_errorStack; } public function errorStack($stack = null) { if ($stack !== null) { if ( ! ($stack instanceof Doctrine_Validator_ErrorStack)) { throw new Doctrine_Record_Exception('Argument should be an instance of Doctrine_Validator_ErrorStack.'); } $this->_errorStack = $stack; } else { return $this->getErrorStack(); } } public function assignInheritanceValues() { $map = $this->_table->inheritanceMap; foreach ($map as $k => $v) { $k = $this->_table->getFieldName($k); $old = $this->get($k, false); if ((string) $old !== (string) $v || $old === null) { $this->set($k, $v); } } } public function assignDefaultValues($overwrite = false) { if ( ! $this->_table->hasDefaultValues()) { return false; } foreach ($this->_data as $column => $value) { $default = $this->_table->getDefaultValueOf($column); if ($default === null) { continue; } if ($value === self::$_null || $overwrite) { $this->_data[$column] = $default; $this->_modified[] = $column; $this->_state = Doctrine_Record::STATE_TDIRTY; } } } public function cleanData(&$data) { $tmp = $data; $data = array(); foreach ($this->getTable()->getFieldNames() as $fieldName) { if (isset($tmp[$fieldName])) { $data[$fieldName] = $tmp[$fieldName]; } else if (array_key_exists($fieldName, $tmp)) { $data[$fieldName] = self::$_null; } else if (!isset($this->_data[$fieldName])) { $data[$fieldName] = self::$_null; } unset($tmp[$fieldName]); } return $tmp; } public function hydrate(array $data) { $this->_values = array_merge($this->_values, $this->cleanData($data)); $this->_data = array_merge($this->_data, $data); if (count($this->_values) < $this->_table->getColumnCount()) { $this->_state = self::STATE_PROXY; } $this->prepareIdentifiers(true); } private function prepareIdentifiers($exists = true) { switch ($this->_table->getIdentifierType()) { case Doctrine::IDENTIFIER_AUTOINC: case Doctrine::IDENTIFIER_SEQUENCE: case Doctrine::IDENTIFIER_NATURAL: $name = $this->_table->getIdentifier(); if (is_array($name)) { $name = $name[0]; } if ($exists) { if (isset($this->_data[$name]) && $this->_data[$name] !== self::$_null) { $this->_id[$name] = $this->_data[$name]; } } break; case Doctrine::IDENTIFIER_COMPOSITE: $names = $this->_table->getIdentifier(); foreach ($names as $name) { if ($this->_data[$name] === self::$_null) { $this->_id[$name] = null; } else { $this->_id[$name] = $this->_data[$name]; } } break; } } public function serialize() { $event = new Doctrine_Event($this, Doctrine_Event::RECORD_SERIALIZE); $this->preSerialize($event); $this->getTable()->getRecordListener()->preSerialize($event); $vars = get_object_vars($this); unset($vars['_references']); unset($vars['_table']); unset($vars['_errorStack']); unset($vars['_filter']); unset($vars['_node']); $name = $this->_table->getIdentifier(); $this->_data = array_merge($this->_data, $this->_id); foreach ($this->_data as $k => $v) { if ($v instanceof Doctrine_Record && $this->_table->getTypeOf($k) != 'object') { unset($vars['_data'][$k]); } elseif ($v === self::$_null) { unset($vars['_data'][$k]); } else { switch ($this->_table->getTypeOf($k)) { case 'array': case 'object': $vars['_data'][$k] = serialize($vars['_data'][$k]); break; case 'gzip': $vars['_data'][$k] = gzcompress($vars['_data'][$k]); break; } } } $str = serialize($vars); $this->postSerialize($event); $this->getTable()->getRecordListener()->postSerialize($event); return $str; } public function unserialize($serialized) { $event = new Doctrine_Event($this, Doctrine_Event::RECORD_UNSERIALIZE); $manager = Doctrine_Manager::getInstance(); $connection = $manager->getConnectionForComponent(get_class($this)); $this->_oid = self::$_index; self::$_index++; $this->_table = $connection->getTable(get_class($this)); $this->preUnserialize($event); $this->getTable()->getRecordListener()->preUnserialize($event); $array = unserialize($serialized); foreach($array as $k => $v) { $this->$k = $v; } foreach ($this->_data as $k => $v) { switch ($this->_table->getTypeOf($k)) { case 'array': case 'object': $this->_data[$k] = unserialize($this->_data[$k]); break; case 'gzip': $this->_data[$k] = gzuncompress($this->_data[$k]); break; case 'enum': $this->_data[$k] = $this->_table->enumValue($k, $this->_data[$k]); break; } } $this->_table->getRepository()->add($this); $this->cleanData($this->_data); $this->prepareIdentifiers($this->exists()); $this->postUnserialize($event); $this->getTable()->getRecordListener()->postUnserialize($event); } public function state($state = null) { if ($state == null) { return $this->_state; } $err = false; if (is_integer($state)) { if ($state >= 1 && $state <= 7) { $this->_state = $state; } else { $err = true; } } else if (is_string($state)) { $upper = strtoupper($state); $const = 'Doctrine_Record::STATE_' . $upper; if (defined($const)) { $this->_state = constant($const); } else { $err = true; } } if ($this->_state === Doctrine_Record::STATE_TCLEAN || $this->_state === Doctrine_Record::STATE_CLEAN) { $this->_modified = array(); } if ($err) { throw new Doctrine_Record_State_Exception('Unknown record state ' . $state); } } public function refresh($deep = false) { $id = $this->identifier(); if ( ! is_array($id)) { $id = array($id); } if (empty($id)) { return false; } $id = array_values($id); if ($deep) { $query = $this->getTable()->createQuery(); foreach (array_keys($this->_references) as $name) { $query->leftJoin(get_class($this) . '.' . $name); } $query->where(implode(' = ? AND ', (array)$this->getTable()->getIdentifier()) . ' = ?'); $this->clearRelated(); $record = $query->fetchOne($id); } else { $record = $this->getTable()->find($id, Doctrine::HYDRATE_ARRAY); if ($record) { $this->hydrate($record); } } if ($record === false) { throw new Doctrine_Record_Exception('Failed to refresh. Record does not exist.'); } $this->_modified = array(); $this->prepareIdentifiers(); $this->_state = Doctrine_Record::STATE_CLEAN; return $this; } public function refreshRelated($name = null) { if (is_null($name)) { foreach ($this->_table->getRelations() as $rel) { $this->_references[$rel->getAlias()] = $rel->fetchRelatedFor($this); } } else { $rel = $this->_table->getRelation($name); $this->_references[$name] = $rel->fetchRelatedFor($this); } } public function clearRelated() { $this->_references = array(); } public function getTable() { return $this->_table; } public function getData() { return $this->_data; } public function rawGet($fieldName) { if ( ! isset($this->_data[$fieldName])) { throw new Doctrine_Record_Exception('Unknown property '. $fieldName); } if ($this->_data[$fieldName] === self::$_null) { return null; } return $this->_data[$fieldName]; } public function load(array $data = array()) { if ($this->_state == Doctrine_Record::STATE_PROXY) { $id = $this->identifier(); if ( ! is_array($id)) { $id = array($id); } if (empty($id)) { return false; } $data = empty($data) ? $this->getTable()->find($id, Doctrine::HYDRATE_ARRAY) : $data; foreach ($data as $field => $value) { if ( ! isset($this->_data[$field]) || $this->_data[$field] === self::$_null) { $this->_data[$field] = $value; } } if ($this->isModified()) { $this->_state = Doctrine_Record::STATE_DIRTY; } else if (count($data) >= $this->_table->getColumnCount()) { $this->_state = Doctrine_Record::STATE_CLEAN; } return true; } return false; } public function get($fieldName, $load = true) { if ($this->_table->getAttribute(Doctrine::ATTR_AUTO_ACCESSOR_OVERRIDE)) { $componentName = $this->_table->getComponentName(); $accessor = isset(self::$_customAccessors[$componentName][$fieldName]) ? self::$_customAccessors[$componentName][$fieldName] : 'get' . Doctrine_Inflector::classify($fieldName); if (isset(self::$_customAccessors[$componentName][$fieldName]) || method_exists($this, $accessor)) { self::$_customAccessors[$componentName][$fieldName] = $accessor; return $this->$accessor($load); } } return $this->_get($fieldName, $load); } protected function _get($fieldName, $load = true) { $value = self::$_null; if (array_key_exists($fieldName, $this->_data)) { if ($this->_data[$fieldName] === self::$_null && $load) { $this->load(); } if ($this->_data[$fieldName] === self::$_null) { $value = null; } else { $value = $this->_data[$fieldName]; } return $value; } if (array_key_exists($fieldName, $this->_values)) { return $this->_values[$fieldName]; } try { if ( ! isset($this->_references[$fieldName]) && $load) { $rel = $this->_table->getRelation($fieldName); $this->_references[$fieldName] = $rel->fetchRelatedFor($this); } if ($this->_references[$fieldName] === self::$_null) { return null; } return $this->_references[$fieldName]; } catch (Doctrine_Table_Exception $e) { $success = false; foreach ($this->_table->getFilters() as $filter) { try { $value = $filter->filterGet($this, $fieldName); $success = true; } catch (Doctrine_Exception $e) {} } if ($success) { return $value; } else { throw $e; } } } public function mapValue($name, $value) { $this->_values[$name] = $value; } public function set($fieldName, $value, $load = true) { if ($this->_table->getAttribute(Doctrine::ATTR_AUTO_ACCESSOR_OVERRIDE)) { $componentName = $this->_table->getComponentName(); $mutator = isset(self::$_customMutators[$componentName][$fieldName]) ? self::$_customMutators[$componentName][$fieldName]:'set' . Doctrine_Inflector::classify($fieldName); if (isset(self::$_customMutators[$componentName][$fieldName]) || method_exists($this, $mutator)) { self::$_customMutators[$componentName][$fieldName] = $mutator; return $this->$mutator($value, $load); } } return $this->_set($fieldName, $value, $load); } protected function _set($fieldName, $value, $load = true) { if (isset($this->_data[$fieldName])) { $type = $this->_table->getTypeOf($fieldName); if ($value instanceof Doctrine_Record) { $id = $value->getIncremented(); if ($id !== null && $type !== 'object') { $value = $id; } } if ($load) { $old = $this->get($fieldName, $load); } else { $old = $this->_data[$fieldName]; } if ($this->_isValueModified($type, $old, $value)) { if ($value === null) { $default = $this->_table->getDefaultValueOf($fieldName); $value = ($default === null) ? self::$_null : $default; } $this->_data[$fieldName] = $value; $this->_modified[] = $fieldName; switch ($this->_state) { case Doctrine_Record::STATE_CLEAN: case Doctrine_Record::STATE_PROXY: $this->_state = Doctrine_Record::STATE_DIRTY; break; case Doctrine_Record::STATE_TCLEAN: $this->_state = Doctrine_Record::STATE_TDIRTY; break; } } } else { try { $this->coreSetRelated($fieldName, $value); } catch (Doctrine_Table_Exception $e) { $success = false; foreach ($this->_table->getFilters() as $filter) { try { $value = $filter->filterSet($this, $fieldName, $value); $success = true; } catch (Doctrine_Exception $e) {} } if ($success) { return $value; } else { throw $e; } } } return $this; } protected function _isValueModified($type, $old, $new) { if ($type == 'boolean' && (is_bool($old) || is_numeric($old)) && (is_bool($new) || is_numeric($new)) && $old == $new) { return false; } else if (in_array($type, array('decimal', 'float')) && is_numeric($old) && is_numeric($new)) { return $old * 100 != $new * 100; } else { return $old !== $new; } } public function coreSetRelated($name, $value) { $rel = $this->_table->getRelation($name); if ($value === null) { $value = self::$_null; } if ($rel instanceof Doctrine_Relation_ForeignKey || $rel instanceof Doctrine_Relation_LocalKey) { if ( ! $rel->isOneToOne()) { if ( ! ($value instanceof Doctrine_Collection)) { throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Collection when setting one-to-many references."); } if (isset($this->_references[$name])) { $this->_references[$name]->setData($value->getData()); return $this; } } else { $localFieldName = $this->_table->getFieldName($rel->getLocal()); if ($value !== self::$_null) { $relatedTable = $value->getTable(); $foreignFieldName = $relatedTable->getFieldName($rel->getForeign()); } if ( ! ($value instanceof Doctrine_Record) && ! ($value instanceof Doctrine_Null)) { throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Record or Doctrine_Null when setting one-to-one references."); } if ($rel instanceof Doctrine_Relation_LocalKey) { if ($value !== self::$_null && ! empty($foreignFieldName) && $foreignFieldName != $value->getTable()->getIdentifier()) { $this->set($localFieldName, $value->rawGet($foreignFieldName), false); } else { $this->set($localFieldName, $value, false); } } elseif ($value !== self::$_null) { $value->set($foreignFieldName, $this, false); } } } else if ($rel instanceof Doctrine_Relation_Association) { if ( ! ($value instanceof Doctrine_Collection)) { throw new Doctrine_Record_Exception("Couldn't call Doctrine::set(), second argument should be an instance of Doctrine_Collection when setting many-to-many references."); } } $this->_references[$name] = $value; } public function contains($fieldName) { if (isset($this->_data[$fieldName])) { return true; } if (isset($this->_id[$fieldName])) { return true; } if (isset($this->_values[$fieldName])) { return true; } if (isset($this->_references[$fieldName]) && $this->_references[$fieldName] !== self::$_null) { return true; } return false; } public function __unset($name) { if (isset($this->_data[$name])) { $this->_data[$name] = array(); } else if (isset($this->_references[$name])) { if ($this->_references[$name] instanceof Doctrine_Record) { $this->_pendingDeletes[] = $this->$name; $this->_references[$name] = self::$_null; } elseif ($this->_references[$name] instanceof Doctrine_Collection) { $this->_pendingDeletes[] = $this->$name; $this->_references[$name]->setData(array()); } } } public function getPendingDeletes() { return $this->_pendingDeletes; } public function save(Doctrine_Connection $conn = null) { if ($conn === null) { $conn = $this->_table->getConnection(); } $conn->unitOfWork->saveGraph($this); } public function trySave(Doctrine_Connection $conn = null) { try { $this->save($conn); return true; } catch (Doctrine_Validator_Exception $ignored) { return false; } } public function replace(Doctrine_Connection $conn = null) { if ($conn === null) { $conn = $this->_table->getConnection(); } if ($this->exists()) { return $this->save(); } else { if ($this->isValid()) { $identifier = (array) $this->getTable()->getIdentifier(); $data = $this->getPrepared(); return $conn->replace($this->_table, $data, $identifier); } else { return false; } } } public function getModified() { $a = array(); foreach ($this->_modified as $k => $v) { $a[$v] = $this->_data[$v]; } return $a; } public function modifiedFields() { $a = array(); foreach ($this->_modified as $k => $v) { $a[$v] = $this->_data[$v]; } return $a; } public function getPrepared(array $array = array()) { $a = array(); if (empty($array)) { $modifiedFields = $this->_modified; } foreach ($modifiedFields as $field) { $type = $this->_table->getTypeOf($field); if ($this->_data[$field] === self::$_null) { $a[$field] = null; continue; } switch ($type) { case 'array': case 'object': $a[$field] = serialize($this->_data[$field]); break; case 'gzip': $a[$field] = gzcompress($this->_data[$field],5); break; case 'boolean': $a[$field] = $this->getTable()->getConnection()->convertBooleans($this->_data[$field]); break; default: if ($this->_data[$field] instanceof Doctrine_Record) { $a[$field] = $this->_data[$field]->getIncremented(); if ($a[$field] !== null) { $this->_data[$field] = $a[$field]; } } else { $a[$field] = $this->_data[$field]; } } } return $a; } public function count() { return count($this->_data); } public function columnCount() { return $this->count(); } public function toArray($deep = true, $prefixKey = false) { if ($this->_state == self::STATE_LOCKED || $this->_state == self::STATE_TLOCKED) { return false; } $stateBeforeLock = $this->_state; $this->_state = $this->exists() ? self::STATE_LOCKED : self::STATE_TLOCKED; $a = array(); foreach ($this as $column => $value) { if ($value === self::$_null || is_object($value)) { $value = null; } $a[$column] = $value; } if ($this->_table->getIdentifierType() == Doctrine::IDENTIFIER_AUTOINC) { $i = $this->_table->getIdentifier(); $a[$i] = $this->getIncremented(); } if ($deep) { foreach ($this->_references as $key => $relation) { if (! $relation instanceof Doctrine_Null) { $a[$key] = $relation->toArray($deep, $prefixKey); } } } foreach ($this->_values as $key => $value) { if ($value instanceof Doctrine_Record) { $a[$key] = $value->toArray($deep, $prefixKey); } else { $a[$key] = $value; } } $this->_state = $stateBeforeLock; return $a; } public function merge($data, $deep = true) { if ($data instanceof $this) { $array = $data->toArray($deep); } else if (is_array($data)) { $array = $data; } return $this->fromArray($array, $deep); } public function fromArray(array $array, $deep = true) { $refresh = false; foreach ($array as $key => $value) { if ($key == '_identifier') { $refresh = true; $this->assignIdentifier($value); continue; } if ($deep && $this->getTable()->hasRelation($key)) { if ( ! $this->$key) { $this->refreshRelated($key); } if (is_array($value)) { $this->$key->fromArray($value, $deep); } } else if ($this->getTable()->hasField($key)) { $this->set($key, $value); } } if ($refresh) { $this->refresh(); } } public function synchronizeWithArray(array $array, $deep = true) { $refresh = false; foreach ($array as $key => $value) { if ($key == '_identifier') { $refresh = true; $this->assignIdentifier($value); continue; } if ($deep && $this->getTable()->hasRelation($key)) { if ( ! $this->$key) { $this->refreshRelated($key); } if (is_array($value)) { $this->get($key)->synchronizeWithArray($value); } } else if ($this->getTable()->hasField($key)) { $this->set($key, $value); } } foreach ($this->_references as $name => $obj) { if ( ! isset($array[$name])) { unset($this->$name); } } if ($refresh) { $this->refresh(); } } public function exportTo($type, $deep = true) { if ($type == 'array') { return $this->toArray($deep); } else { return Doctrine_Parser::dump($this->toArray($deep, true), $type); } } public function importFrom($type, $data) { if ($type == 'array') { return $this->fromArray($data); } else { return $this->fromArray(Doctrine_Parser::load($data, $type)); } } public function exists() { return ($this->_state !== Doctrine_Record::STATE_TCLEAN && $this->_state !== Doctrine_Record::STATE_TDIRTY && $this->_state !== Doctrine_Record::STATE_TLOCKED); } public function isModified() { return ($this->_state === Doctrine_Record::STATE_DIRTY || $this->_state === Doctrine_Record::STATE_TDIRTY); } public function hasRelation($fieldName) { if (isset($this->_data[$fieldName]) || isset($this->_id[$fieldName])) { return true; } return $this->_table->hasRelation($fieldName); } public function getIterator() { return new Doctrine_Record_Iterator($this); } public function delete(Doctrine_Connection $conn = null) { if ($conn == null) { $conn = $this->_table->getConnection(); } return $conn->unitOfWork->delete($this); } public function copy($deep = false) { $data = $this->_data; if ($this->_table->getIdentifierType() === Doctrine::IDENTIFIER_AUTOINC) { $id = $this->_table->getIdentifier(); unset($data[$id]); } $ret = $this->_table->create($data); $modified = array(); foreach ($data as $key => $val) { if ( ! ($val instanceof Doctrine_Null)) { $ret->_modified[] = $key; } } if ($deep) { foreach ($this->_references as $key => $value) { if ($value instanceof Doctrine_Collection) { foreach ($value as $record) { $ret->{$key}[] = $record->copy($deep); } } else if($value instanceof Doctrine_Record) { $ret->set($key, $value->copy($deep)); } } } return $ret; } public function assignIdentifier($id = false) { if ($id === false) { $this->_id = array(); $this->_data = $this->cleanData($this->_data); $this->_state = Doctrine_Record::STATE_TCLEAN; $this->_modified = array(); } elseif ($id === true) { $this->prepareIdentifiers(true); $this->_state = Doctrine_Record::STATE_CLEAN; $this->_modified = array(); } else { if (is_array($id)) { foreach ($id as $fieldName => $value) { $this->_id[$fieldName] = $value; $this->_data[$fieldName] = $value; } } else { $name = $this->_table->getIdentifier(); $this->_id[$name] = $id; $this->_data[$name] = $id; } $this->_state = Doctrine_Record::STATE_CLEAN; $this->_modified = array(); } } public function identifier() { return $this->_id; } final public function getIncremented() { $id = current($this->_id); if ($id === false) { return null; } return $id; } public function getLast() { return $this; } public function hasReference($name) { return isset($this->_references[$name]); } public function reference($name) { if (isset($this->_references[$name])) { return $this->_references[$name]; } } public function obtainReference($name) { if (isset($this->_references[$name])) { return $this->_references[$name]; } throw new Doctrine_Record_Exception("Unknown reference $name"); } public function getReferences() { return $this->_references; } final public function setRelated($alias, Doctrine_Access $coll) { $this->_references[$alias] = $coll; } public function loadReference($name) { $rel = $this->_table->getRelation($name); $this->_references[$name] = $rel->fetchRelatedFor($this); } public function call($callback, $column) { $args = func_get_args(); array_shift($args); if (isset($args[0])) { $fieldName = $args[0]; $args[0] = $this->get($fieldName); $newvalue = call_user_func_array($callback, $args); $this->_data[$fieldName] = $newvalue; } return $this; } public function getNode() { if ( ! $this->_table->isTree()) { return false; } if ( ! isset($this->_node)) { $this->_node = Doctrine_Node::factory($this, $this->getTable()->getOption('treeImpl'), $this->getTable()->getOption('treeOptions') ); } return $this->_node; } public function unshiftFilter(Doctrine_Record_Filter $filter) { return $this->_table->unshiftFilter($filter); } public function unlink($alias, $ids = array()) { $ids = (array) $ids; $q = new Doctrine_Query(); $rel = $this->getTable()->getRelation($alias); if ($rel instanceof Doctrine_Relation_Association) { $q->delete() ->from($rel->getAssociationTable()->getComponentName()) ->where($rel->getLocal() . ' = ?', array_values($this->identifier())); if (count($ids) > 0) { $q->whereIn($rel->getForeign(), $ids); } $q->execute(); } else if ($rel instanceof Doctrine_Relation_ForeignKey) { $q->update($rel->getTable()->getComponentName()) ->set($rel->getForeign(), '?', array(null)) ->addWhere($rel->getForeign() . ' = ?', array_values($this->identifier())); if (count($ids) > 0) { $q->whereIn($rel->getTable()->getIdentifier(), $ids); } $q->execute(); } if (isset($this->_references[$alias])) { foreach ($this->_references[$alias] as $k => $record) { if (in_array(current($record->identifier()), $ids)) { $this->_references[$alias]->remove($k); } } $this->_references[$alias]->takeSnapshot(); } return $this; } public function link($alias, $ids) { $ids = (array) $ids; if ( ! count($ids)) { return $this; } $identifier = array_values($this->identifier()); $identifier = array_shift($identifier); $rel = $this->getTable()->getRelation($alias); if ($rel instanceof Doctrine_Relation_Association) { $modelClassName = $rel->getAssociationTable()->getComponentName(); $localFieldName = $rel->getLocalFieldName(); $localFieldDef = $rel->getAssociationTable()->getColumnDefinition($localFieldName); if ($localFieldDef['type'] == 'integer') { $identifier = (integer) $identifier; } $foreignFieldName = $rel->getForeignFieldName(); $foreignFieldDef = $rel->getAssociationTable()->getColumnDefinition($foreignFieldName); if ($foreignFieldDef['type'] == 'integer') { for ($i = 0; $i < count($ids); $i++) { $ids[$i] = (integer) $ids[$i]; } } foreach ($ids as $id) { $record = new $modelClassName; $record[$localFieldName] = $identifier; $record[$foreignFieldName] = $id; $record->save(); } } else if ($rel instanceof Doctrine_Relation_ForeignKey) { $q = new Doctrine_Query(); $q->update($rel->getTable()->getComponentName()) ->set($rel->getForeign(), '?', array_values($this->identifier())); if (count($ids) > 0) { $q->whereIn($rel->getTable()->getIdentifier(), $ids); } $q->execute(); } else if ($rel instanceof Doctrine_Relation_LocalKey) { $q = new Doctrine_Query(); $q->update($this->getTable()->getComponentName()) ->set($rel->getLocalFieldName(), '?', $ids); if (count($ids) > 0) { $q->whereIn($rel->getTable()->getIdentifier(), array_values($this->identifier())); } $q->execute(); } return $this; } public function __call($method, $args) { if (($template = $this->_table->getMethodOwner($method)) !== false) { $template->setInvoker($this); return call_user_func_array(array($template, $method), $args); } foreach ($this->_table->getTemplates() as $template) { if (method_exists($template, $method)) { $template->setInvoker($this); $this->_table->setMethodOwner($method, $template); return call_user_func_array(array($template, $method), $args); } } throw new Doctrine_Record_Exception(sprintf('Unknown method %s::%s', get_class($this), $method)); } public function deleteNode() { $this->getNode()->delete(); } public function free($deep = false) { if ($this->_state != self::STATE_LOCKED && $this->_state != self::STATE_TLOCKED) { $this->_state = $this->exists() ? self::STATE_LOCKED : self::STATE_TLOCKED; $this->_table->getRepository()->evict($this->_oid); $this->_table->removeRecord($this); $this->_data = array(); $this->_id = array(); if ($deep) { foreach ($this->_references as $name => $reference) { if ( ! ($reference instanceof Doctrine_Null)) { $reference->free($deep); } } } $this->_references = array(); } } public function toString() { return Doctrine::dump(get_object_vars($this)); } public function __toString() { return (string) $this->_oid; } }class Doctrine_File_Index extends Doctrine_Record { public function setTableDefinition() { $this->hasColumn('keyword', 'string', 255, array('notnull' => true, 'primary' => true)); $this->hasColumn('field', 'string', 50, array('notnull' => true, 'primary' => true)); $this->hasColumn('position', 'string', 255, array('notnull' => true, 'primary' => true)); $this->hasColumn('file_id', 'integer', 8, array('notnull' => true, 'primary' => true)); } public function setUp() { $this->hasOne('Doctrine_File', array('local' => 'file_id', 'foreign' => 'id', 'onDelete' => 'CASCADE', 'onUpdate' => 'CASCADE')); } }abstract class Doctrine_Hook_Parser { protected $condition; protected $params = array(); public function getCondition() { return $this->condition; } public function getParams() { return $this->params; } abstract public function parse($alias, $field, $value); }abstract class Doctrine_Hook_Parser_Complex extends Doctrine_Hook_Parser { protected $_tokenizer; public function __construct() { $this->_tokenizer = new Doctrine_Query_Tokenizer(); } public function parse($alias, $field, $value) { $this->condition = $this->parseClause($alias, $field, $value); } public function parseClause($alias, $field, $value) { $parts = $this->_tokenizer->quoteExplode($value, ' AND '); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $ret[] = $this->parseSingle($alias, $field, $part); } $r = implode(' AND ', $ret); } else { $parts = $this->_tokenizer->quoteExplode($value, ' OR '); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $ret[] = $this->parseClause($alias, $field, $part); } $r = implode(' OR ', $ret); } else { $ret = $this->parseSingle($alias, $field, $parts[0]); return $ret; } } return '(' . $r . ')'; } abstract public function parseSingle($alias, $field, $value); }class Doctrine_Hook_WordLike extends Doctrine_Hook_Parser_Complex { public function parseSingle($alias, $field, $value) { if (strpos($value, "'") !== false) { $value = $this->_tokenizer->bracketTrim($value, "'", "'"); $a[] = $alias . '.' . $field . ' LIKE ?'; $this->params[] = '%' . $value . '%'; } else { $e2 = explode(' ',$value); foreach ($e2 as $v) { $v = trim($v); $a[] = $alias . '.' . $field . ' LIKE ?'; $this->params[] = '%' . $v . '%'; } } return implode(' OR ', $a); } } class Doctrine_Hook_Integer extends Doctrine_Hook_Parser_Complex { public function parseSingle($alias, $field, $value) { $e = explode(' ', $value); foreach ($e as $v) { $v = trim($v); $e2 = explode('-', $v); $name = $alias. '.' . $field; if (count($e2) == 1) { $a[] = $name . ' = ?'; $this->params[] = $v; } else { $a[] = '(' . $name . ' > ? AND ' . $name . ' < ?)'; $this->params += array($e2[0], $e2[1]); } } return implode(' OR ', $a); } }class Doctrine_Hook_Equal extends Doctrine_Hook_Parser { public function parse($alias, $field, $value) { $this->params = (array) $value; $this->condition = $alias . '.' . $field . ' = ?'; } }abstract class Doctrine_Record_Generator extends Doctrine_Record_Abstract { protected $_options = array('generateFiles' => false, 'generatePath' => false, 'builderOptions' => array(), 'identifier' => false, 'table' => false, 'pluginTable' => false, 'children' => array()); protected $_initialized = false; public function __get($option) { if (isset($this->_options[$option])) { return $this->_options[$option]; } return null; } public function __isset($option) { return isset($this->_options[$option]); } public function getOption($name) { if ( ! isset($this->_options[$name])) { throw new Doctrine_Exception('Unknown option ' . $name); } return $this->_options[$name]; } public function setOption($name, $value) { $this->_options[$name] = $value; return $this; } public function addChild($generator) { $this->_options['children'][] = $generator; } public function getOptions() { return $this->_options; } public function initialize(Doctrine_Table $table) { if ($this->_initialized) { return false; } $this->_initialized = true; $this->initOptions(); $table->addGenerator($this, get_class($this)); $this->_options['table'] = $table; $this->_options['className'] = str_replace('%CLASS%', $this->_options['table']->getComponentName(), $this->_options['className']); if ($this->_options['generateFiles'] === false && class_exists($this->_options['className'], false)) { return false; } $this->buildTable(); $fk = $this->buildForeignKeys($this->_options['table']); $this->_table->setColumns($fk); $this->buildRelation(); $this->setTableDefinition(); $this->setUp(); $definition = array(); $definition['columns'] = $this->_table->getColumns(); $definition['tableName'] = $this->_table->getTableName(); $this->generateClass($definition); $this->buildChildDefinitions(); $this->_table->initIdentifier(); } public function buildTable() { $conn = $this->_options['table']->getConnection(); $conn->getManager()->bindComponent($this->_options['className'], $conn->getName()); $this->_table = new Doctrine_Table($this->_options['className'], $conn); if (isset($this->_options['tableName']) && $this->_options['tableName']) { $this->_table->setTableName($this->_options['tableName']); } $options = $this->_options['table']->getOptions(); $newOptions = array(); $maintain = array('type', 'collate', 'charset'); foreach ($maintain as $key) { if (isset($options[$key])) { $newOptions[$key] = $options[$key]; } } $this->_table->setOptions($newOptions); $conn->addTable($this->_table); } public function initOptions() { } public function buildChildDefinitions() { if ( ! isset($this->_options['children'])) { throw new Doctrine_Record_Exception("Unknown option 'children'."); } foreach ($this->_options['children'] as $child) { if ($child instanceof Doctrine_Template) { if ($child->getPlugin() !== null) { $this->_table->addGenerator($child->getPlugin(), get_class($child->getPlugin())); } $child->setTable($this->_table); $child->setTableDefinition(); $child->setUp(); } else { $this->_table->addGenerator($child, get_class($child)); $child->initialize($this->_table); } } } public function buildForeignKeys(Doctrine_Table $table) { $fk = array(); foreach ((array) $table->getIdentifier() as $column) { $def = $table->getDefinitionOf($column); unset($def['autoincrement']); unset($def['sequence']); unset($def['primary']); $col = $column; $def['primary'] = true; $fk[$col] = $def; } return $fk; } public function buildLocalRelation() { $options = array('local' => $this->_options['table']->getIdentifier(), 'foreign' => $this->_options['table']->getIdentifier(), 'type' => Doctrine_Relation::MANY); $options['type'] = Doctrine_Relation::ONE; $options['onDelete'] = 'CASCADE'; $options['onUpdate'] = 'CASCADE'; $this->_table->getRelationParser()->bind($this->_options['table']->getComponentName(), $options); } public function buildForeignRelation($alias = null) { $options = array('local' => $this->_options['table']->getIdentifier(), 'foreign' => $this->_options['table']->getIdentifier(), 'type' => Doctrine_Relation::MANY); $aliasStr = ''; if ($alias !== null) { $aliasStr = ' as ' . $alias; } $this->_options['table']->getRelationParser()->bind($this->_table->getComponentName() . $aliasStr, $options); } public function buildRelation() { $this->buildForeignRelation(); $this->buildLocalRelation(); } public function generateClass(array $definition = array()) { $definition['className'] = $this->_options['className']; $builder = new Doctrine_Import_Builder(); if ($this->_options['generateFiles']) { if (isset($this->_options['generatePath']) && $this->_options['generatePath']) { $builder->setTargetPath($this->_options['generatePath']); $builderOptions = isset($this->_options['builderOptions']) ? (array) $this->_options['builderOptions']:array(); $builder->setOptions($builderOptions); $builder->buildRecord($definition); } else { throw new Doctrine_Record_Exception('If you wish to generate files then you must specify the path to generate the files in.'); } } else { $def = $builder->buildDefinition($definition); eval($def); } } }class Doctrine_I18n extends Doctrine_Record_Generator { protected $_options = array( 'className' => '%CLASS%Translation', 'fields' => array(), 'generateFiles' => false, 'table' => false, 'pluginTable' => false, 'children' => array(), 'type' => 'string', 'length' => 2, 'options' => array() ); public function __construct($options) { $this->_options = Doctrine_Lib::arrayDeepMerge($this->_options, $options); } public function buildRelation() { $this->buildForeignRelation('Translation'); $this->buildLocalRelation(); } public function setTableDefinition() { if (empty($this->_options['fields'])) { throw new Doctrine_I18n_Exception('Fields not set.'); } $options = array('className' => $this->_options['className']); $cols = $this->_options['table']->getColumns(); foreach ($cols as $column => $definition) { if (in_array($column, $this->_options['fields'])) { $columns[$column] = $definition; $this->_options['table']->removeColumn($column); } } $this->hasColumns($columns); $options = $this->_options['options']; $options['fixed'] = true; $options['primary'] = true; $this->hasColumn('lang', $this->_options['type'], $this->_options['length'], $options); $this->bindQueryParts(array('indexBy' => 'lang')); $originalName = $this->_options['table']->getClassnameToReturn(); $relations = $this->_options['table']->getRelationParser()->getPendingRelations(); foreach($relations as $table => $relation) { if ($table != $this->_table->getTableName() ) { if (isset($relation['local']) && in_array($relation['local'], $this->_options['fields'])) { $this->_options['table']->getRelationParser()->unsetPendingRelations($table); $this->_table->getRelationParser()->bind($table, $relation); $rp = Doctrine::getTable($table)->getRelationParser(); $others = $rp->getPendingRelation($originalName); if (isset($others)) { $others['class'] = $this->_table->getClassnameToReturn(); $others['alias'] = $this->_table->getClassnameToReturn(); $rp->unsetPendingRelations($originalName); $rp->bind($this->_table->getClassnameToReturn() ,$others); } } } } } }class Doctrine_Node_NestedSet_PreOrderIterator implements Iterator { protected $collection; protected $keys; protected $key; protected $index; protected $prevIndex; protected $traverseLevel; protected $count; public function __construct($record, $opts) { $componentName = $record->getTable()->getComponentName(); $q = $record->getTable()->createQuery(); $params = array($record->get('lft'), $record->get('rgt')); if (isset($opts['include_record']) && $opts['include_record']) { $query = $q->where("$componentName.lft >= ? AND $componentName.rgt <= ?", $params)->orderBy("$componentName.lft asc"); } else { $query = $q->where("$componentName.lft > ? AND $componentName.rgt < ?", $params)->orderBy("$componentName.lft asc"); } $query = $record->getTable()->getTree()->returnQueryWithRootId($query, $record->getNode()->getRootValue()); $this->maxLevel = isset($opts['depth']) ? ($opts['depth'] + $record->getNode()->getLevel()) : 0; $this->options = $opts; $this->collection = isset($opts['collection']) ? $opts['collection'] : $query->execute(); $this->keys = $this->collection->getKeys(); $this->count = $this->collection->count(); $this->index = -1; $this->level = $record->getNode()->getLevel(); $this->prevLeft = $record->getNode()->getLeftValue(); $record->getTable()->clear(); } public function rewind() { $this->index = -1; $this->key = null; } public function key() { return $this->key; } public function current() { $record = $this->collection->get($this->key); $record->getNode()->setLevel($this->level); return $record; } public function next() { while ($current = $this->advanceIndex()) { if ($this->maxLevel && ($this->level > $this->maxLevel)) { continue; } return $current; } return false; } public function valid() { return ($this->index < $this->count); } public function count() { return $this->count; } private function updateLevel() { if ( ! (isset($this->options['include_record']) && $this->options['include_record'] && $this->index == 0)) { $left = $this->collection->get($this->key)->getNode()->getLeftValue(); $this->level += $this->prevLeft - $left + 2; $this->prevLeft = $left; } } private function advanceIndex() { $this->index++; $i = $this->index; if (isset($this->keys[$i])) { $this->key = $this->keys[$i]; $this->updateLevel(); return $this->current(); } return false; } }class Doctrine_Node_NestedSet_PostOrderIterator { }class Doctrine_Node_NestedSet_LevelOrderIterator { }class Doctrine_Node implements IteratorAggregate { protected $record; protected $options; protected $iteratorType; protected $iteratorOptions; protected $_tree; public function __construct(Doctrine_Record $record, $options) { $this->record = $record; $this->options = $options; $class = $record->getTable()->getComponentName(); $thisTable = $record->getTable(); $table = $thisTable; if ($thisTable->getOption('inheritanceMap')) { while ( ! $subclasses = $table->getOption('subclasses')) { $class = get_parent_class($class); $reflectionClass = new ReflectionClass($class); if ($reflectionClass->isAbstract()) { continue; } if ($class == 'Doctrine_Record') { throw new Doctrine_Node_Exception("No subclasses specified. You are " . "using Single Table Inheritance with NestedSet but you have " . "not specified the subclasses correctly. Make sure you use " . "setSubclasses() in the root class of your hierarchy."); } $table = $table->getConnection()->getTable($class); } } if ($thisTable !== $table) { $this->_tree = $table->getTree(); } else { $this->_tree = $thisTable->getTree(); } } public static function factory(Doctrine_Record $record, $implName, $options = array()) { $class = 'Doctrine_Node_' . $implName; if ( ! class_exists($class)) { throw new Doctrine_Node_Exception("The class $class must exist and extend Doctrine_Node"); } return new $class($record, $options); } public function setRecord(Doctrine_Record $record) { $this->record = $record; } public function getRecord() { return $this->record; } public function traverse($type = 'Pre', $options = array()) { return $this->getIterator($type, $options); } public function getIterator($type = null, $options = null) { if ($type === null) { $type = (isset($this->iteratorType) ? $this->iteratorType : 'Pre'); } if ($options === null) { $options = (isset($this->iteratorOptions) ? $this->iteratorOptions : array()); } $implName = $this->record->getTable()->getOption('treeImpl'); $iteratorClass = 'Doctrine_Node_' . $implName . '_' . ucfirst(strtolower($type)) . 'OrderIterator'; return new $iteratorClass($this->record, $options); } public function setIteratorType($type) { $this->iteratorType = $type; } public function setIteratorOptions($options) { $this->iteratorOptions = $options; } }abstract class Doctrine_Node_MaterializedPath extends Doctrine_Node implements Doctrine_Node_Interface { }class Doctrine_Node_NestedSet extends Doctrine_Node implements Doctrine_Node_Interface { public function hasPrevSibling() { return $this->isValidNode($this->getPrevSibling()); } public function hasNextSibling() { return $this->isValidNode($this->getNextSibling()); } public function hasChildren() { return (($this->getRightValue() - $this->getLeftValue() ) >1 ); } public function hasParent() { return !$this->isRoot(); } public function getPrevSibling() { $baseAlias = $this->_tree->getBaseAlias(); $q = $this->_tree->getBaseQuery(); $q = $q->addWhere("$baseAlias.rgt = ?", $this->getLeftValue() - 1); $q = $this->_tree->returnQueryWithRootId($q, $this->getRootValue()); $result = $q->execute(); if (count($result) <= 0) { return false; } if ($result instanceof Doctrine_Collection) { $sibling = $result->getFirst(); } else if (is_array($result)) { $sibling = array_shift($result); } return $sibling; } public function getNextSibling() { $baseAlias = $this->_tree->getBaseAlias(); $q = $this->_tree->getBaseQuery(); $q = $q->addWhere("$baseAlias.lft = ?", $this->getRightValue() + 1); $q = $this->_tree->returnQueryWithRootId($q, $this->getRootValue()); $result = $q->execute(); if (count($result) <= 0) { return false; } if ($result instanceof Doctrine_Collection) { $sibling = $result->getFirst(); } else if (is_array($result)) { $sibling = array_shift($result); } return $sibling; } public function getSiblings($includeNode = false) { $parent = $this->getParent(); $siblings = array(); if ($parent && $parent->exists()) { foreach ($parent->getNode()->getChildren() as $child) { if ($this->isEqualTo($child) && !$includeNode) { continue; } $siblings[] = $child; } } return $siblings; } public function getFirstChild() { $baseAlias = $this->_tree->getBaseAlias(); $q = $this->_tree->getBaseQuery(); $q->addWhere("$baseAlias.lft = ?", $this->getLeftValue() + 1); $this->_tree->returnQueryWithRootId($q, $this->getRootValue()); $result = $q->execute(); if (count($result) <= 0) { return false; } if ($result instanceof Doctrine_Collection) { $child = $result->getFirst(); } else if (is_array($result)) { $child = array_shift($result); } return $child; } public function getLastChild() { $baseAlias = $this->_tree->getBaseAlias(); $q = $this->_tree->getBaseQuery(); $q->addWhere("$baseAlias.rgt = ?", $this->getRightValue() - 1); $this->_tree->returnQueryWithRootId($q, $this->getRootValue()); $result = $q->execute(); if (count($result) <= 0) { return false; } if ($result instanceof Doctrine_Collection) { $child = $result->getFirst(); } else if (is_array($result)) { $child = array_shift($result); } return $child; } public function getChildren() { return $this->getDescendants(1); } public function getDescendants($depth = null, $includeNode = false) { $baseAlias = $this->_tree->getBaseAlias(); $q = $this->_tree->getBaseQuery(); $params = array($this->record->get('lft'), $this->record->get('rgt')); if ($includeNode) { $q->addWhere("$baseAlias.lft >= ? AND $baseAlias.rgt <= ?", $params)->addOrderBy("$baseAlias.lft asc"); } else { $q->addWhere("$baseAlias.lft > ? AND $baseAlias.rgt < ?", $params)->addOrderBy("$baseAlias.lft asc"); } if ($depth !== null) { $q->addWhere("$baseAlias.level <= ?", $this->record['level'] + $depth); } $q = $this->_tree->returnQueryWithRootId($q, $this->getRootValue()); $result = $q->execute(); if (count($result) <= 0) { return false; } return $result; } public function getParent() { $baseAlias = $this->_tree->getBaseAlias(); $q = $this->_tree->getBaseQuery(); $q->addWhere("$baseAlias.lft < ? AND $baseAlias.rgt > ?", array($this->getLeftValue(), $this->getRightValue())) ->addOrderBy("$baseAlias.rgt asc"); $q = $this->_tree->returnQueryWithRootId($q, $this->getRootValue()); $result = $q->execute(); if (count($result) <= 0) { return false; } if ($result instanceof Doctrine_Collection) { $parent = $result->getFirst(); } else if (is_array($result)) { $parent = array_shift($result); } return $parent; } public function getAncestors($depth = null) { $baseAlias = $this->_tree->getBaseAlias(); $q = $this->_tree->getBaseQuery(); $q->addWhere("$baseAlias.lft < ? AND $baseAlias.rgt > ?", array($this->getLeftValue(), $this->getRightValue())) ->addOrderBy("$baseAlias.lft asc"); if ($depth !== null) { $q->addWhere("$baseAlias.level >= ?", $this->record['level'] - $depth); } $q = $this->_tree->returnQueryWithRootId($q, $this->getRootValue()); $ancestors = $q->execute(); if (count($ancestors) <= 0) { return false; } return $ancestors; } public function getPath($seperator = ' > ', $includeRecord = false) { $path = array(); $ancestors = $this->getAncestors(); if ($ancestors) { foreach ($ancestors as $ancestor) { $path[] = $ancestor->__toString(); } } if ($includeRecord) { $path[] = $this->getRecord()->__toString(); } return implode($seperator, $path); } public function getNumberChildren() { return count($this->getChildren()); } public function getNumberDescendants() { return ($this->getRightValue() - $this->getLeftValue() - 1) / 2; } public function insertAsParentOf(Doctrine_Record $dest) { if ($this->isValidNode()) { return false; } if ($dest->getNode()->isRoot()) { return false; } if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot insert node as parent of itself"); return false; } $newLeft = $dest->getNode()->getLeftValue(); $newRight = $dest->getNode()->getRightValue() + 2; $newRoot = $dest->getNode()->getRootValue(); $newLevel = $dest->getNode()->getLevel(); $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $this->shiftRLValues($dest->getNode()->getRightValue() + 1, 2, $newRoot); $componentName = $this->_tree->getBaseComponent(); $q = new Doctrine_Query(); $q->update($componentName); $q->set("$componentName.lft", "$componentName.lft + 1"); $q->set("$componentName.rgt", "$componentName.rgt + 1"); $q->set("$componentName.level", "$componentName.level + 1"); $q->where("$componentName.lft >= ? AND $componentName.rgt <= ?", array($newLeft, $newRight)); $q = $this->_tree->returnQueryWithRootId($q, $newRoot); $q->execute(); $this->record['level'] = $newLevel; $this->insertNode($newLeft, $newRight, $newRoot); $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return true; } public function insertAsPrevSiblingOf(Doctrine_Record $dest) { if ($this->isValidNode()) { return false; } if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot insert node as previous sibling of itself"); return false; } $newLeft = $dest->getNode()->getLeftValue(); $newRight = $dest->getNode()->getLeftValue() + 1; $newRoot = $dest->getNode()->getRootValue(); $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $this->shiftRLValues($newLeft, 2, $newRoot); $this->record['level'] = $dest['level']; $this->insertNode($newLeft, $newRight, $newRoot); $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return true; } public function insertAsNextSiblingOf(Doctrine_Record $dest) { if ($this->isValidNode()) { return false; } if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot insert node as next sibling of itself"); return false; } $newLeft = $dest->getNode()->getRightValue() + 1; $newRight = $dest->getNode()->getRightValue() + 2; $newRoot = $dest->getNode()->getRootValue(); $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $this->shiftRLValues($newLeft, 2, $newRoot); $this->record['level'] = $dest['level']; $this->insertNode($newLeft, $newRight, $newRoot); $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return true; } public function insertAsFirstChildOf(Doctrine_Record $dest) { if ($this->isValidNode()) { return false; } if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot insert node as first child of itself"); return false; } $newLeft = $dest->getNode()->getLeftValue() + 1; $newRight = $dest->getNode()->getLeftValue() + 2; $newRoot = $dest->getNode()->getRootValue(); $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $this->shiftRLValues($newLeft, 2, $newRoot); $this->record['level'] = $dest['level'] + 1; $this->insertNode($newLeft, $newRight, $newRoot); $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return true; } public function insertAsLastChildOf(Doctrine_Record $dest) { if ($this->isValidNode()) { return false; } if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot insert node as last child of itself"); return false; } $newLeft = $dest->getNode()->getRightValue(); $newRight = $dest->getNode()->getRightValue() + 1; $newRoot = $dest->getNode()->getRootValue(); $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $this->shiftRLValues($newLeft, 2, $newRoot); $this->record['level'] = $dest['level'] + 1; $this->insertNode($newLeft, $newRight, $newRoot); $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return true; } private function _moveBetweenTrees(Doctrine_Record $dest, $newLeftValue, $moveType) { $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $newRoot = $dest->getNode()->getRootValue(); $oldRoot = $this->getRootValue(); $oldLft = $this->getLeftValue(); $oldRgt = $this->getRightValue(); $oldLevel = $this->record['level']; $this->shiftRlValues($newLeftValue, $oldRgt - $oldLft - 1, $newRoot); $this->setRootValue($newRoot); $this->record->save(); $first = $oldRgt + 1; $delta = $oldLft - $oldRgt - 1; $this->shiftRLValues($first, $delta, $oldRoot); $this->setRightValue(0); $this->setLeftValue(0); switch ($moveType) { case 'moveAsPrevSiblingOf': $this->insertAsPrevSiblingOf($dest); break; case 'moveAsFirstChildOf': $this->insertAsFirstChildOf($dest); break; case 'moveAsNextSiblingOf': $this->insertAsNextSiblingOf($dest); break; case 'moveAsLastChildOf': $this->insertAsLastChildOf($dest); break; default: throw new Exception("Unknown move operation: $moveType."); } $diff = $oldRgt - $oldLft; $this->setRightValue($this->getLeftValue() + ($oldRgt - $oldLft)); $this->record->save(); $newLevel = $this->record['level']; $levelDiff = $newLevel - $oldLevel; $diff = $this->getLeftValue() - $oldLft; $componentName = $this->_tree->getBaseComponent(); $rootColName = $this->_tree->getAttribute('rootColumnName'); $q = new Doctrine_Query($conn); $q = $q->update($componentName) ->set($componentName . '.lft', $componentName.'.lft + ?', $diff) ->set($componentName . '.rgt', $componentName.'.rgt + ?', $diff) ->set($componentName . '.level', $componentName.'.level + ?', $levelDiff) ->set($componentName . '.' . $rootColName, '?', $newRoot) ->where($componentName . '.lft > ? AND ' . $componentName . '.rgt < ?', array($oldLft, $oldRgt)); $q = $this->_tree->returnQueryWithRootId($q, $oldRoot); $q->execute(); $conn->commit(); return true; } catch (Exception $e) { $conn->rollback(); throw $e; } return false; } public function moveAsPrevSiblingOf(Doctrine_Record $dest) { if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot move node as previous sibling of itself"); return false; } if ($dest->getNode()->getRootValue() != $this->getRootValue()) { return $this->_moveBetweenTrees($dest, $dest->getNode()->getLeftValue(), __FUNCTION__); } else { $oldLevel = $this->record['level']; $this->record['level'] = $dest['level']; $this->updateNode($dest->getNode()->getLeftValue(), $this->record['level'] - $oldLevel); } return true; } public function moveAsNextSiblingOf(Doctrine_Record $dest) { if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot move node as next sibling of itself"); return false; } if ($dest->getNode()->getRootValue() != $this->getRootValue()) { return $this->_moveBetweenTrees($dest, $dest->getNode()->getRightValue() + 1, __FUNCTION__); } else { $oldLevel = $this->record['level']; $this->record['level'] = $dest['level']; $this->updateNode($dest->getNode()->getRightValue() + 1, $this->record['level'] - $oldLevel); } return true; } public function moveAsFirstChildOf(Doctrine_Record $dest) { if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot move node as first child of itself"); return false; } if ($dest->getNode()->getRootValue() != $this->getRootValue()) { return $this->_moveBetweenTrees($dest, $dest->getNode()->getLeftValue() + 1, __FUNCTION__); } else { $oldLevel = $this->record['level']; $this->record['level'] = $dest['level'] + 1; $this->updateNode($dest->getNode()->getLeftValue() + 1, $this->record['level'] - $oldLevel); } return true; } public function moveAsLastChildOf(Doctrine_Record $dest) { if ( $dest === $this->record || ($dest->exists() && $this->record->exists() && $dest->identifier() === $this->record->identifier()) ) { throw new Doctrine_Tree_Exception("Cannot move node as last child of itself"); return false; } if ($dest->getNode()->getRootValue() != $this->getRootValue()) { return $this->_moveBetweenTrees($dest, $dest->getNode()->getRightValue(), __FUNCTION__); } else { $oldLevel = $this->record['level']; $this->record['level'] = $dest['level'] + 1; $this->updateNode($dest->getNode()->getRightValue(), $this->record['level'] - $oldLevel); } return true; } public function makeRoot($newRootId) { if ($this->getLeftValue() == 1 || ! $this->_tree->getAttribute('hasManyRoots')) { return false; } $oldRgt = $this->getRightValue(); $oldLft = $this->getLeftValue(); $oldRoot = $this->getRootValue(); $oldLevel = $this->record['level']; $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $first = $oldRgt + 1; $delta = $oldLft - $oldRgt - 1; $this->shiftRLValues($first, $delta, $this->getRootValue()); $this->setLeftValue(1); $this->setRightValue($oldRgt - $oldLft + 1); $this->setRootValue($newRootId); $this->record['level'] = 0; $diff = 1 - $oldLft; $newRoot = $newRootId; $componentName = $this->_tree->getBaseComponent(); $rootColName = $this->_tree->getAttribute('rootColumnName'); $q = new Doctrine_Query($conn); $q = $q->update($componentName) ->set($componentName . '.lft', $componentName.'.lft + ?', $diff) ->set($componentName . '.rgt', $componentName.'.rgt + ?', $diff) ->set($componentName . '.level', $componentName.'.level - ?', $oldLevel) ->set($componentName . '.' . $rootColName, '?', $newRoot) ->where($componentName . '.lft > ? AND ' . $componentName . '.rgt < ?', array($oldLft, $oldRgt)); $q = $this->_tree->returnQueryWithRootId($q, $oldRoot); $q->execute(); $conn->commit(); return true; } catch (Exception $e) { $conn->rollback(); throw $e; } return false; } public function addChild(Doctrine_Record $record) { $record->getNode()->insertAsLastChildOf($this->getRecord()); } public function isLeaf() { return (($this->getRightValue() - $this->getLeftValue()) == 1); } public function isRoot() { return ($this->getLeftValue() == 1); } public function isEqualTo(Doctrine_Record $subj) { return (($this->getLeftValue() == $subj->getNode()->getLeftValue()) && ($this->getRightValue() == $subj->getNode()->getRightValue()) && ($this->getRootValue() == $subj->getNode()->getRootValue()) ); } public function isDescendantOf(Doctrine_Record $subj) { return (($this->getLeftValue() > $subj->getNode()->getLeftValue()) && ($this->getRightValue() < $subj->getNode()->getRightValue()) && ($this->getRootValue() == $subj->getNode()->getRootValue())); } public function isDescendantOfOrEqualTo(Doctrine_Record $subj) { return (($this->getLeftValue() >= $subj->getNode()->getLeftValue()) && ($this->getRightValue() <= $subj->getNode()->getRightValue()) && ($this->getRootValue() == $subj->getNode()->getRootValue())); } public function isValidNode($record = null) { if ($record === null) { return ($this->getRightValue() > $this->getLeftValue()); } else if ( $record instanceof Doctrine_Record ) { return ($record->getNode()->getRightValue() > $record->getNode()->getLeftValue()); } else { return false; } } public function detach() { $this->setLeftValue(0); $this->setRightValue(0); } public function delete() { $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $oldRoot = $this->getRootValue(); $q = $this->_tree->getBaseQuery(); $baseAlias = $this->_tree->getBaseAlias(); $componentName = $this->_tree->getBaseComponent(); $q = $q->addWhere("$baseAlias.lft >= ? AND $baseAlias.rgt <= ?", array($this->getLeftValue(), $this->getRightValue())); $q = $this->_tree->returnQueryWithRootId($q, $oldRoot); $coll = $q->execute(); $coll->delete(); $first = $this->getRightValue() + 1; $delta = $this->getLeftValue() - $this->getRightValue() - 1; $this->shiftRLValues($first, $delta, $oldRoot); $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return true; } private function insertNode($destLeft = 0, $destRight = 0, $destRoot = 1) { $this->setLeftValue($destLeft); $this->setRightValue($destRight); $this->setRootValue($destRoot); $this->record->save(); } private function updateNode($destLeft, $levelDiff) { $componentName = $this->_tree->getBaseComponent(); $left = $this->getLeftValue(); $right = $this->getRightValue(); $rootId = $this->getRootValue(); $treeSize = $right - $left + 1; $conn = $this->record->getTable()->getConnection(); try { $conn->beginInternalTransaction(); $this->shiftRLValues($destLeft, $treeSize, $rootId); if ($left >= $destLeft) { $left += $treeSize; $right += $treeSize; } $q = new Doctrine_Query(); $q = $q->update($componentName) ->set($componentName . '.level', $componentName.'.level + ?') ->where($componentName . '.lft > ? AND ' . $componentName . '.rgt < ?', array($levelDiff, $left, $right)); $q = $this->_tree->returnQueryWithRootId($q, $rootId); $q->execute(); $this->shiftRLRange($left, $right, $destLeft - $left, $rootId); $this->shiftRLValues($right + 1, -$treeSize, $rootId); $this->record->save(); $this->record->refresh(); $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return true; } private function shiftRlValues($first, $delta, $rootId = 1) { $qLeft = new Doctrine_Query(); $qRight = new Doctrine_Query(); $componentName = $this->_tree->getBaseComponent(); $qLeft = $qLeft->update($componentName) ->set($componentName . '.lft', $componentName.'.lft + ?', $delta) ->where($componentName . '.lft >= ?', $first); $qLeft = $this->_tree->returnQueryWithRootId($qLeft, $rootId); $resultLeft = $qLeft->execute(); $resultRight = $qRight->update($componentName) ->set($componentName . '.rgt', $componentName.'.rgt + ?', $delta) ->where($componentName . '.rgt >= ?', $first); $qRight = $this->_tree->returnQueryWithRootId($qRight, $rootId); $resultRight = $qRight->execute(); } private function shiftRlRange($first, $last, $delta, $rootId = 1) { $qLeft = new Doctrine_Query(); $qRight = new Doctrine_Query(); $componentName = $this->_tree->getBaseComponent(); $qLeft = $qLeft->update($componentName) ->set($componentName . '.lft', $componentName.'.lft + ?', $delta) ->where($componentName . '.lft >= ? AND ' . $componentName . '.lft <= ?', array($first, $last)); $qLeft = $this->_tree->returnQueryWithRootId($qLeft, $rootId); $resultLeft = $qLeft->execute(); $qRight = $qRight->update($componentName) ->set($componentName . '.rgt', $componentName.'.rgt + ?', $delta) ->where($componentName . '.rgt >= ? AND ' . $componentName . '.rgt <= ?', array($first, $last)); $qRight = $this->_tree->returnQueryWithRootId($qRight, $rootId); $resultRight = $qRight->execute(); } public function getLeftValue() { return $this->record->get('lft'); } public function setLeftValue($lft) { $this->record->set('lft', $lft); } public function getRightValue() { return $this->record->get('rgt'); } public function setRightValue($rgt) { $this->record->set('rgt', $rgt); } public function getLevel() { if ( ! isset($this->record['level'])) { $baseAlias = $this->_tree->getBaseAlias(); $componentName = $this->_tree->getBaseComponent(); $q = $this->_tree->getBaseQuery(); $q = $q->addWhere("$baseAlias.lft < ? AND $baseAlias.rgt > ?", array($this->getLeftValue(), $this->getRightValue())); $q = $this->_tree->returnQueryWithRootId($q, $this->getRootValue()); $coll = $q->execute(); $this->record['level'] = count($coll) ? count($coll) : 0; } return $this->record['level']; } public function getRootValue() { if ($this->_tree->getAttribute('hasManyRoots')) { return $this->record->get($this->_tree->getAttribute('rootColumnName')); } return 1; } public function setRootValue($value) { if ($this->_tree->getAttribute('hasManyRoots')) { $this->record->set($this->_tree->getAttribute('rootColumnName'), $value); } } }class Doctrine_Node_Exception extends Doctrine_Exception { }class Doctrine_Node_MaterializedPath_PreOrderIterator implements Iterator { private $topNode = null; private $curNode = null; public function __construct($node, $opts) { throw new Doctrine_Exception('Not yet implemented'); } public function rewind() { throw new Doctrine_Exception('Not yet implemented'); } public function valid() { throw new Doctrine_Exception('Not yet implemented'); } public function current() { throw new Doctrine_Exception('Not yet implemented'); } public function key() { throw new Doctrine_Exception('Not yet implemented'); } public function next() { throw new Doctrine_Exception('Not yet implemented'); } }class Doctrine_Node_MaterializedPath_PostOrderIterator implements Iterator { private $topNode = null; private $curNode = null; public function __construct($node, $opts) { throw new Doctrine_Exception('Not yet implemented'); } public function rewind() { throw new Doctrine_Exception('Not yet implemented'); } public function valid() { throw new Doctrine_Exception('Not yet implemented'); } public function current() { throw new Doctrine_Exception('Not yet implemented'); } public function key() { throw new Doctrine_Exception('Not yet implemented'); } public function next() { throw new Doctrine_Exception('Not yet implemented'); } }class Doctrine_Node_MaterializedPath_LevelOrderIterator implements Iterator { private $topNode = null; private $curNode = null; public function __construct($node, $opts) { throw new Doctrine_Exception('Not yet implemented'); } public function rewind() { throw new Doctrine_Exception('Not yet implemented'); } public function valid() { throw new Doctrine_Exception('Not yet implemented'); } public function current() { throw new Doctrine_Exception('Not yet implemented'); } public function key() { throw new Doctrine_Exception('Not yet implemented'); } public function next() { throw new Doctrine_Exception('Not yet implemented'); } }abstract class Doctrine_Node_AdjacencyList extends Doctrine_Node implements Doctrine_Node_Interface { }abstract class Doctrine_Node_AdjacencyList_PreOrderIterator implements Iterator { }abstract class Doctrine_Node_AdjacencyList_PostOrderIterator implements Iterator { }abstract class Doctrine_Node_AdjacencyList_LevelOrderIterator implements Iterator { }abstract class Doctrine_Task { public $dispatcher = null, $taskName = null, $description = null, $arguments = array(), $requiredArguments = array(), $optionalArguments = array(); public function __construct($dispatcher = null) { $this->dispatcher = $dispatcher; $this->taskName = str_replace('_', '-', Doctrine_Inflector::tableize(str_replace('Doctrine_Task_', '', get_class($this)))); } public function notify($notification = null) { if (is_object($this->dispatcher) && method_exists($this->dispatcher, 'notify')) { $args = func_get_args(); return call_user_func_array(array($this->dispatcher, 'notify'), $args); } else if ( $notification !== null ) { return $notification; } else { return false; } } public function ask() { $args = func_get_args(); call_user_func_array(array($this, 'notify'), $args); $answer = strtolower(trim(fgets(STDIN))); return $answer; } abstract function execute(); public function validate() { $requiredArguments = $this->getRequiredArguments(); foreach ($requiredArguments as $arg) { if ( ! isset($this->arguments[$arg])) { return false; } } return true; } public function addArgument($name, $value) { $this->arguments[$name] = $value; } public function getArgument($name, $default = null) { if (isset($this->arguments[$name]) && $this->arguments[$name] !== null) { return $this->arguments[$name]; } else { return $default; } } public function getArguments() { return $this->arguments; } public function setArguments(array $args) { $this->arguments = $args; } public function getTaskName() { return $this->taskName; } public function getDescription() { return $this->description; } public function getRequiredArguments() { return array_keys($this->requiredArguments); } public function getOptionalArguments() { return array_keys($this->optionalArguments); } public function getRequiredArgumentsDescriptions() { return $this->requiredArguments; } public function getOptionalArgumentsDescriptions() { return $this->optionalArguments; } }class Doctrine_Task_CreateTables extends Doctrine_Task { public $description = 'Create tables for all existing database connections. If table exists nothing happens.', $requiredArguments = array('models_path' => 'Specify path to your models directory.'), $optionalArguments = array(); public function execute() { Doctrine::createTablesFromModels($this->getArgument('models_path')); $this->notify('Created tables successfully'); } }class Doctrine_Task_RebuildDb extends Doctrine_Task { public $description = 'Drops and re-creates databases', $requiredArguments = array(), $optionalArguments = array(); public function __construct($dispatcher = null) { parent::__construct($dispatcher); $this->dropDb = new Doctrine_Task_DropDb($this->dispatcher); $this->buildAll = new Doctrine_Task_BuildAll($this->dispatcher); $this->requiredArguments = array_merge($this->requiredArguments, $this->dropDb->requiredArguments, $this->buildAll->requiredArguments); $this->optionalArguments = array_merge($this->optionalArguments, $this->dropDb->optionalArguments, $this->buildAll->optionalArguments); } public function execute() { $this->dropDb->setArguments($this->getArguments()); $this->dropDb->execute(); $this->buildAll->setArguments($this->getArguments()); $this->buildAll->execute(); } }class Doctrine_Task_GenerateModelsDb extends Doctrine_Task { public $description = 'Generates your Doctrine_Record definitions from your existing database connections.', $requiredArguments = array('models_path' => 'Specify path to your Doctrine_Record definitions.'), $optionalArguments = array('connection' => 'Optionally specify a single connection to generate the models for.'); public function execute() { Doctrine::generateModelsFromDb($this->getArgument('models_path'), (array) $this->getArgument('connection')); $this->notify('Generated models successfully from databases'); } } class Doctrine_Task_GenerateModelsYaml extends Doctrine_Task { public $description = 'Generates your Doctrine_Record definitions from a Yaml schema file', $requiredArguments = array('yaml_schema_path' => 'Specify the complete directory path to your yaml schema files.', 'models_path' => 'Specify complete path to your Doctrine_Record definitions.'), $optionalArguments = array('generate_models_options' => 'Array of options for generating models'); public function execute() { Doctrine::generateModelsFromYaml($this->getArgument('yaml_schema_path'), $this->getArgument('models_path'), $this->getArgument('generate_models_options', array())); $this->notify('Generated models successfully from YAML schema'); } } class Doctrine_Task_GenerateYamlDb extends Doctrine_Task { public $description = 'Generates a Yaml schema file from an existing database', $requiredArguments = array('yaml_schema_path' => 'Specify the path to your yaml schema files.'), $optionalArguments = array(); public function execute() { Doctrine::generateYamlFromDb($this->getArgument('yaml_schema_path')); $this->notify('Generate YAML schema successfully from database'); } }class Doctrine_Task_LoadData extends Doctrine_Task { public $description = 'Load data from a yaml data fixture file.', $requiredArguments = array('data_fixtures_path' => 'Specify the complete path to load the yaml data fixtures files from.', 'models_path' => 'Specify path to your Doctrine_Record definitions.'), $optionalArguments = array(); public function execute() { Doctrine::loadModels($this->getArgument('models_path')); Doctrine::loadData($this->getArgument('data_fixtures_path')); $this->notify('Data was successfully loaded'); } }class Doctrine_Task_BuildAllLoad extends Doctrine_Task { public $description = 'Calls build-all, and load-data', $requiredArguments = array(), $optionalArguments = array(); public function __construct($dispatcher = null) { parent::__construct($dispatcher); $this->buildAll = new Doctrine_Task_BuildAll($this->dispatcher); $this->loadData = new Doctrine_Task_LoadData($this->dispatcher); $this->requiredArguments = array_merge($this->requiredArguments, $this->buildAll->requiredArguments, $this->loadData->requiredArguments); $this->optionalArguments = array_merge($this->optionalArguments, $this->buildAll->optionalArguments, $this->loadData->optionalArguments); } public function execute() { $this->buildAll->setArguments($this->getArguments()); $this->buildAll->execute(); $this->loadData->setArguments($this->getArguments()); $this->loadData->execute(); } }class Doctrine_Task_GenerateMigrationsModels extends Doctrine_Task { public $description = 'Generate migration classes for an existing set of models', $requiredArguments = array('migrations_path' => 'Specify the path to your migration classes folder.', 'models_path' => 'Specify the path to your doctrine models folder.'), $optionalArguments = array(); public function execute() { Doctrine::generateMigrationsFromModels($this->getArgument('migrations_path'), $this->getArgument('models_path')); $this->notify('Generated migration classes successfully from models'); } }class Doctrine_Task_Exception extends Doctrine_Exception { }class Doctrine_Task_BuildAll extends Doctrine_Task { public $description = 'Calls generate-models-from-yaml, create-db, and create-tables', $requiredArguments = array(), $optionalArguments = array(); protected $models, $tables; public function __construct($dispatcher = null) { parent::__construct($dispatcher); $this->models = new Doctrine_Task_GenerateModelsYaml($this->dispatcher); $this->createDb = new Doctrine_Task_CreateDb($this->dispatcher); $this->tables = new Doctrine_Task_CreateTables($this->dispatcher); $this->requiredArguments = array_merge($this->requiredArguments, $this->models->requiredArguments, $this->createDb->requiredArguments, $this->tables->requiredArguments); $this->optionalArguments = array_merge($this->optionalArguments, $this->models->optionalArguments, $this->createDb->optionalArguments, $this->tables->optionalArguments); } public function execute() { $this->models->setArguments($this->getArguments()); $this->models->execute(); $this->createDb->setArguments($this->getArguments()); $this->createDb->execute(); $this->tables->setArguments($this->getArguments()); $this->tables->execute(); } }class Doctrine_Task_CreateDb extends Doctrine_Task { public $description = 'Create all databases for your connections. If the database already exists, nothing happens.', $optionalArguments = array(); public function execute() { $results = Doctrine::createDatabases(); foreach ($results as $name => $result) { $msg = $result instanceof Exception ? 'Could not create database for connection: "' .$name . '." Failed with exception: ' . $result->getMessage():$result; $this->notify($msg); } } }class Doctrine_Task_Migrate extends Doctrine_Task { public $description = 'Migrate database to latest version or the specified version', $requiredArguments = array('migrations_path' => 'Specify path to your migrations directory.'), $optionalArguments = array('version' => 'Version to migrate to. If you do not specify, the db will be migrated from the current version to the latest.'); public function execute() { $version = Doctrine::migrate($this->getArgument('migrations_path'), $this->getArgument('version')); $this->notify('migrated successfully to version #' . $version); } }class Doctrine_Task_GenerateYamlModels extends Doctrine_Task { public $description = 'Generates a Yaml schema file from existing Doctrine_Record definitions', $requiredArguments = array('yaml_schema_path' => 'Specify the complete directory path to your yaml schema files.', 'models_path' => 'Specify complete path to your Doctrine_Record definitions.'), $optionalArguments = array(); public function execute() { Doctrine::generateYamlFromModels($this->getArgument('yaml_schema_path'), $this->getArgument('models_path')); $this->notify('Generated YAML schema successfully from models'); } }class Doctrine_Task_DumpData extends Doctrine_Task { public $description = 'Dump data to a yaml data fixture file.', $requiredArguments = array('data_fixtures_path' => 'Specify path to write the yaml data fixtures file to.', 'models_path' => 'Specify path to your Doctrine_Record definitions.'), $optionalArguments = array(); public function execute() { $models = Doctrine::loadModels($this->getArgument('models_path')); if (empty($models)) { throw new Doctrine_Task_Exception('No models were loaded'); } $path = $this->getArgument('data_fixtures_path'); if (is_array($path) && count($path) > 0) { $path = $path[0]; } if ( ! empty($path)) { Doctrine::dumpData($path); $this->notify(sprintf('Dumped data successfully to: %s', $path)); } else { throw new Doctrine_Task_Exception('Unable to find data fixtures path.'); } } }class Doctrine_Task_Dql extends Doctrine_Task { public $description = 'Execute dql query and display the results', $requiredArguments = array('models_path' => 'Specify path to your Doctrine_Record definitions.', 'dql_query' => 'Specify the complete dql query to execute.'), $optionalArguments = array('params' => 'Comma separated list of the params to replace the ? tokens in the dql'); public function execute() { Doctrine::loadModels($this->getArgument('models_path')); $dql = $this->getArgument('dql_query'); $query = new Doctrine_Query(); $params = $this->getArgument('params'); $params = $params ? explode(',', $params):array(); $this->notify('executing: "' . $dql . '" (' . implode(', ', $params) . ')'); $results = $query->query($dql, $params, Doctrine::HYDRATE_ARRAY); $this->_printResults($results); } protected function _printResults($array) { $yaml = Doctrine_Parser::dump($array, 'yml'); $lines = explode("\n", $yaml); unset($lines[0]); foreach ($lines as $yamlLine) { $line = trim($yamlLine); if ($line) { $this->notify($yamlLine); } } } }class Doctrine_Task_LoadDummyData extends Doctrine_Task { public $description = 'Load data from a yaml data fixture file.', $requiredArguments = array('models_path' => 'Specify path to your Doctrine_Record definitions.'), $optionalArguments = array('append' => 'Whether or not to append the data or to delete all data before loading.', 'num' => 'Number of records to populate for each model.'); public function execute() { Doctrine::loadModels($this->getArgument('models_path')); Doctrine::loadDummyData($this->getArgument('append') ? true:false, $this->getArgument('num') ? $this->getArgument('num'):5); $this->dispatcher->notify('Dummy data was successfully loaded'); } }class Doctrine_Task_GenerateMigrationsDb extends Doctrine_Task { public $description = 'Generate migration classes for an existing database', $requiredArguments = array('migrations_path' => 'Specify the complete path to your migration classes folder.'), $optionalArguments = array(); public function execute() { Doctrine::generateMigrationsFromDb($this->getArgument('migrations_path')); $this->notify('Generated migration classes successfully from database'); } }class Doctrine_Task_Compile extends Doctrine_Task { public $description = 'Compile doctrine classes in to one single php file', $requiredArguments = array(), $optionalArguments = array('drivers' => 'Specify list of drivers you wish to compile. Ex: mysql|mssql|sqlite', 'compiled_path' => 'The path where you want to write the compiled doctrine libs.'); public function execute() { $compiledPath = Doctrine::compile($this->getArgument('compiled_path'), $this->getArgument('drivers', array())); $this->notify('Compiled Doctrine successfully to: ' . $compiledPath); } }class Doctrine_Task_GenerateSql extends Doctrine_Task { public $description = 'Generate sql for all existing database connections.', $requiredArguments = array('models_path' => 'Specify complete path to your Doctrine_Record definitions.', 'sql_path' => 'Path to write the generated sql.'), $optionalArguments = array(); public function execute() { if (is_dir($this->getArgument('sql_path'))) { $path = $this->getArgument('sql_path') . DIRECTORY_SEPARATOR . 'schema.sql'; } else if (is_file($this->getArgument('sql_path'))) { $path = $this->getArgument('sql_path'); } else { throw new Doctrine_Task_Exception('Invalid sql path.'); } $sql = Doctrine::generateSqlFromModels($this->getArgument('models_path')); file_put_contents($path, $sql); $this->notify('Generated SQL successfully for models'); } }class Doctrine_Task_DropDb extends Doctrine_Task { public $description = 'Drop database for all existing connections', $requiredArguments = array(), $optionalArguments = array('force' => 'Whether or not to force the drop database task'); public function execute() { if ( ! $this->getArgument('force')) { $answer = $this->ask('Are you sure you wish to drop your databases? (y/n)'); if ($answer != 'y') { $this->notify('Successfully cancelled'); return; } } $results = Doctrine::dropDatabases(); foreach ($results as $name => $result) { $msg = $result instanceof Exception ? 'Could not drop database for connection: "' .$name . '." Failed with exception: ' . $result->getMessage():$result; $this->notify($msg); } } }class Doctrine_Task_GenerateMigration extends Doctrine_Task { public $description = 'Generate new migration class definition', $requiredArguments = array('class_name' => 'Name of the migration class to generate', 'migrations_path' => 'Specify the complete path to your migration classes folder.'), $optionalArguments = array(); public function execute() { Doctrine::generateMigrationClass($this->getArgument('class_name'), $this->getArgument('migrations_path')); $this->notify(sprintf('Generated migration class: %s successfully to %s', $this->getArgument('class_name'), $this->getArgument('migrations_path'))); } }class Doctrine_Task_BuildAllReload extends Doctrine_Task { public $description = 'Calls rebuild-db and load-data', $requiredArguments = array(), $optionalArguments = array(); public function __construct($dispatcher = null) { parent::__construct($dispatcher); $this->rebuildDb = new Doctrine_Task_RebuildDb($this->dispatcher); $this->loadData = new Doctrine_Task_LoadData($this->dispatcher); $this->requiredArguments = array_merge($this->requiredArguments, $this->rebuildDb->requiredArguments, $this->loadData->requiredArguments); $this->optionalArguments = array_merge($this->optionalArguments, $this->rebuildDb->optionalArguments, $this->loadData->optionalArguments); } public function execute() { $this->rebuildDb->setArguments($this->getArguments()); $this->rebuildDb->execute(); $this->loadData->setArguments($this->getArguments()); $this->loadData->execute(); } }class Doctrine_Tree { protected $table; protected $options = array(); protected $_baseComponent; public function __construct(Doctrine_Table $table, $options) { $this->table = $table; $this->options = $options; $this->_baseComponent = $table->getComponentName(); $class = $this->_baseComponent; if ($table->getOption('inheritanceMap')) { $subclasses = $table->getOption('subclasses'); while (in_array($class, $subclasses)) { $class = get_parent_class($class); } $this->_baseComponent = $class; } } public function setTableDefinition() { throw new Doctrine_Tree_Exception('Table attributes have not been defined for this Tree implementation.'); } public function setUp() { } public static function factory(Doctrine_Table $table, $implName, $options = array()) { $class = 'Doctrine_Tree_' . $implName; if ( ! class_exists($class)) { throw new Doctrine_Exception('The chosen class must extend Doctrine_Tree'); } return new $class($table, $options); } public function getAttribute($name) { return isset($this->options[$name]) ? $this->options[$name] : null; } public function setAttribute($name, $value) { $this->options[$name] = $value; } public function getBaseComponent() { return $this->_baseComponent; } }abstract class Doctrine_Tree_MaterializedPath extends Doctrine_Tree implements Doctrine_Tree_Interface { }class Doctrine_Tree_NestedSet extends Doctrine_Tree implements Doctrine_Tree_Interface { private $_baseQuery; private $_baseAlias = "base"; public function __construct(Doctrine_Table $table, $options) { $options['hasManyRoots'] = isset($options['hasManyRoots']) ? $options['hasManyRoots'] : false; if ($options['hasManyRoots']) { $options['rootColumnName'] = isset($options['rootColumnName']) ? $options['rootColumnName'] : 'root_id'; } parent::__construct($table, $options); } public function setTableDefinition() { if ($root = $this->getAttribute('rootColumnName')) { $this->table->setColumn($root, 'integer', 4); } $this->table->setColumn('lft', 'integer', 4); $this->table->setColumn('rgt', 'integer', 4); $this->table->setColumn('level', 'integer', 2); } public function createRoot(Doctrine_Record $record = null) { if ($this->getAttribute('hasManyRoots')) { if ( ! $record || ( ! $record->exists() && $record->getNode()->getRootValue() <= 0) || $record->getTable()->isIdentifierComposite()) { throw new Doctrine_Tree_Exception("Node must have a root id set or must " . " be persistent and have a single-valued numeric primary key in order to" . " be created as a root node. Automatic assignment of a root id on" . " transient/new records is no longer supported."); } if ($record->exists() && $record->getNode()->getRootValue() <= 0) { $identifier = $record->getTable()->getIdentifier(); $record->getNode()->setRootValue($record->get($identifier)); } } if ( ! $record) { $record = $this->table->create(); } $record->set('lft', '1'); $record->set('rgt', '2'); $record->set('level', 0); $record->save(); return $record; } public function findRoot($rootId = 1) { return $this->fetchRoot($rootId); } public function fetchRoot($rootId = 1) { $q = $this->getBaseQuery(); $q = $q->addWhere($this->_baseAlias . '.lft = ?', 1); $q = $this->returnQueryWithRootId($q, $rootId); $data = $q->execute(); if (count($data) <= 0) { return false; } if ($data instanceof Doctrine_Collection) { $root = $data->getFirst(); $root['level'] = 0; } else if (is_array($data)) { $root = array_shift($data); $root['level'] = 0; } else { throw new Doctrine_Tree_Exception("Unexpected data structure returned."); } return $root; } public function fetchTree($options = array(), $hydrationMode = null) { $q = $this->getBaseQuery(); $q = $q->addWhere($this->_baseAlias . ".lft >= ?", 1); $rootId = isset($options['root_id']) ? $options['root_id'] : '1'; if (is_array($rootId)) { $q->addOrderBy($this->_baseAlias . "." . $this->getAttribute('rootColumnName') . ", " . $this->_baseAlias . ".lft ASC"); } else { $q->addOrderBy($this->_baseAlias . ".lft ASC"); } $q = $this->returnQueryWithRootId($q, $rootId); $tree = $q->execute(array(), $hydrationMode); if (count($tree) <= 0) { return false; } return $tree; } public function fetchBranch($pk, $options = array(), $hydrationMode = null) { $record = $this->table->find($pk); if ( ! ($record instanceof Doctrine_Record) || !$record->exists()) { return false; } $depth = isset($options['depth']) ? $options['depth'] : null; $q = $this->getBaseQuery(); $params = array($record->get('lft'), $record->get('rgt')); $q->addWhere($this->_baseAlias . ".lft >= ? AND " . $this->_baseAlias . ".rgt <= ?", $params) ->addOrderBy($this->_baseAlias . ".lft asc"); if ( ! is_null($depth)) { $q->addWhere($this->_baseAlias . ".level BETWEEN ? AND ?", array($record->get('level'), $record->get('level')+$depth)); } $q = $this->returnQueryWithRootId($q, $record->getNode()->getRootValue()); return $q->execute(array(), $hydrationMode); } public function fetchRoots() { $q = $this->getBaseQuery(); $q = $q->addWhere($this->_baseAlias . '.lft = ?', 1); return $q->execute(); } public function getNextRootId() { return $this->getMaxRootId() + 1; } public function getMaxRootId() { $component = $this->table->getComponentName(); $column = $this->getAttribute('rootColumnName'); $dql = 'SELECT c.' . $column . ' FROM ' . $component . ' c ORDER BY c.' . $column . ' DESC LIMIT 1'; $coll = $this->table->getConnection()->query($dql); if ($coll->count() > 0) { $max = $coll->getFirst()->get($column); $max = ! is_null($max) ? $max : 0; } else { $max = 0; } return $max; } public function returnQueryWithRootId($query, $rootId = 1) { if ($root = $this->getAttribute('rootColumnName')) { if (is_array($rootId)) { $query->addWhere($root . ' IN (' . implode(',', array_fill(0, count($rootId), '?')) . ')', $rootId); } else { $query->addWhere($root . ' = ?', $rootId); } } return $query; } public function getBaseQuery() { if ( ! isset($this->_baseQuery)) { $this->_baseQuery = $this->_createBaseQuery(); } return $this->_baseQuery->copy(); } public function getBaseAlias() { return $this->_baseAlias; } private function _createBaseQuery() { $this->_baseAlias = "base"; $q = new Doctrine_Query(); $q->select($this->_baseAlias . ".*")->from($this->getBaseComponent() . " " . $this->_baseAlias); return $q; } public function setBaseQuery(Doctrine_Query $query) { $this->_baseAlias = $query->getRootAlias(); $query->addSelect($this->_baseAlias . ".lft, " . $this->_baseAlias . ".rgt, ". $this->_baseAlias . ".level"); if ($this->getAttribute('rootColumnName')) { $query->addSelect($this->_baseAlias . "." . $this->getAttribute('rootColumnName')); } $this->_baseQuery = $query; } public function resetBaseQuery() { $this->_baseQuery = $this->_createBaseQuery(); } }class Doctrine_Tree_Exception extends Doctrine_Exception { }abstract class Doctrine_Tree_AdjacencyList extends Doctrine_Tree implements Doctrine_Tree_Interface { }class Doctrine_View_Exception extends Doctrine_Exception { }class Doctrine_Connection_Module { protected $conn; protected $moduleName; public function __construct($conn = null) { if ( ! ($conn instanceof Doctrine_Connection)) { $conn = Doctrine_Manager::getInstance()->getCurrentConnection(); } $this->conn = $conn; $e = explode('_', get_class($this)); $this->moduleName = $e[1]; } public function getConnection() { return $this->conn; } public function getModuleName() { return $this->moduleName; } }class Doctrine_Formatter extends Doctrine_Connection_Module { public function escapePattern($text) { if ( ! $this->string_quoting['escape_pattern']) { return $text; } $tmp = $this->conn->string_quoting; $text = str_replace($tmp['escape_pattern'], $tmp['escape_pattern'] . $tmp['escape_pattern'], $text); foreach ($this->wildcards as $wildcard) { $text = str_replace($wildcard, $tmp['escape_pattern'] . $wildcard, $text); } return $text; } public function convertBooleans($item) { if (is_array($item)) { foreach ($item as $k => $value) { if (is_bool($value)) { $item[$k] = (int) $value; } } } else { if (is_bool($item)) { $item = (int) $item; } } return $item; } public function quoteIdentifier($str, $checkOption = true) { if ($checkOption && ! $this->conn->getAttribute(Doctrine::ATTR_QUOTE_IDENTIFIER)) { return $str; } $tmp = $this->conn->identifier_quoting; $str = str_replace($tmp['end'], $tmp['escape'] . $tmp['end'], $str); return $tmp['start'] . $str . $tmp['end']; } public function quoteMultipleIdentifier($arr, $checkOption = true) { foreach ($arr as $k => $v) { $arr[$k] = $this->quoteIdentifier($v, $checkOption); } return $arr; } public function quote($input, $type = null) { if ($type == null) { $type = gettype($input); } switch ($type) { case 'integer': case 'double': case 'float': case 'bool': case 'decimal': case 'int': return $input; case 'array': case 'object': $input = serialize($input); case 'date': case 'time': case 'timestamp': case 'string': case 'char': case 'varchar': case 'text': case 'gzip': case 'blob': case 'clob': case 'enum': case 'boolean': $this->conn->connect(); return $this->conn->getDbh()->quote($input); } } public function fixSequenceName($sqn) { $seqPattern = '/^'.preg_replace('/%s/', '([a-z0-9_]+)', $this->conn->getAttribute(Doctrine::ATTR_SEQNAME_FORMAT)).'$/i'; $seqName = preg_replace($seqPattern, '\\1', $sqn); if ($seqName && ! strcasecmp($sqn, $this->getSequenceName($seqName))) { return $seqName; } return $sqn; } public function fixIndexName($idx) { $indexPattern = '/^'.preg_replace('/%s/', '([a-z0-9_]+)', $this->conn->getAttribute(Doctrine::ATTR_IDXNAME_FORMAT)).'$/i'; $indexName = preg_replace($indexPattern, '\\1', $idx); if ($indexName && ! strcasecmp($idx, $this->getIndexName($indexName))) { return $indexName; } return $idx; } public function getSequenceName($sqn) { return sprintf($this->conn->getAttribute(Doctrine::ATTR_SEQNAME_FORMAT), preg_replace('/[^a-z0-9_\$.]/i', '_', $sqn)); } public function getIndexName($idx) { return sprintf($this->conn->getAttribute(Doctrine::ATTR_IDXNAME_FORMAT), preg_replace('/[^a-z0-9_\$]/i', '_', $idx)); } public function getTableName($table) { return sprintf($this->conn->getAttribute(Doctrine::ATTR_TBLNAME_FORMAT), $table); } } class Doctrine_Expression { protected $_expression; protected $_conn; protected $_tokenizer; public function __construct($expr, $conn = null) { $this->_tokenizer = new Doctrine_Query_Tokenizer(); $this->setExpression($expr); if ($conn !== null) { $this->_conn = $conn; } } public function getConnection() { if ( ! isset($this->_conn)) { return Doctrine_Manager::connection(); } return $this->_conn; } public function setExpression($clause) { $this->_expression = $this->parseClause($clause); } public function parseExpression($expr) { $pos = strpos($expr, '('); $quoted = (substr($expr, 0, 1) === "'" && substr($expr, -1) === "'"); if ($pos === false || $quoted) { return $expr; } $name = substr($expr, 0, $pos); $argStr = substr($expr, ($pos + 1), -1); foreach ($this->_tokenizer->bracketExplode($argStr, ',') as $arg) { $args[] = $this->parseClause($arg); } return call_user_func_array(array($this->getConnection()->expression, $name), $args); } public function parseClause($clause) { $e = $this->_tokenizer->bracketExplode($clause, ' '); foreach ($e as $k => $expr) { $e[$k] = $this->parseExpression($expr); } return implode(' ', $e); } public function getSql() { return $this->_expression; } public function __toString() { return $this->getSql(); } } class Doctrine_Expression_Driver extends Doctrine_Connection_Module { public function getIdentifier($column) { return $column; } public function getIdentifiers($columns) { return $columns; } public function regexp() { throw new Doctrine_Expression_Exception('Regular expression operator is not supported by this database driver.'); } public function avg($column) { $column = $this->getIdentifier($column); return 'AVG(' . $column . ')'; } public function count($column) { $column = $this->getIdentifier($column); return 'COUNT(' . $column . ')'; } public function max($column) { $column = $this->getIdentifier($column); return 'MAX(' . $column . ')'; } public function min($column) { $column = $this->getIdentifier($column); return 'MIN(' . $column . ')'; } public function sum($column) { $column = $this->getIdentifier($column); return 'SUM(' . $column . ')'; } public function md5($column) { $column = $this->getIdentifier($column); return 'MD5(' . $column . ')'; } public function length($column) { $column = $this->getIdentifier($column); return 'LENGTH(' . $column . ')'; } public function round($column, $decimals = 0) { $column = $this->getIdentifier($column); return 'ROUND(' . $column . ', ' . $decimals . ')'; } public function mod($expression1, $expression2) { $expression1 = $this->getIdentifier($expression1); $expression2 = $this->getIdentifier($expression2); return 'MOD(' . $expression1 . ', ' . $expression2 . ')'; } public function trim($str) { return 'TRIM(' . $str . ')'; } public function rtrim($str) { return 'RTRIM(' . $str . ')'; } public function ltrim($str) { return 'LTRIM(' . $str . ')'; } public function upper($str) { return 'UPPER(' . $str . ')'; } public function lower($str) { return 'LOWER(' . $str . ')'; } public function locate($str, $substr) { return 'LOCATE(' . $str . ', ' . $substr . ')'; } public function now() { return 'NOW()'; } public function soundex($value) { throw new Doctrine_Expression_Exception('SQL soundex function not supported by this driver.'); } public function substring($value, $from, $len = null) { $value = $this->getIdentifier($value); if ($len === null) return 'SUBSTRING(' . $value . ' FROM ' . $from . ')'; else { $len = $this->getIdentifier($len); return 'SUBSTRING(' . $value . ' FROM ' . $from . ' FOR ' . $len . ')'; } } public function concat() { $args = func_get_args(); return 'CONCAT(' . join(', ', (array) $args) . ')'; } public function not($expression) { $expression = $this->getIdentifier($expression); return 'NOT(' . $expression . ')'; } private function basicMath($type, array $args) { $elements = $this->getIdentifiers($args); if (count($elements) < 1) { return ''; } if (count($elements) == 1) { return $elements[0]; } else { return '(' . implode(' ' . $type . ' ', $elements) . ')'; } } public function add(array $args) { return $this->basicMath('+', $args); } public function sub(array $args) { return $this->basicMath('-', $args ); } public function mul(array $args) { return $this->basicMath('*', $args); } public function div(array $args) { return $this->basicMath('/', $args); } public function eq($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' = ' . $value2; } public function neq($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' <> ' . $value2; } public function gt($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' > ' . $value2; } public function gte($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' >= ' . $value2; } public function lt($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' < ' . $value2; } public function lte($value1, $value2) { $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $value1 . ' <= ' . $value2; } public function in($column, $values) { if ( ! is_array($values)) { $values = array($values); } $values = $this->getIdentifiers($values); $column = $this->getIdentifier($column); if (count($values) == 0) { throw new Doctrine_Expression_Exception('Values array for IN operator should not be empty.'); } return $column . ' IN (' . implode(', ', $values) . ')'; } public function isNull($expression) { $expression = $this->getIdentifier($expression); return $expression . ' IS NULL'; } public function isNotNull($expression) { $expression = $this->getIdentifier($expression); return $expression . ' IS NOT NULL'; } public function between($expression, $value1, $value2) { $expression = $this->getIdentifier($expression); $value1 = $this->getIdentifier($value1); $value2 = $this->getIdentifier($value2); return $expression . ' BETWEEN ' .$value1 . ' AND ' . $value2; } public function guid() { throw new Doctrine_Expression_Exception('method not implemented'); } public function acos($value) { return 'ACOS(' . $value . ')'; } public function sin($value) { return 'SIN(' . $value . ')'; } public function pi() { return 'PI()'; } public function cos($value) { return 'COS(' . $value . ')'; } public function coalesce() { $args = func_get_args(); return 'COALESCE(' . join(', ', (array) $args) . ')'; } public function __call($m, $a) { if ($this->conn->getAttribute(Doctrine::ATTR_PORTABILITY) & Doctrine::PORTABILITY_EXPR) { throw new Doctrine_Expression_Exception('Unknown expression ' . $m); } return $m . '(' . implode(', ', $a) . ')'; } }class Doctrine_Expression_Pgsql extends Doctrine_Expression_Driver { public function md5($column) { $column = $this->getIdentifier($column); return 'MD5(' . $column . ')'; } public function substring($value, $from, $len = null) { $value = $this->getIdentifier($value); if ($len === null) { $len = $this->getIdentifier($len); return 'SUBSTR(' . $value . ', ' . $from . ')'; } else { return 'SUBSTR(' . $value . ', ' . $from . ', ' . $len . ')'; } } public function age($timestamp1, $timestamp2 = null) { if ( $timestamp2 == null ) { return 'AGE(' . $timestamp1 . ')'; } return 'AGE(' . $timestamp1 . ', ' . $timestamp2 . ')'; } public function date_part($text, $time) { return 'DATE_PART(' . $text . ', ' . $time . ')'; } public function to_char($time, $text) { return 'TO_CHAR(' . $time . ', ' . $text . ')'; } public function concat() { $args = func_get_args(); return join(' || ' , $args); } public function now() { return 'LOCALTIMESTAMP(0)'; } public function regexp() { return 'SIMILAR TO'; } public function random() { return 'RANDOM()'; } public function matchPattern($pattern, $operator = null, $field = null) { $match = ''; if ( ! is_null($operator)) { $field = is_null($field) ? '' : $field.' '; $operator = strtoupper($operator); switch ($operator) { case 'ILIKE': $match = $field.'ILIKE '; break; case 'LIKE': $match = $field.'LIKE '; break; default: throw new Doctrine_Expression_Pgsql_Exception('not a supported operator type:'. $operator); } } $match.= "'"; foreach ($pattern as $key => $value) { if ($key % 2) { $match.= $value; } else { $match.= $this->conn->escapePattern($this->conn->escape($value)); } } $match.= "'"; $match.= $this->patternEscapeString(); return $match; } public function translate($string, $from, $to) { $translate = 'TRANSLATE(' . $string . ', ' . $from . ', ' . $to . ')'; return $translate; } }class Doctrine_Expression_Exception extends Doctrine_Exception { }class Doctrine_Expression_Mock extends Doctrine_Expression_Driver { }class Doctrine_Db { public function __construct() { throw new Doctrine_Exception('Doctrine_Db has been deprecated. The functionality has been merged into Doctrine_Connection.'); } } class Doctrine_File extends Doctrine_Record { public function setTableDefinition() { $this->hasColumn('url', 'string', 255); } public function setUp() { $this->actAs('Searchable', array('className' => 'Doctrine_File_Index', 'fields' => array('url', 'content'))); $this->index('url', array('fields' => array('url'))); } public function get($name, $load = true) { if ($name === 'content') { return file_get_contents(parent::get('url')); } return parent::get($name, $load); } }abstract class Doctrine_Hydrator_Abstract extends Doctrine_Locator_Injectable { protected $_queryComponents = array(); protected $_hydrationMode = Doctrine::HYDRATE_RECORD; public function __construct() {} public function setHydrationMode($hydrationMode) { $this->_hydrationMode = $hydrationMode; } public function getHydrationMode() { return $this->_hydrationMode; } public function setQueryComponents(array $queryComponents) { $this->_queryComponents = $queryComponents; } public function getQueryComponents() { return $this->_queryComponents; } abstract public function hydrateResultSet($stmt, $tableAliases); }class Doctrine_Hydrator extends Doctrine_Hydrator_Abstract { protected $_rootAlias = null; public function hydrateResultSet($stmt, $tableAliases) { $hydrationMode = $this->_hydrationMode; $this->_tableAliases = $tableAliases; if ($hydrationMode == Doctrine::HYDRATE_NONE) { return $stmt->fetchAll(PDO::FETCH_NUM); } if ($hydrationMode == Doctrine::HYDRATE_ARRAY) { $driver = new Doctrine_Hydrator_ArrayDriver(); } else { $driver = new Doctrine_Hydrator_RecordDriver(); } reset($this->_queryComponents); $rootAlias = key($this->_queryComponents); $this->_rootAlias = $rootAlias; $rootComponentName = $this->_queryComponents[$rootAlias]['table']->getComponentName(); $isSimpleQuery = count($this->_queryComponents) <= 1; $result = array(); $listeners = array(); $identifierMap = array(); $prev = array(); $id = array(); $idTemplate = array(); $result = $driver->getElementCollection($rootComponentName); if ($stmt === false || $stmt === 0) { return $result; } foreach ($this->_queryComponents as $dqlAlias => $data) { $componentName = $data['table']->getComponentName(); $listeners[$componentName] = $data['table']->getRecordListener(); $identifierMap[$dqlAlias] = array(); $prev[$dqlAlias] = null; $idTemplate[$dqlAlias] = ''; } $event = new Doctrine_Event(null, Doctrine_Event::HYDRATE, null); $cache = array(); while ($data = $stmt->fetch(Doctrine::FETCH_ASSOC)) { $id = $idTemplate; $nonemptyComponents = array(); $rowData = $this->_gatherRowData($data, $cache, $id, $nonemptyComponents); $table = $this->_queryComponents[$rootAlias]['table']; $componentName = $table->getComponentName(); $event->setInvoker($table); $event->set('data', $rowData[$rootAlias]); $listeners[$componentName]->preHydrate($event); $index = false; if ($isSimpleQuery || ! isset($identifierMap[$rootAlias][$id[$rootAlias]])) { $element = $driver->getElement($rowData[$rootAlias], $componentName); $event->set('data', $element); $listeners[$componentName]->postHydrate($event); if ($field = $this->_getCustomIndexField($rootAlias)) { if (isset($result[$field])) { throw new Doctrine_Hydrator_Exception("Couldn't hydrate. Found non-unique key mapping."); } else if ( ! isset($element[$field])) { throw new Doctrine_Hydrator_Exception("Couldn't hydrate. Found a non-existent key."); } $result[$element[$field]] = $element; } else { $result[] = $element; } $identifierMap[$rootAlias][$id[$rootAlias]] = $driver->getLastKey($result); } else { $index = $identifierMap[$rootAlias][$id[$rootAlias]]; } $driver->setLastElement($prev, $result, $index, $rootAlias, false); unset($rowData[$rootAlias]); foreach ($rowData as $dqlAlias => $data) { $index = false; $map = $this->_queryComponents[$dqlAlias]; $table = $map['table']; $componentName = $table->getComponentName(); $event->set('data', $data); $event->setInvoker($table); $listeners[$componentName]->preHydrate($event); if ( ! isset($map['parent'])) { throw new Doctrine_Hydrator_Exception( '"' . $componentName . '" with an alias of "' . $dqlAlias . '"' . ' in your query does not reference the parent component it is related to.' ); } $parent = $map['parent']; $relation = $map['relation']; $relationAlias = $map['relation']->getAlias(); $path = $parent . '.' . $dqlAlias; if ( ! isset($prev[$parent])) { unset($prev[$dqlAlias]); continue; } if ( ! $relation->isOneToOne() && $driver->initRelated($prev[$parent], $relationAlias)) { $oneToOne = false; if (isset($nonemptyComponents[$dqlAlias])) { $indexExists = isset($identifierMap[$path][$id[$parent]][$id[$dqlAlias]]); $index = $indexExists ? $identifierMap[$path][$id[$parent]][$id[$dqlAlias]] : false; $indexIsValid = $index !== false ? isset($prev[$parent][$relationAlias][$index]) : false; if ( ! $indexExists || ! $indexIsValid) { $element = $driver->getElement($data, $componentName); $event->set('data', $element); $listeners[$componentName]->postHydrate($event); if ($field = $this->_getCustomIndexField($dqlAlias)) { if (isset($prev[$parent][$relationAlias][$element[$field]])) { throw new Doctrine_Hydrator_Exception("Couldn't hydrate. Found non-unique key mapping."); } else if ( ! isset($element[$field])) { throw new Doctrine_Hydrator_Exception("Couldn't hydrate. Found a non-existent key."); } $prev[$parent][$relationAlias][$element[$field]] = $element; } else { $prev[$parent][$relationAlias][] = $element; } $identifierMap[$path][$id[$parent]][$id[$dqlAlias]] = $driver->getLastKey($prev[$parent][$relationAlias]); } $driver->registerCollection($prev[$parent][$relationAlias]); } } else { $oneToOne = true; if ( ! isset($nonemptyComponents[$dqlAlias]) && ! isset($prev[$parent][$relationAlias])) { $prev[$parent][$relationAlias] = $driver->getNullPointer(); } else if ( ! isset($prev[$parent][$relationAlias])) { $element = $driver->getElement($data, $componentName); $event->set('data', $element); $listeners[$componentName]->postHydrate($event); $prev[$parent][$relationAlias] = $element; } } if ($prev[$parent][$relationAlias] !== null) { $coll =& $prev[$parent][$relationAlias]; $driver->setLastElement($prev, $coll, $index, $dqlAlias, $oneToOne); } } } $stmt->closeCursor(); $driver->flush(); return $result; } protected function _gatherRowData(&$data, &$cache, &$id, &$nonemptyComponents) { $rowData = array(); foreach ($data as $key => $value) { if ( ! isset($cache[$key])) { if ($key == 'DOCTRINE_ROWNUM') continue; $e = explode('__', $key); $last = strtolower(array_pop($e)); $cache[$key]['dqlAlias'] = $this->_tableAliases[strtolower(implode('__', $e))]; $table = $this->_queryComponents[$cache[$key]['dqlAlias']]['table']; $fieldName = $table->getFieldName($last); $cache[$key]['fieldName'] = $fieldName; if ($table->isIdentifier($fieldName)) { $cache[$key]['isIdentifier'] = true; } else { $cache[$key]['isIdentifier'] = false; } $type = $table->getTypeOfColumn($last); if ($type == 'integer' || $type == 'string') { $cache[$key]['isSimpleType'] = true; } else { $cache[$key]['type'] = $type; $cache[$key]['isSimpleType'] = false; } } $map = $this->_queryComponents[$cache[$key]['dqlAlias']]; $table = $map['table']; $dqlAlias = $cache[$key]['dqlAlias']; $fieldName = $cache[$key]['fieldName']; $agg = false; if (isset($this->_queryComponents[$dqlAlias]['agg'][$fieldName])) { $fieldName = $this->_queryComponents[$dqlAlias]['agg'][$fieldName]; $agg = true; } if ($cache[$key]['isIdentifier']) { $id[$dqlAlias] .= '|' . $value; } if ($cache[$key]['isSimpleType']) { $rowData[$dqlAlias][$fieldName] = $value; } else { $rowData[$dqlAlias][$fieldName] = $table->prepareValue( $fieldName, $value, $cache[$key]['type']); } if ($agg) { $rowData[$this->_rootAlias][$fieldName] = $rowData[$dqlAlias][$fieldName]; } if ( ! isset($nonemptyComponents[$dqlAlias]) && $value !== null) { $nonemptyComponents[$dqlAlias] = true; } } return $rowData; } protected function _getCustomIndexField($alias) { return isset($this->_queryComponents[$alias]['map']) ? $this->_queryComponents[$alias]['map'] : null; } }class Doctrine_DataDict extends Doctrine_Connection_Module { public function compareDefinition($current, $previous) { $type = !empty($current['type']) ? $current['type'] : null; if ( ! method_exists($this, "_compare{$type}Definition")) { throw new Doctrine_DataDict_Exception('type "'.$current['type'].'" is not yet supported'); } if (empty($previous['type']) || $previous['type'] != $type) { return $current; } $change = $this->{"_compare{$type}Definition"}($current, $previous); if ($previous['type'] != $type) { $change['type'] = true; } $previous_notnull = !empty($previous['notnull']) ? $previous['notnull'] : false; $notnull = !empty($current['notnull']) ? $current['notnull'] : false; if ($previous_notnull != $notnull) { $change['notnull'] = true; } $previous_default = array_key_exists('default', $previous) ? $previous['default'] : ($previous_notnull ? '' : null); $default = array_key_exists('default', $current) ? $current['default'] : ($notnull ? '' : null); if ($previous_default !== $default) { $change['default'] = true; } return $change; } public function parseBoolean($value) { if ($value == 'true') { $value = 1; } elseif ($value == 'false') { $value = 0; } return $value; } }class Doctrine_Event { const CONN_QUERY = 1; const CONN_EXEC = 2; const CONN_PREPARE = 3; const CONN_CONNECT = 4; const CONN_CLOSE = 5; const CONN_ERROR = 6; const STMT_EXECUTE = 10; const STMT_FETCH = 11; const STMT_FETCHALL = 12; const TX_BEGIN = 31; const TX_COMMIT = 32; const TX_ROLLBACK = 33; const SAVEPOINT_CREATE = 34; const SAVEPOINT_ROLLBACK = 35; const SAVEPOINT_COMMIT = 36; const HYDRATE = 40; const RECORD_DELETE = 21; const RECORD_SAVE = 22; const RECORD_UPDATE = 23; const RECORD_INSERT = 24; const RECORD_SERIALIZE = 25; const RECORD_UNSERIALIZE = 26; const RECORD_DQL_DELETE = 27; const RECORD_DQL_SELECT = 28; const RECORD_DQL_UPDATE = 29; const RECORD_VALIDATE = 30; protected $_invoker; protected $_query; protected $_params; protected $_code; protected $_startedMicrotime; protected $_endedMicrotime; protected $_options = array(); public function __construct($invoker, $code, $query = null, $params = array()) { $this->_invoker = $invoker; $this->_code = $code; $this->_query = $query; $this->_params = $params; } public function getQuery() { return $this->_query; } public function getName() { switch ($this->_code) { case self::CONN_QUERY: return 'query'; case self::CONN_EXEC: return 'exec'; case self::CONN_PREPARE: return 'prepare'; case self::CONN_CONNECT: return 'connect'; case self::CONN_CLOSE: return 'close'; case self::CONN_ERROR: return 'error'; case self::STMT_EXECUTE: return 'execute'; case self::STMT_FETCH: return 'fetch'; case self::STMT_FETCHALL: return 'fetch all'; case self::TX_BEGIN: return 'begin'; case self::TX_COMMIT: return 'commit'; case self::TX_ROLLBACK: return 'rollback'; case self::SAVEPOINT_CREATE: return 'create savepoint'; case self::SAVEPOINT_ROLLBACK: return 'rollback savepoint'; case self::SAVEPOINT_COMMIT: return 'commit savepoint'; case self::RECORD_DELETE: return 'delete record'; case self::RECORD_SAVE: return 'save record'; case self::RECORD_UPDATE: return 'update record'; case self::RECORD_INSERT: return 'insert record'; case self::RECORD_SERIALIZE: return 'serialize record'; case self::RECORD_UNSERIALIZE: return 'unserialize record'; case self::RECORD_DQL_SELECT: return 'select records'; case self::RECORD_DQL_DELETE: return 'delete records'; case self::RECORD_DQL_UPDATE: return 'update records'; case self::RECORD_VALIDATE: return 'validate record'; } } public function getCode() { return $this->_code; } public function __get($option) { if ( ! isset($this->_options[$option])) { return null; } return $this->_options[$option]; } public function skipOperation() { $this->_options['skipOperation'] = true; return $this; } public function __set($option, $value) { $this->_options[$option] = $value; return $this; } public function set($option, &$value) { $this->_options[$option] =& $value; return $this; } public function start() { $this->_startedMicrotime = microtime(true); } public function hasEnded() { return ($this->_endedMicrotime != null); } public function end() { $this->_endedMicrotime = microtime(true); return $this; } public function getInvoker() { return $this->_invoker; } public function setInvoker($invoker) { $this->_invoker = $invoker; } public function getParams() { return $this->_params; } public function getElapsedSecs() { if (is_null($this->_endedMicrotime)) { return false; } return ($this->_endedMicrotime - $this->_startedMicrotime); } } class Doctrine_Export extends Doctrine_Connection_Module { protected $valid_default_values = array( 'text' => '', 'boolean' => true, 'integer' => 0, 'decimal' => 0.0, 'float' => 0.0, 'timestamp' => '1970-01-01 00:00:00', 'time' => '00:00:00', 'date' => '1970-01-01', 'clob' => '', 'blob' => '', 'string' => '' ); public function dropDatabase($database) { $this->conn->execute($this->dropDatabaseSql($database)); } public function dropDatabaseSql($database) { throw new Doctrine_Export_Exception('Drop database not supported by this driver.'); } public function dropTableSql($table) { return 'DROP TABLE ' . $this->conn->quoteIdentifier($table); } public function dropTable($table) { $this->conn->execute($this->dropTableSql($table)); } public function dropIndex($table, $name) { return $this->conn->exec($this->dropIndexSql($table, $name)); } public function dropIndexSql($table, $name) { $name = $this->conn->quoteIdentifier($this->conn->formatter->getIndexName($name)); return 'DROP INDEX ' . $name; } public function dropConstraint($table, $name, $primary = false) { $table = $this->conn->quoteIdentifier($table); $name = $this->conn->quoteIdentifier($name); return $this->conn->exec('ALTER TABLE ' . $table . ' DROP CONSTRAINT ' . $name); } public function dropForeignKey($table, $name) { return $this->dropConstraint($table, $name); } public function dropSequence($sequenceName) { $this->conn->exec($this->dropSequenceSql($sequenceName)); } public function dropSequenceSql($sequenceName) { throw new Doctrine_Export_Exception('Drop sequence not supported by this driver.'); } public function createDatabase($database) { $this->conn->execute($this->createDatabaseSql($database)); } public function createDatabaseSql($database) { throw new Doctrine_Export_Exception('Create database not supported by this driver.'); } public function createTableSql($name, array $fields, array $options = array()) { if ( ! $name) { throw new Doctrine_Export_Exception('no valid table name specified'); } if (empty($fields)) { throw new Doctrine_Export_Exception('no fields specified for table ' . $name); } $queryFields = $this->getFieldDeclarationList($fields); if (isset($options['primary']) && ! empty($options['primary'])) { $primaryKeys = array_map(array($this->conn, 'quoteIdentifier'), array_values($options['primary'])); $queryFields .= ', PRIMARY KEY(' . implode(', ', $primaryKeys) . ')'; } if (isset($options['indexes']) && ! empty($options['indexes'])) { foreach($options['indexes'] as $index => $definition) { $indexDeclaration = $this->getIndexDeclaration($index, $definition); if ( ! is_null($indexDeclaration)) { $queryFields .= ', '.$indexDeclaration; } } } $query = 'CREATE TABLE ' . $this->conn->quoteIdentifier($name, true) . ' (' . $queryFields; $check = $this->getCheckDeclaration($fields); if ( ! empty($check)) { $query .= ', ' . $check; } $query .= ')'; $sql[] = $query; if (isset($options['foreignKeys'])) { foreach ((array) $options['foreignKeys'] as $k => $definition) { if (is_array($definition)) { $sql[] = $this->createForeignKeySql($name, $definition); } } } return $sql; } public function createTable($name, array $fields, array $options = array()) { $count = 0; foreach ($fields as $fieldName => $field) { if (isset($field['primary']) && $field['primary']) { if ($count == 0) { $options['primary'] = array(); } $count++; $options['primary'][] = $fieldName; } } $sql = (array) $this->createTableSql($name, $fields, $options); foreach ($sql as $query) { $this->conn->execute($query); } } public function createSequence($seqName, $start = 1, array $options = array()) { return $this->conn->execute($this->createSequenceSql($seqName, $start = 1, $options)); } public function createSequenceSql($seqName, $start = 1, array $options = array()) { throw new Doctrine_Export_Exception('Create sequence not supported by this driver.'); } public function createConstraint($table, $name, $definition) { $sql = $this->createConstraintSql($table, $name, $definition); return $this->conn->exec($sql); } public function createConstraintSql($table, $name, $definition) { $table = $this->conn->quoteIdentifier($table); $name = $this->conn->quoteIdentifier($this->conn->formatter->getIndexName($name)); $query = 'ALTER TABLE ' . $table . ' ADD CONSTRAINT ' . $name; if (isset($definition['primary']) && $definition['primary']) { $query .= ' PRIMARY KEY'; } elseif (isset($definition['unique']) && $definition['unique']) { $query .= ' UNIQUE'; } $fields = array(); foreach (array_keys($definition['fields']) as $field) { $fields[] = $this->conn->quoteIdentifier($field, true); } $query .= ' ('. implode(', ', $fields) . ')'; return $query; } public function createIndex($table, $name, array $definition) { return $this->conn->execute($this->createIndexSql($table, $name, $definition)); } public function createIndexSql($table, $name, array $definition) { $table = $this->conn->quoteIdentifier($table); $name = $this->conn->quoteIdentifier($name); $type = ''; if (isset($definition['type'])) { switch (strtolower($definition['type'])) { case 'unique': $type = strtoupper($definition['type']) . ' '; break; default: throw new Doctrine_Export_Exception( 'Unknown type ' . $definition['type'] . ' for index ' . $name . ' in table ' . $table ); } } $query = 'CREATE ' . $type . 'INDEX ' . $name . ' ON ' . $table; $fields = array(); foreach ($definition['fields'] as $field) { $fields[] = $this->conn->quoteIdentifier($field); } $query .= ' (' . implode(', ', $fields) . ')'; return $query; } public function createForeignKeySql($table, array $definition) { $table = $this->conn->quoteIdentifier($table); $query = 'ALTER TABLE ' . $table . ' ADD ' . $this->getForeignKeyDeclaration($definition); return $query; } public function createForeignKey($table, array $definition) { $sql = $this->createForeignKeySql($table, $definition); return $this->conn->execute($sql); } public function alterTable($name, array $changes, $check = false) { $sql = $this->alterTableSql($name, $changes, $check); if (is_string($sql) && $sql) { $this->conn->execute($sql); } } public function alterTableSql($name, array $changes, $check = false) { throw new Doctrine_Export_Exception('Alter table not supported by this driver.'); } public function getFieldDeclarationList(array $fields) { foreach ($fields as $fieldName => $field) { $query = $this->getDeclaration($fieldName, $field); $queryFields[] = $query; } return implode(', ', $queryFields); } public function getDeclaration($name, array $field) { $default = $this->getDefaultFieldDeclaration($field); $charset = (isset($field['charset']) && $field['charset']) ? ' ' . $this->getCharsetFieldDeclaration($field['charset']) : ''; $collation = (isset($field['collation']) && $field['collation']) ? ' ' . $this->getCollationFieldDeclaration($field['collation']) : ''; $notnull = $this->getNotNullFieldDeclaration($field); $unique = (isset($field['unique']) && $field['unique']) ? ' ' . $this->getUniqueFieldDeclaration() : ''; $check = (isset($field['check']) && $field['check']) ? ' ' . $field['check'] : ''; $method = 'get' . $field['type'] . 'Declaration'; try { if (method_exists($this->conn->dataDict, $method)) { return $this->conn->dataDict->$method($name, $field); } else { $dec = $this->conn->dataDict->getNativeDeclaration($field); } return $this->conn->quoteIdentifier($name, true) . ' ' . $dec . $charset . $default . $notnull . $unique . $check . $collation; } catch (Exception $e) { throw new Doctrine_Exception('Around field ' . $name . ': ' . $e->getMessage()); } } public function getDefaultFieldDeclaration($field) { $default = ''; if (array_key_exists('default', $field)) { if ($field['default'] === '') { $field['default'] = empty($field['notnull']) ? null : $this->valid_default_values[$field['type']]; if ($field['default'] === '' && ($this->conn->getAttribute(Doctrine::ATTR_PORTABILITY) & Doctrine::PORTABILITY_EMPTY_TO_NULL)) { $field['default'] = null; } } if ($field['type'] === 'boolean') { $field['default'] = $this->conn->convertBooleans($field['default']); } $default = ' DEFAULT ' . (is_null($field['default']) ? 'NULL' : $this->conn->quote($field['default'], $field['type'])); } return $default; } public function getNotNullFieldDeclaration(array $definition) { return (isset($definition['notnull']) && $definition['notnull']) ? ' NOT NULL' : ''; } public function getCheckDeclaration(array $definition) { $constraints = array(); foreach ($definition as $field => $def) { if (is_string($def)) { $constraints[] = 'CHECK (' . $def . ')'; } else { if (isset($def['min'])) { $constraints[] = 'CHECK (' . $field . ' >= ' . $def['min'] . ')'; } if (isset($def['max'])) { $constraints[] = 'CHECK (' . $field . ' <= ' . $def['max'] . ')'; } } } return implode(', ', $constraints); } public function getIndexDeclaration($name, array $definition) { $name = $this->conn->quoteIdentifier($name); $type = ''; if (isset($definition['type'])) { if (strtolower($definition['type']) == 'unique') { $type = strtoupper($definition['type']) . ' '; } else { throw new Doctrine_Export_Exception( 'Unknown type ' . $definition['type'] . ' for index ' . $name ); } } if ( ! isset($definition['fields']) || ! is_array($definition['fields'])) { throw new Doctrine_Export_Exception('No columns given for index ' . $name); } $query = $type . 'INDEX ' . $name; $query .= ' (' . $this->getIndexFieldDeclarationList($definition['fields']) . ')'; return $query; } public function getIndexFieldDeclarationList(array $fields) { $ret = array(); foreach ($fields as $field => $definition) { if (is_array($definition)) { $ret[] = $this->conn->quoteIdentifier($field); } else { $ret[] = $this->conn->quoteIdentifier($definition); } } return implode(', ', $ret); } public function getTemporaryTableQuery() { return 'TEMPORARY'; } public function getForeignKeyDeclaration(array $definition) { $sql = $this->getForeignKeyBaseDeclaration($definition); $sql .= $this->getAdvancedForeignKeyOptions($definition); return $sql; } public function getAdvancedForeignKeyOptions(array $definition) { $query = ''; if ( ! empty($definition['onUpdate'])) { $query .= ' ON UPDATE ' . $this->getForeignKeyReferentialAction($definition['onUpdate']); } if ( ! empty($definition['onDelete'])) { $query .= ' ON DELETE ' . $this->getForeignKeyReferentialAction($definition['onDelete']); } return $query; } public function getForeignKeyReferentialAction($action) { $upper = strtoupper($action); switch ($upper) { case 'CASCADE': case 'SET NULL': case 'NO ACTION': case 'RESTRICT': case 'SET DEFAULT': return $upper; break; default: throw new Doctrine_Export_Exception('Unknown foreign key referential action \'' . $upper . '\' given.'); } } public function getForeignKeyBaseDeclaration(array $definition) { $sql = ''; if (isset($definition['name'])) { $sql .= ' CONSTRAINT ' . $this->conn->quoteIdentifier($definition['name']) . ' '; } $sql .= 'FOREIGN KEY ('; if ( ! isset($definition['local'])) { throw new Doctrine_Export_Exception('Local reference field missing from definition.'); } if ( ! isset($definition['foreign'])) { throw new Doctrine_Export_Exception('Foreign reference field missing from definition.'); } if ( ! isset($definition['foreignTable'])) { throw new Doctrine_Export_Exception('Foreign reference table missing from definition.'); } if ( ! is_array($definition['local'])) { $definition['local'] = array($definition['local']); } if ( ! is_array($definition['foreign'])) { $definition['foreign'] = array($definition['foreign']); } $sql .= implode(', ', array_map(array($this->conn, 'quoteIdentifier'), $definition['local'])) . ') REFERENCES ' . $this->conn->quoteIdentifier($definition['foreignTable']) . '(' . implode(', ', array_map(array($this->conn, 'quoteIdentifier'), $definition['foreign'])) . ')'; return $sql; } public function getUniqueFieldDeclaration() { return 'UNIQUE'; } public function getCharsetFieldDeclaration($charset) { return ''; } public function getCollationFieldDeclaration($collation) { return ''; } public function exportSchema($directory = null) { if ($directory !== null) { $models = Doctrine::filterInvalidModels(Doctrine::loadModels($directory)); } else { $models = Doctrine::getLoadedModels(); } $this->exportClasses($models); } public function exportSortedClassesSql($classes, $groupByConnection = true) { $connections = array(); foreach ($classes as $class) { $connection = Doctrine_Manager::getInstance()->getConnectionForComponent($class); $connectionName = $connection->getName(); if ( ! isset($connections[$connectionName])) { $connections[$connectionName] = array( 'create_tables' => array(), 'create_sequences' => array(), 'create_indexes' => array(), 'alters' => array(), 'create_triggers' => array(), ); } $sql = $connection->export->exportClassesSql(array($class)); foreach ($sql as $key => $query) { if (substr($query, 0, strlen('CREATE TABLE')) == 'CREATE TABLE') { $connections[$connectionName]['create_tables'][] = $query; unset($sql[$key]); continue; } if (substr($query, 0, strlen('CREATE SEQUENCE')) == 'CREATE SEQUENCE') { $connections[$connectionName]['create_sequences'][] = $query; unset($sql[$key]); continue; } if (preg_grep("/CREATE ?.* INDEX/", array($query))) { $connections[$connectionName]['create_indexes'][] = $query; unset($sql[$key]); continue; } if (substr($query, 0, strlen('ALTER TABLE')) == 'ALTER TABLE' || substr($query, 0, strlen('DECLARE')) == 'DECLARE') { $connections[$connectionName]['alters'][] = $query; unset($sql[$key]); continue; } if (substr($query, 0, strlen('CREATE TRIGGER')) == 'CREATE TRIGGER') { $connections[$connectionName]['create_triggers'][] = $query; unset($sql[$key]); continue; } } } $build = array(); foreach ($connections as $connectionName => $sql) { $build[$connectionName] = array_unique(array_merge($sql['create_tables'], $sql['create_sequences'], $sql['create_indexes'], $sql['alters'], $sql['create_triggers'])); } if ( ! $groupByConnection) { $new = array(); foreach($build as $connectionname => $sql) { $new = array_unique(array_merge($new, $sql)); } $build = $new; } return $build; } public function exportClasses(array $classes) { $queries = $this->exportSortedClassesSql($classes); foreach ($queries as $connectionName => $sql) { $connection = Doctrine_Manager::getInstance()->getConnection($connectionName); $connection->beginTransaction(); foreach ($sql as $query) { try { $connection->exec($query); } catch (Doctrine_Connection_Exception $e) { if ($e->getPortableCode() !== Doctrine::ERR_ALREADY_EXISTS) { $connection->rollback(); throw new Doctrine_Export_Exception($e->getMessage() . '. Failing Query: ' . $query); } } } $connection->commit(); } } public function exportClassesSql(array $classes) { $models = Doctrine::filterInvalidModels($classes); $sql = array(); foreach ($models as $name) { try { $record = new $name(); $table = $record->getTable(); $parents = $table->getOption('joinedParents'); foreach ($parents as $parent) { $data = $table->getConnection()->getTable($parent)->getExportableFormat(); $query = $this->conn->export->createTableSql($data['tableName'], $data['columns'], $data['options']); $sql = array_merge($sql, (array) $query); } $data = $table->getExportableFormat(); $query = $this->conn->export->createTableSql($data['tableName'], $data['columns'], $data['options']); if (is_array($query)) { $sql = array_merge($sql, $query); } else { $sql[] = $query; } if ($table->getAttribute(Doctrine::ATTR_EXPORT) & Doctrine::EXPORT_PLUGINS) { $sql = array_merge($sql, $this->exportGeneratorsSql($table)); } } catch (Exception $e) { throw new Doctrine_Export_Exception("While exporting model class '$name' to SQL: " . $e->getMessage()); } } $sql = array_unique($sql); rsort($sql); return $sql; } public function getAllGenerators(Doctrine_Table $table) { $generators = array(); foreach ($table->getGenerators() as $name => $generator) { if ($generator === null) { continue; } $generators[] = $generator; $generatorTable = $generator->getTable(); if ($generatorTable instanceof Doctrine_Table) { $generators = array_merge($generators, $this->getAllGenerators($generatorTable)); } } return $generators; } public function exportGeneratorsSql(Doctrine_Table $table) { $sql = array(); foreach ($this->getAllGenerators($table) as $name => $generator) { $table = $generator->getTable(); if ($table instanceof Doctrine_Table) { $data = $table->getExportableFormat(); $query = $this->conn->export->createTableSql($data['tableName'], $data['columns'], $data['options']); $sql = array_merge($sql, (array) $query); } } return $sql; } public function exportSql($directory = null) { if ($directory !== null) { $models = Doctrine::filterInvalidModels(Doctrine::loadModels($directory)); } else { $models = Doctrine::getLoadedModels(); } return $this->exportSortedClassesSql($models, false); } public function exportTable(Doctrine_Table $table) { try { $data = $table->getExportableFormat(); $this->conn->export->createTable($data['tableName'], $data['columns'], $data['options']); } catch(Doctrine_Connection_Exception $e) { if ($e->getPortableCode() !== Doctrine::ERR_ALREADY_EXISTS) { throw $e; } } } }class Doctrine_Export_Reporter implements IteratorAggregate { protected $messages = array(); public function add($code, $message) { $this->messages[] = array($code, $message); } public function pop() { return array_pop($this->messages); } public function getIterator() { return new ArrayIterator($this->messages); } }class Doctrine_Export_Frontbase extends Doctrine_Export { public function createDatabaseSql($name) { $name = $this->conn->quoteIdentifier($name, true); return 'CREATE DATABASE ' . $name; } public function dropDatabaseSql($name) { $name = $this->conn->quoteIdentifier($name, true); return 'DELETE DATABASE ' . $name; } public function dropTableSql($name) { $name = $this->conn->quoteIdentifier($name, true); return 'DROP TABLE ' . $name . ' CASCADE'; } public function alterTable($name, array $changes, $check = false) { foreach ($changes as $changeName => $change) { switch ($changeName) { case 'add': case 'remove': case 'change': case 'rename': case 'name': break; default: throw new Doctrine_Export_Exception('change type "'.$changeName.'" not yet supported'); } } if ($check) { return true; } $query = ''; if ( ! empty($changes['name'])) { $changeName = $this->conn->quoteIdentifier($changes['name'], true); $query .= 'RENAME TO ' . $changeName; } if ( ! empty($changes['add']) && is_array($changes['add'])) { foreach ($changes['add'] as $fieldName => $field) { if ($query) { $query.= ', '; } $query.= 'ADD ' . $this->conn->getDeclaration($fieldName, $field); } } if ( ! empty($changes['remove']) && is_array($changes['remove'])) { foreach ($changes['remove'] as $fieldName => $field) { if ($query) { $query.= ', '; } $fieldName = $this->conn->quoteIdentifier($fieldName, true); $query.= 'DROP ' . $fieldName; } } $rename = array(); if ( ! empty($changes['rename']) && is_array($changes['rename'])) { foreach ($changes['rename'] as $fieldName => $field) { $rename[$field['name']] = $fieldName; } } if ( ! empty($changes['change']) && is_array($changes['change'])) { foreach ($changes['change'] as $fieldName => $field) { if ($query) { $query.= ', '; } if (isset($rename[$fieldName])) { $oldFieldName = $rename[$fieldName]; unset($rename[$fieldName]); } else { $oldFieldName = $fieldName; } $oldFieldName = $this->conn->quoteIdentifier($oldFieldName, true); $query.= 'CHANGE ' . $oldFieldName . ' ' . $this->conn->getDeclaration($oldFieldName, $field['definition']); } } if ( ! empty($rename) && is_array($rename)) { foreach ($rename as $renamedFieldName => $renamed_field) { if ($query) { $query.= ', '; } $oldFieldName = $rename[$renamedFieldName]; $field = $changes['rename'][$oldFieldName]; $query.= 'CHANGE ' . $this->conn->getDeclaration($oldFieldName, $field['definition']); } } if ( ! $query) { return true; } $name = $this->conn->quoteIdentifier($name, true); return $this->conn->exec('ALTER TABLE ' . $name . ' ' . $query); } public function createSequence($sequenceName, $start = 1, array $options = array()) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($sequenceName), true); $seqcolName = $this->conn->quoteIdentifier($this->conn->getAttribute(Doctrine::ATTR_SEQCOL_NAME), true); $query = 'CREATE TABLE ' . $sequenceName . ' (' . $seqcolName . ' INTEGER DEFAULT UNIQUE, PRIMARY KEY(' . $seqcolName . '))'; $res = $this->conn->exec($query); $res = $this->conn->exec('SET UNIQUE = 1 FOR ' . $sequenceName); if ($start == 1) { return true; } try { $this->conn->exec('INSERT INTO ' . $sequenceName . ' (' . $seqcolName . ') VALUES (' . ($start-1) . ')'); } catch(Doctrine_Connection_Exception $e) { try { $this->conn->exec('DROP TABLE ' . $sequenceName); } catch(Doctrine_Connection_Exception $e) { throw new Doctrine_Export_Exception('could not drop inconsistent sequence table'); } throw new Doctrine_Export_Exception('could not create sequence table'); } } public function dropSequenceSql($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->getSequenceName($seqName), true); return 'DROP TABLE ' . $sequenceName . ' CASCADE'; } public function dropIndexSql($table, $name) { $table = $this->conn->quoteIdentifier($table, true); $name = $this->conn->quoteIdentifier($this->conn->getIndexName($name), true); return 'ALTER TABLE ' . $table . ' DROP INDEX ' . $name; } }class Doctrine_Export_Pgsql extends Doctrine_Export { public $tmpConnectionDatabase = 'postgres'; public function createDatabaseSql($name) { $query = 'CREATE DATABASE ' . $this->conn->quoteIdentifier($name); return $query; } public function dropDatabaseSql($name) { $query = 'DROP DATABASE ' . $this->conn->quoteIdentifier($name); return $query; } public function getAdvancedForeignKeyOptions(array $definition) { $query = ''; if (isset($definition['match'])) { $query .= ' MATCH ' . $definition['match']; } if (isset($definition['onUpdate'])) { $query .= ' ON UPDATE ' . $definition['onUpdate']; } if (isset($definition['onDelete'])) { $query .= ' ON DELETE ' . $definition['onDelete']; } if (isset($definition['deferrable'])) { $query .= ' DEFERRABLE'; } else { $query .= ' NOT DEFERRABLE'; } if (isset($definition['feferred'])) { $query .= ' INITIALLY DEFERRED'; } else { $query .= ' INITIALLY IMMEDIATE'; } return $query; } public function alterTableSql($name, array $changes, $check = false) { foreach ($changes as $changeName => $change) { switch ($changeName) { case 'add': case 'remove': case 'change': case 'name': case 'rename': break; default: throw new Doctrine_Export_Exception('change type "' . $changeName . '\" not yet supported'); } } if ($check) { return true; } $sql = array(); if (isset($changes['add']) && is_array($changes['add'])) { foreach ($changes['add'] as $fieldName => $field) { $query = 'ADD ' . $this->getDeclaration($fieldName, $field); $sql[] = 'ALTER TABLE ' . $name . ' ' . $query; } } if (isset($changes['remove']) && is_array($changes['remove'])) { foreach ($changes['remove'] as $fieldName => $field) { $fieldName = $this->conn->quoteIdentifier($fieldName, true); $query = 'DROP ' . $fieldName; $sql[] = 'ALTER TABLE ' . $name . ' ' . $query; } } if (isset($changes['change']) && is_array($changes['change'])) { foreach ($changes['change'] as $fieldName => $field) { $fieldName = $this->conn->quoteIdentifier($fieldName, true); if (isset($field['type'])) { $serverInfo = $this->conn->getServerVersion(); if (is_array($serverInfo) && $serverInfo['major'] < 8) { throw new Doctrine_Export_Exception('changing column type for "'.$field['type'].'\" requires PostgreSQL 8.0 or above'); } $query = 'ALTER ' . $fieldName . ' TYPE ' . $this->conn->datatype->getTypeDeclaration($field['definition']); $sql[] = 'ALTER TABLE ' . $name . ' ' . $query; } if (array_key_exists('default', $field)) { $query = 'ALTER ' . $fieldName . ' SET DEFAULT ' . $this->conn->quote($field['definition']['default'], $field['definition']['type']); $sql[] = 'ALTER TABLE ' . $name . ' ' . $query; } if ( ! empty($field['notnull'])) { $query = 'ALTER ' . $fieldName . ' ' . ($field['definition']['notnull'] ? 'SET' : 'DROP') . ' NOT NULL'; $sql[] = 'ALTER TABLE ' . $name . ' ' . $query; } } } if (isset($changes['rename']) && is_array($changes['rename'])) { foreach ($changes['rename'] as $fieldName => $field) { $fieldName = $this->conn->quoteIdentifier($fieldName, true); $sql[] = 'ALTER TABLE ' . $name . ' RENAME COLUMN ' . $fieldName . ' TO ' . $this->conn->quoteIdentifier($field['name'], true); } } $name = $this->conn->quoteIdentifier($name, true); if (isset($changes['name'])) { $changeName = $this->conn->quoteIdentifier($changes['name'], true); $sql[] = 'ALTER TABLE ' . $name . ' RENAME TO ' . $changeName; } return $sql; } public function alterTable($name, array $changes, $check = false) { $sql = $this->alterTableSql($name, $changes, $check); foreach ($sql as $query) { $this->conn->exec($query); } return true; } public function createSequenceSql($sequenceName, $start = 1, array $options = array()) { $sequenceName = $this->conn->quoteIdentifier($this->conn->formatter->getSequenceName($sequenceName), true); return 'CREATE SEQUENCE ' . $sequenceName . ' INCREMENT 1' . ($start < 1 ? ' MINVALUE ' . $start : '') . ' START ' . $start; } public function dropSequenceSql($sequenceName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->formatter->getSequenceName($sequenceName), true); return 'DROP SEQUENCE ' . $sequenceName; } public function createTableSql($name, array $fields, array $options = array()) { if ( ! $name) { throw new Doctrine_Export_Exception('no valid table name specified'); } if (empty($fields)) { throw new Doctrine_Export_Exception('no fields specified for table ' . $name); } $queryFields = $this->getFieldDeclarationList($fields); if (isset($options['primary']) && ! empty($options['primary'])) { $keyColumns = array_values($options['primary']); $keyColumns = array_map(array($this->conn, 'quoteIdentifier'), $keyColumns); $queryFields .= ', PRIMARY KEY(' . implode(', ', $keyColumns) . ')'; } $query = 'CREATE TABLE ' . $this->conn->quoteIdentifier($name, true) . ' (' . $queryFields . ')'; $sql[] = $query; if (isset($options['indexes']) && ! empty($options['indexes'])) { foreach($options['indexes'] as $index => $definition) { $sql[] = $this->createIndexSql($name, $index, $definition); } } if (isset($options['foreignKeys'])) { foreach ((array) $options['foreignKeys'] as $k => $definition) { if (is_array($definition)) { $sql[] = $this->createForeignKeySql($name, $definition); } } } return $sql; } }class Doctrine_Export_Exception extends Doctrine_Exception { }class Doctrine_Export_Schema { public function buildSchema($directory = null, $models = array()) { if ($directory !== null) { $loadedModels = Doctrine::filterInvalidModels(Doctrine::loadModels($directory)); } else { $loadedModels = Doctrine::getLoadedModels(); } $array = array(); $parent = new ReflectionClass('Doctrine_Record'); $sql = array(); $fks = array(); foreach ($loadedModels as $className) { if ( ! empty($models) && !in_array($className, $models)) { continue; } $recordTable = Doctrine::getTable($className); $data = $recordTable->getExportableFormat(); $table = array(); $remove = array('ptype', 'ntype', 'alltypes'); foreach ($data['columns'] AS $name => $column) { if (isset($column['length']) && $column['length'] && isset($column['scale']) && $column['scale']) { $data['columns'][$name]['type'] = $column['type'] . '(' . $column['length'] . ', ' . $column['scale'] . ')'; unset($data['columns'][$name]['length'], $data['columns'][$name]['scale']); } else { $data['columns'][$name]['type'] = $column['type'] . '(' . $column['length'] . ')'; unset($data['columns'][$name]['length']); } foreach ($remove as $value) { if (isset($data['columns'][$name][$value])) { unset($data['columns'][$name][$value]); } } if (count($data['columns'][$name]) === 1 && isset($data['columns'][$name]['type'])) { $type = $data['columns'][$name]['type']; unset($data['columns'][$name]); $data['columns'][$name] = $type; } } $table['tableName'] = $data['tableName']; $table['columns'] = $data['columns']; $relations = $recordTable->getRelations(); foreach ($relations as $key => $relation) { $relationData = $relation->toArray(); $relationKey = $relationData['alias']; if (isset($relationData['refTable']) && $relationData['refTable']) { $table['relations'][$relationKey]['refClass'] = $relationData['refTable']->getComponentName(); } if (isset($relationData['class']) && $relationData['class'] && $relation['class'] != $relationKey) { $table['relations'][$relationKey]['class'] = $relationData['class']; } $table['relations'][$relationKey]['local'] = $relationData['local']; $table['relations'][$relationKey]['foreign'] = $relationData['foreign']; if ($relationData['type'] === Doctrine_Relation::ONE) { $table['relations'][$relationKey]['type'] = 'one'; } else if($relationData['type'] === Doctrine_Relation::MANY) { $table['relations'][$relationKey]['type'] = 'many'; } else { $table['relations'][$relationKey]['type'] = 'one'; } } $array[$className] = $table; } return $array; } public function exportSchema($schema, $format = 'yml', $directory = null, $models = array()) { $array = $this->buildSchema($directory, $models); if (is_dir($schema)) { $schema = $schema . DIRECTORY_SEPARATOR . 'schema.' . $format; } return Doctrine_Parser::dump($array, $format, $schema); } }class Doctrine_Migration_Exception extends Doctrine_Exception { }class Doctrine_Migration_IrreversibleMigrationException extends Doctrine_Migration_Exception { }class Doctrine_Builder { public function varExport($var) { $export = var_export($var, true); $export = str_replace("\n", '', $export); $export = str_replace('  ', ' ', $export); $export = str_replace('array ( ', 'array(', $export); $export = str_replace('array( ', 'array(', $export); $export = str_replace(',)', ')', $export); $export = str_replace(', )', ')', $export); $export = str_replace('  ', ' ', $export); return $export; } }class Doctrine_Migration_Builder extends Doctrine_Builder { private $migrationsPath = ''; private $suffix = '.class.php'; private $migration; private static $tpl; public function __construct($migrationsPath = null) { if ($migrationsPath) { $this->setMigrationsPath($migrationsPath); $this->migration = new Doctrine_Migration($migrationsPath); } $this->loadTemplate(); } public function setMigrationsPath($path) { Doctrine_Lib::makeDirectories($path); $this->migrationsPath = $path; } public function getMigrationsPath() { return $this->migrationsPath; } protected function loadTemplate() { if (isset(self::$tpl)) { return; } self::$tpl =<<<END
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class %s extends %s
{
	public function up()
	{
%s
	}

	public function down()
	{
%s
	}
}
END;
} public function generateMigrationsFromDb() { $directory = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'tmp_doctrine_models'; Doctrine::generateModelsFromDb($directory); $result = $this->generateMigrationsFromModels($directory, Doctrine::MODEL_LOADING_CONSERVATIVE); Doctrine_Lib::removeDirectories($directory); return $result; } public function generateMigrationsFromModels($modelsPath = null, $modelLoading = null) { if ($modelsPath !== null) { $models = Doctrine::filterInvalidModels(Doctrine::loadModels($modelsPath, $modelLoading)); } else { $models = Doctrine::getLoadedModels(); } $models = Doctrine::initializeModels($models); $foreignKeys = array(); foreach ($models as $model) { $table = Doctrine::getTable($model); if ($table->getTableName() !== $this->migration->getTableName()) { $export = $table->getExportableFormat(); $foreignKeys[$export['tableName']] = $export['options']['foreignKeys']; $up = $this->buildCreateTable($export); $down = $this->buildDropTable($export); $className = 'Add' . Doctrine_Inflector::classify($export['tableName']); $this->generateMigrationClass($className, array(), $up, $down); } } if ( ! empty($foreignKeys)) { $className = 'ApplyForeignKeyConstraints'; $up = ''; $down = ''; foreach ($foreignKeys as $tableName => $definitions) { $tableForeignKeyNames[$tableName] = array(); foreach ($definitions as $definition) { $definition['name'] = $tableName . '_' .implode('_', (array)$definition['local']); $up .= $this->buildCreateForeignKey($tableName, $definition); $down .= $this->buildDropForeignKey($tableName, $definition); } } $this->generateMigrationClass($className, array(), $up, $down); } return true; } public function buildCreateForeignKey($tableName, $definition) { return "\t\t\$this->createForeignKey('" . $tableName . "', " . $this->varExport($definition, true) . ");"; } public function buildDropForeignKey($tableName, $definition) { return "\t\t\$this->dropForeignKey('" . $tableName . "', '" . $definition['name'] . "');\n"; } public function buildCreateTable($tableData) { $code = "\t\t\$this->createTable('" . $tableData['tableName'] . "', "; $code .= $this->varExport($tableData['columns'], true) . ", "; $code .= $this->varExport(array('indexes' => $tableData['options']['indexes'], 'primary' => $tableData['options']['primary']), true); $code .= ");"; return $code; } public function buildDropTable($tableData) { return "\t\t\$this->dropTable('" . $tableData['tableName'] . "');"; } public function generateMigrationClass($className, $options = array(), $up = null, $down = null, $return = false) { $className = Doctrine_Inflector::urlize($className); $className = str_replace('-', '_', $className); $className = Doctrine_Inflector::classify($className); if ($return || ! $this->getMigrationsPath()) { return $this->buildMigrationClass($className, null, $options, $up, $down); } else { if ( ! $this->getMigrationsPath()) { throw new Doctrine_Migration_Exception('You must specify the path to your migrations.'); } $next = (string) $this->migration->getNextVersion(); $fileName = str_repeat('0', (3 - strlen($next))) . $next . '_' . Doctrine_Inflector::tableize($className) . $this->suffix; $class = $this->buildMigrationClass($className, $fileName, $options, $up, $down); $path = $this->getMigrationsPath() . DIRECTORY_SEPARATOR . $fileName; if ( class_exists($className) || file_exists($path)) { return false; } file_put_contents($path, $class); return true; } } public function buildMigrationClass($className, $fileName = null, $options = array(), $up = null, $down = null) { $extends = isset($options['extends']) ? $options['extends']:'Doctrine_Migration'; $content = '<?php' . PHP_EOL; $content .= sprintf(self::$tpl, $className, $extends, $up, $down); return $content; } }class Doctrine_Migration_Process { public function getConnection($tableName) { return Doctrine::getConnectionByTableName($tableName); } public function processCreatedTables($tables) { foreach ($tables as $table) { $conn = $this->getConnection($table['tableName']); $conn->export->createTable($table['tableName'], $table['fields'], $table['options']); } } public function processDroppedTables($tables) { foreach ($tables as $table) { $conn = $this->getConnection($table['tableName']); $conn->export->dropTable($table['tableName']); } } public function processRenamedTables($tables) { foreach ($tables as $table) { $conn = $this->getConnection($table['newTableName']); $conn->export->alterTable($table['oldTableName'], array('name' => $table['newTableName'])); } } public function processAddedColumns($columns) { foreach ($columns as $column) { $conn = $this->getConnection($column['tableName']); $options = array(); $options = $column['options']; $options['type'] = $column['type']; $conn->export->alterTable($column['tableName'], array('add' => array($column['columnName'] => $options))); } } public function processRenamedColumns($columns) { foreach ($columns as $column) { $conn = $this->getConnection($column['tableName']); $columnList = $conn->import->listTableColumns($column['tableName']); if (isset($columnList[$column['oldColumnName']])) { $conn->export->alterTable($column['tableName'], array('rename' => array($column['oldColumnName'] => array('name' => $column['newColumnName'], 'definition'=>$columnList[$column['oldColumnName']])))); } } } public function processChangedColumns($columns) { foreach ($columns as $column) { $conn = $this->getConnection($column['tableName']); $options = array(); $options = $column['options']; $options['type'] = $column['type']; $conn->export->alterTable($column['tableName'], array('change' => array($column['columnName'] => array('definition' => $options)))); } } public function processRemovedColumns($columns) { foreach ($columns as $column) { $conn = $this->getConnection($column['tableName']); $conn->export->alterTable($column['tableName'], array('remove' => array($column['columnName'] => array()))); } } public function processAddedIndexes($indexes) { foreach ($indexes as $index) { $conn = $this->getConnection($index['tableName']); $conn->export->createIndex($index['tableName'], $index['indexName'], $index['definition']); } } public function processRemovedIndexes($indexes) { foreach ($indexes as $index) { $conn = $this->getConnection($index['tableName']); $conn->export->dropIndex($index['tableName'], $index['indexName']); } } public function processCreatedConstraints($constraints) { foreach ($constraints as $constraint) { $conn = $this->getConnection($constraint['tableName']); $conn->export->createConstraint($constraint['tableName'], $constraint['constraintName'], $constraint['definition']); } } public function processDroppedConstraints($constraints) { foreach ($constraints as $constraint) { $conn = $this->getConnection($constraint['tableName']); $conn->export->dropConstraint($constraint['tableName'], $constraint['constraintName'], $constraint['primary']); } } public function processCreatedFks($foreignKeys) { foreach ($foreignKeys as $fk) { $conn = $this->getConnection($fk['tableName']); $conn->export->createForeignKey($fk['tableName'], $fk['definition']); } } public function processDroppedFks($foreignKeys) { foreach ($foreignKeys as $fk) { $conn = $this->getConnection($fk['tableName']); $conn->export->dropForeignKey($fk['tableName'], $fk['fkName']); } } }abstract class Doctrine_Cache_Driver implements Doctrine_Cache_Interface { protected $_options = array(); public function __construct($options) { $this->_options = $options; } public function setOption($option, $value) { if (isset($this->_options[$option])) { $this->_options[$option] = $value; return true; } return false; } public function getOption($option) { if ( ! isset($this->_options[$option])) { return null; } return $this->_options[$option]; } }class Doctrine_Cache_Db extends Doctrine_Cache_Driver implements Countable { public function __construct($options) { if ( ! isset($options['connection']) || ! ($options['connection'] instanceof Doctrine_Connection)) { throw new Doctrine_Cache_Exception('Connection option not set.'); } if ( ! isset($options['tableName']) || ! is_string($options['tableName'])) { throw new Doctrine_Cache_Exception('Table name option not set.'); } $this->_options = $options; } public function getConnection() { return $this->_options['connection']; } public function fetch($id, $testCacheValidity = true) { $sql = 'SELECT data, expire FROM ' . $this->_options['tableName'] . ' WHERE id = ?'; if ($testCacheValidity) { $sql .= ' AND (expire=0 OR expire > ' . time() . ')'; } $result = $this->getConnection()->fetchAssoc($sql, array($id)); if ( ! isset($result[0])) { return false; } return unserialize($result[0]['data']); } public function contains($id) { $sql = 'SELECT expire FROM ' . $this->_options['tableName'] . ' WHERE id = ? AND (expire=0 OR expire > ' . time() . ')'; return $this->getConnection()->fetchOne($sql, array($id)); } public function save($id, $data, $lifeTime = false) { $sql = 'INSERT INTO ' . $this->_options['tableName'] . ' (id, data, expire) VALUES (?, ?, ?)'; if ($lifeTime) { $expire = time() + $lifeTime; } else { $expire = 0; } $params = array($id, serialize($data), $expire); return (bool) $this->getConnection()->exec($sql, $params); } public function delete($id) { $sql = 'DELETE FROM ' . $this->_options['tableName'] . ' WHERE id = ?'; return (bool) $this->getConnection()->exec($sql, array($id)); } public function deleteAll() { $sql = 'DELETE FROM ' . $this->_options['tableName']; return (bool) $this->getConnection()->exec($sql); } public function count() { $sql = 'SELECT COUNT(*) FROM ' . $this->_options['tableName']; return (int) $this->getConnection()->fetchOne($sql); } public function createTable() { $name = $this->_options['tableName']; $fields = array( 'id' => array( 'type' => 'string', 'length' => 255 ), 'data' => array( 'type' => 'blob' ), 'expire' => array( 'type' => 'timestamp' ) ); $options = array( 'primary' => array('id') ); $this->getConnection()->export->createTable($name, $fields, $options); } }class Doctrine_Cache_Memcache extends Doctrine_Cache_Driver { protected $_memcache = null; public function __construct($options = array()) { if ( ! extension_loaded('memcache')) { throw new Doctrine_Cache_Exception('In order to use Memcache driver, the memcache extension must be loaded.'); } parent::__construct($options); if (isset($options['servers'])) { $value= $options['servers']; if (isset($value['host'])) { $value = array(0 => $value); } $this->setOption('servers', $value); } $this->_memcache = new Memcache; foreach ($this->_options['servers'] as $server) { if ( ! array_key_exists('persistent', $server)) { $server['persistent'] = true; } if ( ! array_key_exists('port', $server)) { $server['port'] = 11211; } $this->_memcache->addServer($server['host'], $server['port'], $server['persistent']); } } public function fetch($id, $testCacheValidity = true) { return $this->_memcache->get($id); } public function contains($id) { return (bool) $this->_memcache->get($id); } public function save($id, $data, $lifeTime = false) { if ($this->_options['compression']) { $flag = MEMCACHE_COMPRESSED; } else { $flag = 0; } $result = $this->_memcache->set($id, $data, $flag, $lifeTime); } public function delete($id) { return $this->_memcache->delete($id); } }class Doctrine_Cache_Apc extends Doctrine_Cache_Driver { public function __construct($options = array()) { if ( ! extension_loaded('apc')) { throw new Doctrine_Cache_Exception('The apc extension must be loaded for using this backend !'); } parent::__construct($options); } public function fetch($id, $testCacheValidity = true) { $results = apc_fetch($id); $results = (array) $results; return $results[0]; } public function contains($id) { return apc_fetch($id) === false ? false : true; } public function save($id, $data, $lifeTime = false) { return (bool) apc_store($id, $data, $lifeTime); } public function delete($id) { return apc_delete($id); } }class Doctrine_Cache_Array implements Countable, Doctrine_Cache_Interface { protected $data; public function fetch($id, $testCacheValidity = true) { if (isset($this->data[$id])) { return $this->data[$id]; } return false; } public function contains($id) { return isset($this->data[$id]); } public function save($id, $data, $lifeTime = false) { $this->data[$id] = $data; } public function delete($id) { unset($this->data[$id]); } public function deleteAll() { $this->data = array(); } public function count() { return count($this->data); } }class Doctrine_Cache_Exception extends Doctrine_Exception { }class Doctrine_Cache_Xcache extends Doctrine_Cache_Driver { public function __construct($options = array()) { if ( ! extension_loaded('xcache') ) { throw new Doctrine_Cache_Exception('In order to use Xcache driver, the xcache extension must be loaded.'); } parent::__construct($options); } public function fetch($id, $testCacheValidity = true) { return $this->contains($id) ? xcache_get($id) : false; } public function contains($id) { return xcache_isset($id); } public function save($id, $data, $lifeTime = false) { return xcache_set($id, $data, $lifeTime); } public function delete($id) { return xcache_unset($id); } }abstract class Doctrine_Relation implements ArrayAccess { const ONE = 0; const MANY = 1; protected $definition = array('alias' => true, 'foreign' => true, 'local' => true, 'class' => true, 'type' => true, 'table' => true, 'localTable' => true, 'name' => null, 'refTable' => null, 'onDelete' => null, 'onUpdate' => null, 'deferred' => null, 'deferrable' => null, 'constraint' => null, 'equal' => false, 'cascade' => array(), 'owningSide' => false, 'refClassRelationAlias' => null, ); public function __construct(array $definition) { $def = array(); foreach ($this->definition as $key => $val) { if ( ! isset($definition[$key]) && $val) { throw new Doctrine_Exception($key . ' is required!'); } if (isset($definition[$key])) { $def[$key] = $definition[$key]; } else { $def[$key] = $this->definition[$key]; } } $this->definition = $def; } public function hasConstraint() { return ($this->definition['constraint'] || ($this->definition['onUpdate']) || ($this->definition['onDelete'])); } public function isDeferred() { return $this->definition['deferred']; } public function isDeferrable() { return $this->definition['deferrable']; } public function isEqual() { return $this->definition['equal']; } public function offsetExists($offset) { return isset($this->definition[$offset]); } public function offsetGet($offset) { if (isset($this->definition[$offset])) { return $this->definition[$offset]; } return null; } public function offsetSet($offset, $value) { if (isset($this->definition[$offset])) { $this->definition[$offset] = $value; } } public function offsetUnset($offset) { $this->definition[$offset] = false; } public function toArray() { return $this->definition; } final public function getAlias() { return $this->definition['alias']; } final public function getType() { return $this->definition['type']; } public function isCascadeDelete() { return in_array('delete', $this->definition['cascade']); } final public function getTable() { return Doctrine_Manager::getInstance() ->getConnectionForComponent($this->definition['class']) ->getTable($this->definition['class']); } final public function getClass() { return $this->definition['class']; } final public function getLocal() { return $this->definition['local']; } final public function getLocalFieldName() { return $this->definition['localTable']->getFieldName($this->definition['local']); } final public function getLocalColumnName() { return $this->definition['localTable']->getColumnName($this->definition['local']); } final public function getForeign() { return $this->definition['foreign']; } final public function getForeignFieldName() { return $this->definition['table']->getFieldName($this->definition['foreign']); } final public function getForeignColumnName() { return $this->definition['table']->getColumnName($this->definition['foreign']); } final public function isOneToOne() { return ($this->definition['type'] == Doctrine_Relation::ONE); } public function getRelationDql($count) { $component = $this->getTable()->getComponentName(); $dql = 'FROM ' . $component . ' WHERE ' . $component . '.' . $this->definition['foreign'] . ' IN (' . substr(str_repeat('?, ', $count), 0, -2) . ')'; return $dql; } abstract public function fetchRelatedFor(Doctrine_Record $record); public function __toString() { $r[] = "<pre>"; foreach ($this->definition as $k => $v) { if (is_object($v)) { $v = 'Object(' . get_class($v) . ')'; } $r[] = $k . ' : ' . $v; } $r[] = "</pre>"; return implode("\n", $r); } }class Doctrine_EventListener_Exception extends Doctrine_Exception { }class Doctrine_EventListener_Chain extends Doctrine_Access implements Doctrine_EventListener_Interface { protected $_listeners = array(); public function add($listener, $name = null) { if ( ! ($listener instanceof Doctrine_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable)) { throw new Doctrine_EventListener_Exception("Couldn't add eventlistener. EventListeners should implement either Doctrine_EventListener_Interface or Doctrine_Overloadable"); } if ($name === null) { $this->_listeners[] = $listener; } else { $this->_listeners[$name] = $listener; } } public function get($key) { if ( ! isset($this->_listeners[$key])) { return null; } return $this->_listeners[$key]; } public function set($key, $listener) { $this->_listeners[$key] = $listener; } public function onLoad(Doctrine_Record $record) { foreach ($this->_listeners as $listener) { $listener->onLoad($record); } } public function onPreLoad(Doctrine_Record $record) { foreach ($this->_listeners as $listener) { $listener->onPreLoad($record); } } public function onSleep(Doctrine_Record $record) { foreach ($this->_listeners as $listener) { $listener->onSleep($record); } } public function onWakeUp(Doctrine_Record $record) { foreach ($this->_listeners as $listener) { $listener->onWakeUp($record); } } public function postClose(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postClose($event); } } public function preClose(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preClose($event); } } public function onOpen(Doctrine_Connection $connection) { foreach ($this->_listeners as $listener) { $listener->onOpen($connection); } } public function postTransactionCommit(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postTransactionCommit($event); } } public function preTransactionCommit(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preTransactionCommit($event); } } public function postTransactionRollback(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postTransactionRollback($event); } } public function preTransactionRollback(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preTransactionRollback($event); } } public function postTransactionBegin(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postTransactionBegin($event); } } public function preTransactionBegin(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preTransactionBegin($event); } } public function onCollectionDelete(Doctrine_Collection $collection) { foreach ($this->_listeners as $listener) { $listener->onCollectionDelete($collection); } } public function onPreCollectionDelete(Doctrine_Collection $collection) { foreach ($this->_listeners as $listener) { $listener->onPreCollectionDelete($collection); } } public function postConnect(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postConnect($event); } } public function preConnect(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preConnect($event); } } public function preQuery(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preQuery($event); } } public function postQuery(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postQuery($event); } } public function prePrepare(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->prePrepare($event); } } public function postPrepare(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postPrepare($event); } } public function preExec(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preExec($event); } } public function postExec(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postExec($event); } } public function preError(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preError($event); } } public function postError(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postError($event); } } public function preFetch(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preFetch($event); } } public function postFetch(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postFetch($event); } } public function preFetchAll(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preFetchAll($event); } } public function postFetchAll(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postFetchAll($event); } } public function preStmtExecute(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preStmtExecute($event); } } public function postStmtExecute(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postStmtExecute($event); } } } abstract class Doctrine_Pager_Range { protected $_options; private $pager; final public function __construct($options = array(), $pager = null) { $this->_setOptions($options); if ($pager !== null) { $this->setPager($pager); } } public function getPager() { return $this->pager; } public function setPager($pager) { $this->pager = $pager; $this->_initialize(); } public function getOptions() { return $this->_options; } public function getOption($option) { if (isset($this->_options[$option])) { return $this->_options[$option]; } throw new Doctrine_Pager_Exception( 'Cannot access unexistent option \'' . $option . '\' in Doctrine_Pager_Range class' ); } protected function _setOptions($options) { $this->_options = $options; } public function isInRange($page) { return (array_search($page, $this->rangeAroundPage()) !== false); } abstract protected function _initialize(); abstract public function rangeAroundPage(); } class Doctrine_Pager_Range_Sliding extends Doctrine_Pager_Range { private $_chunkLength; protected function _initialize() { if (isset($this->_options['chunk'])) { $this->_setChunkLength($this->_options['chunk']); } else { throw new Doctrine_Pager_Exception('Missing parameter \'chunk\' that must be defined in options.'); } } public function getChunkLength() { return $this->_chunkLength; } protected function _setChunkLength($chunkLength) { $chunkLength = (int) $chunkLength; if (!$chunkLength) { $chunkLength = 1; } else { $this->_chunkLength = $chunkLength; } } public function rangeAroundPage() { $pager = $this->getPager(); if ($pager->getExecuted()) { $page = $pager->getPage(); $pages = $pager->getLastPage(); $chunk = $this->getChunkLength(); if ($chunk > $pages) { $chunk = $pages; } $chunkStart = $page - (floor($chunk / 2)); $chunkEnd = $page + (ceil($chunk / 2)-1); if ($chunkStart < 1) { $adjust = 1 - $chunkStart; $chunkStart = 1; $chunkEnd = $chunkEnd + $adjust; } if ($chunkEnd > $pages) { $adjust = $chunkEnd - $pages; $chunkStart = $chunkStart - $adjust; $chunkEnd = $pages; } return range($chunkStart, $chunkEnd); } throw new Doctrine_Pager_Exception( 'Cannot retrieve the range around the page of a not yet executed Pager query' ); } } class Doctrine_Pager_Range_Jumping extends Doctrine_Pager_Range { private $_chunkLength; protected function _initialize() { if (isset($this->_options['chunk'])) { $this->_setChunkLength($this->_options['chunk']); } else { throw new Doctrine_Pager_Exception('Missing parameter \'chunk\' that must be define in options.'); } } public function getChunkLength() { return $this->_chunkLength; } protected function _setChunkLength($chunkLength) { $this->_chunkLength = $chunkLength; } public function rangeAroundPage() { $pager = $this->getPager(); if ($pager->getExecuted()) { $page = $pager->getPage(); $startPage = $page - ($page - 1) % $this->getChunkLength(); $endPage = ($startPage + $this->getChunkLength()) - 1; if ($endPage > $pager->getLastPage()) { $endPage = $pager->getLastPage(); } return range($startPage, $endPage); } throw new Doctrine_Pager_Exception( 'Cannot retrieve the range around the page of a not yet executed Pager query' ); } } class Doctrine_Pager_Exception extends Doctrine_Exception { }class Doctrine_Pager_Layout { private $_pager; private $_pagerRange; private $_template; private $_selectedTemplate; private $_separatorTemplate; private $_urlMask; private $_maskReplacements = array(); public function __construct($pager, $pagerRange, $urlMask) { $this->_setPager($pager); $this->_setPagerRange($pagerRange); $this->_setUrlMask($urlMask); $this->setTemplate('[<a href="{%url}">{%page}</a>]'); $this->setSelectedTemplate(''); $this->setSeparatorTemplate(''); } public function getPager() { return $this->_pager; } protected function _setPager($pager) { $this->_pager = $pager; } public function execute($params = array(), $hydrationMode = null) { return $this->getPager()->execute($params, $hydrationMode); } public function getPagerRange() { return $this->_pagerRange; } protected function _setPagerRange($pagerRange) { $this->_pagerRange = $pagerRange; $this->getPagerRange()->setPager($this->getPager()); } public function getUrlMask() { return $this->_urlMask; } protected function _setUrlMask($urlMask) { $this->_urlMask = $urlMask; } public function getTemplate() { return $this->_template; } public function setTemplate($template) { $this->_template = $template; } public function getSelectedTemplate() { return $this->_selectedTemplate; } public function setSelectedTemplate($selectedTemplate) { $this->_selectedTemplate = $selectedTemplate; } public function getSeparatorTemplate() { return $this->_separatorTemplate; } public function setSeparatorTemplate($separatorTemplate) { $this->_separatorTemplate = $separatorTemplate; } public function addMaskReplacement($oldMask, $newMask, $asValue = false) { if (($oldMask = trim($oldMask)) != 'page_number') { $this->_maskReplacements[$oldMask] = array( 'newMask' => $newMask, 'asValue' => ($asValue === false) ? false : true ); } } public function removeMaskReplacement($oldMask) { if (isset($this->_maskReplacements[$oldMask])) { $this->_maskReplacements[$oldMask] = null; unset($this->_maskReplacements[$oldMask]); } } public function cleanMaskReplacements() { $this->_maskReplacements = null; $this->_maskReplacements = array(); } public function display($options = array(), $return = false) { $range = $this->getPagerRange()->rangeAroundPage(); $str = ''; for ($i = 0, $l = count($range); $i < $l; $i++) { $options['page_number'] = $range[$i]; $str .= $this->processPage($options); if ($i < $l - 1) { $str .= $this->getSeparatorTemplate(); } } if ($return) { return $str; } echo $str; } public function processPage($options = array()) { if (!isset($options['page_number'])) { throw new Doctrine_Pager_Exception( 'Cannot process template of the given page. ' . 'Missing at least one of needed parameters: \'page\' or \'page_number\'' ); return ''; } if (!isset($this->_maskReplacements['page']) && !isset($options['page'])) { $options['page'] = $options['page_number']; } return $this->_parseTemplate($options); } public function __toString() { return $this->display(array(), true); } protected function _parseTemplate($options = array()) { $str = $this->_parseUrlTemplate($options); $replacements = $this->_parseReplacementsTemplate($options); return strtr($str, $replacements); } protected function _parseUrlTemplate($options = array()) { $str = ''; if ($options['page_number'] == $this->getPager()->getPage()) { $str = $this->_parseMaskReplacements($this->getSelectedTemplate()); } if ($str == '') { $str = $this->_parseMaskReplacements($this->getTemplate()); } return $str; } protected function _parseReplacementsTemplate($options = array()) { $options['url'] = $this->_parseUrl($options); $replacements = array(); foreach ($options as $k => $v) { $replacements['{%'.$k.'}'] = $v; } return $replacements; } protected function _parseUrl($options = array()) { $str = $this->_parseMaskReplacements($this->getUrlMask()); $replacements = array(); foreach ($options as $k => $v) { $replacements['{%'.$k.'}'] = $v; } return strtr($str, $replacements); } protected function _parseMaskReplacements($str) { $replacements = array(); foreach ($this->_maskReplacements as $k => $v) { $replacements['{%'.$k.'}'] = ($v['asValue'] === true) ? $v['newMask'] : '{%'.$v['newMask'].'}'; } return strtr($str, $replacements); } } class Doctrine_Query_Parser { }abstract class Doctrine_Query_Part { protected $query; protected $_tokenizer; public function __construct($query, Doctrine_Query_Tokenizer $tokenizer = null) { $this->query = $query; if ( ! $tokenizer) { $tokenizer = new Doctrine_Query_Tokenizer(); } $this->_tokenizer = $tokenizer; } public function getQuery() { return $this->query; } } class Doctrine_Query_Filter_Chain { protected $_filters = array(); public function add(Doctrine_Query_Filter $filter) { $this->_filters[] = $filter; } public function get($key) { if ( ! isset($this->_filters[$key])) { throw new Doctrine_Query_Exception('Unknown filter ' . $key); } return $this->_filters[$key]; } public function set($key, Doctrine_Query_Filter $listener) { $this->_filters[$key] = $listener; } public function preQuery(Doctrine_Query $query) { foreach ($this->_filters as $filter) { $filter->preQuery($query); } } public function postQuery(Doctrine_Query $query) { foreach ($this->_filters as $filter) { $filter->postQuery($query); } } }class Doctrine_Query_Tokenizer_Exception extends Doctrine_Exception { }class Doctrine_Query_Offset extends Doctrine_Query_Part { public function parse($offset) { return (int) $offset; } }class Doctrine_Query_Select extends Doctrine_Query_Part { public function parse($dql) { $this->query->parseSelect($dql); } }class Doctrine_Query_Limit extends Doctrine_Query_Part { public function parse($limit) { return (int) $limit; } }abstract class Doctrine_Query_Condition extends Doctrine_Query_Part { public function parse($str) { $tmp = trim($str); $parts = $this->_tokenizer->bracketExplode($str, array(' \|\| ', ' OR '), '(', ')'); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $part = $this->_tokenizer->bracketTrim($part, '(', ')'); $ret[] = $this->parse($part); } $r = implode(' OR ', $ret); } else { $parts = $this->_tokenizer->bracketExplode($str, array(' AND ', ' \&\& '), '(', ')'); $tmp = array(); for ($i = 0, $l = count($parts); $i < $l; $i++) { $test = $this->_tokenizer->sqlExplode($parts[$i]); if (count($test) == 3 && strtoupper($test[1]) == 'BETWEEN') { $tmp[] = $parts[$i] . ' AND ' . $parts[++$i]; } else { $tmp[] = $parts[$i]; } } $parts = $tmp; unset($tmp); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $part = $this->_tokenizer->bracketTrim($part, '(', ')'); $ret[] = $this->parse($part); } $r = implode(' AND ', $ret); } else { if (substr($parts[0],0,1) == '(' && substr($parts[0], -1) == ')') { return $this->parse(substr($parts[0], 1, -1)); } else { if (strtoupper(substr($parts[0], 0, 4)) === 'NOT ') { $r = 'NOT ('.$this->parse(substr($parts[0], 4)).')'; } else { return $this->load($parts[0]); } } } } return '(' . $r . ')'; } public function parseLiteralValue($value) { if (strpos($value, '\'') === false) { $value = $this->query->getConnection() ->dataDict->parseBoolean($value); $a = explode('.', $value); if (count($a) > 1) { if ( ! is_numeric($a[0])) { $field = array_pop($a); $reference = implode('.', $a); $value = $this->query->getConnection()->quoteIdentifier($this->query->getTableAlias($reference). '.' . $field); } } } else { } return $value; } }class Doctrine_Query_Check { protected $table; protected $sql; protected $_tokenizer; public function __construct($table) { if ( ! ($table instanceof Doctrine_Table)) { $table = Doctrine_Manager::getInstance() ->getCurrentConnection() ->getTable($table); } $this->table = $table; $this->_tokenizer = new Doctrine_Query_Tokenizer(); } public function getTable() { return $this->table; } public function parse($dql) { $this->sql = $this->parseClause($dql); } public function parseClause($dql) { $parts = $this->_tokenizer->sqlExplode($dql, ' AND '); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $ret[] = $this->parseSingle($part); } $r = implode(' AND ', $ret); } else { $parts = $this->_tokenizer->quoteExplode($dql, ' OR '); if (count($parts) > 1) { $ret = array(); foreach ($parts as $part) { $ret[] = $this->parseClause($part); } $r = implode(' OR ', $ret); } else { $ret = $this->parseSingle($dql); return $ret; } } return '(' . $r . ')'; } public function parseSingle($part) { $e = explode(' ', $part); $e[0] = $this->parseFunction($e[0]); switch ($e[1]) { case '>': case '<': case '=': case '!=': case '<>': break; default: throw new Doctrine_Query_Exception('Unknown operator ' . $e[1]); } return implode(' ', $e); } public function parseFunction($dql) { if (($pos = strpos($dql, '(')) !== false) { $func = substr($dql, 0, $pos); $value = substr($dql, ($pos + 1), -1); $expr = $this->table->getConnection()->expression; if ( ! method_exists($expr, $func)) { throw new Doctrine_Query_Exception('Unknown function ' . $func); } $func = $expr->$func($value); } return $func; } public function getSql() { return $this->sql; } }class Doctrine_Query_From extends Doctrine_Query_Part { public function parse($str, $return = false) { $str = trim($str); $parts = $this->_tokenizer->bracketExplode($str, 'JOIN'); $from = $return ? array() : null; $operator = false; switch (trim($parts[0])) { case 'INNER': $operator = ':'; case 'LEFT': array_shift($parts); break; } $last = ''; foreach ($parts as $k => $part) { $part = trim($part); if (empty($part)) { continue; } $e = explode(' ', $part); if (end($e) == 'INNER' || end($e) == 'LEFT') { $last = array_pop($e); } $part = implode(' ', $e); foreach ($this->_tokenizer->bracketExplode($part, ',') as $reference) { $reference = trim($reference); $e = explode(' ', $reference); $e2 = explode('.', $e[0]); if ($operator) { $e[0] = array_shift($e2) . $operator . implode('.', $e2); } if ($return) { $from[] = $e; } else { $table = $this->query->load(implode(' ', $e)); } } $operator = ($last == 'INNER') ? ':' : '.'; } return $from; } } class Doctrine_Query_Filter implements Doctrine_Query_Filter_Interface { public function preQuery(Doctrine_Query $query) { } public function postQuery(Doctrine_Query $query) { } }class Doctrine_Query_Registry { protected $_queries = array(); public function add($key, $query) { if ($query instanceof Doctrine_Query) { $query = clone $query; } if (strpos($key, '/') === false) { $this->_queries[$key] = $query; } else { $e = explode('/', $key); $this->_queries[$e[0]][$e[1]] = $query; } } public function get($key, $namespace = null) { if (isset($namespace)) { if ( ! isset($this->_queries[$namespace][$key])) { throw new Doctrine_Query_Registry_Exception('A query with the name ' . $namespace . '/' . $key . ' does not exist.'); } $query = $this->_queries[$namespace][$key]; } else { if ( ! isset($this->_queries[$key])) { throw new Doctrine_Query_Registry_Exception('A query with the name ' . $key . ' does not exist.'); } $query = $this->_queries[$key]; } if ( ! ($query instanceof Doctrine_Query)) { $query = Doctrine_Query::create()->parseQuery($query); } return clone $query; } public function has($key, $namespace = null) { return isset($namespace) ? isset($this->_queries[$namespace][$key]) : isset($this->_queries[$key]); } }class Doctrine_Query_Exception extends Doctrine_Exception { }class Doctrine_Query_Forupdate extends Doctrine_Query_Part { public function parse($forUpdate) { return (bool) $forUpdate; } }class Doctrine_Query_Set extends Doctrine_Query_Part { public function parse($dql) { $terms = $this->_tokenizer->sqlExplode($dql, ' '); $termsTranslation = array(); foreach ($terms as $term) { $termOriginal = $term; $matches = array(); $hasAggExpression = $this->_processPossibleAggExpression($term, $matches); $lftExpr = (($hasAggExpression) ? $matches[1] . '(' : ''); $rgtExpr = (($hasAggExpression) ? $matches[3] . ')' : ''); preg_match_all("/[a-zA-Z0-9_]+[\.[a-zA-Z0-9_]+]*/i", $term, $m); if (isset($m[0])) { foreach ($m[0] as $part) { $e = explode('.', trim($part)); $fieldName = array_pop($e); $reference = (count($e) > 0) ? implode('.', $e) : $this->query->getRootAlias(); $aliasMap = $this->query->getAliasDeclaration($reference); if ($aliasMap['table']->hasField($fieldName)) { $columnName = $aliasMap['table']->getColumnName($fieldName); $columnName = $aliasMap['table']->getConnection()->quoteIdentifier($columnName); $termsTranslation[$termOriginal] = $lftExpr . $columnName . $rgtExpr; } } } } return strtr($dql, $termsTranslation); } protected function _processPossibleAggExpression(& $expr, & $matches = array()) { $hasAggExpr = preg_match('/(.*[^\s\(\=])\(([^\)]*)\)(.*)/', $expr, $matches); if ($hasAggExpr) { $expr = $matches[2]; if (substr(trim($matches[3]), 0, 1) == ',') { $xplod = $this->_tokenizer->sqlExplode(trim($matches[3], ' )'), ','); $matches[3] = array(); foreach ($xplod as $part) { if ($part != '') { $matches[3][] = $this->parseLiteralValue($part); } } $matches[3] = '), ' . implode(', ', $matches[3]); } } return $hasAggExpr; } }class Doctrine_Query_Registry_Exception extends Doctrine_Query_Exception { }class Doctrine_Query_Groupby extends Doctrine_Query_Part { public function parse($str, $append = false) { $r = array(); foreach (explode(',', $str) as $reference) { $reference = trim($reference); $r[] = $this->query->parseClause($reference); } return implode(', ', $r); } } abstract class Doctrine_Query_Abstract { const SELECT = 0; const DELETE = 1; const UPDATE = 2; const INSERT = 3; const CREATE = 4; const STATE_CLEAN = 1; const STATE_DIRTY = 2; const STATE_DIRECT = 3; const STATE_LOCKED = 4; protected $_tableAliasMap = array(); protected $_view; protected $_state = Doctrine_Query::STATE_CLEAN; protected $_params = array('join' => array(), 'where' => array(), 'set' => array(), 'having' => array()); protected $_resultCache; protected $_expireResultCache = false; protected $_resultCacheTTL; protected $_queryCache; protected $_expireQueryCache = false; protected $_queryCacheTTL; protected $_conn; protected $_sqlParts = array( 'select' => array(), 'distinct' => false, 'forUpdate' => false, 'from' => array(), 'set' => array(), 'join' => array(), 'where' => array(), 'groupby' => array(), 'having' => array(), 'orderby' => array(), 'limit' => false, 'offset' => false, ); protected $_dqlParts = array( 'from' => array(), 'select' => array(), 'forUpdate' => false, 'set' => array(), 'join' => array(), 'where' => array(), 'groupby' => array(), 'having' => array(), 'orderby' => array(), 'limit' => array(), 'offset' => array(), ); protected $_queryComponents = array(); protected $_type = self::SELECT; protected $_hydrator; protected $_tokenizer; protected $_parser; protected $_tableAliasSeeds = array(); protected $_options = array( 'hydrationMode' => Doctrine::HYDRATE_RECORD ); protected $_isLimitSubqueryUsed = false; protected $_components; protected $_preQueried = false; public function __construct(Doctrine_Connection $connection = null, Doctrine_Hydrator_Abstract $hydrator = null) { if ($connection === null) { $connection = Doctrine_Manager::getInstance()->getCurrentConnection(); } if ($hydrator === null) { $hydrator = new Doctrine_Hydrator(); } $this->_conn = $connection; $this->_hydrator = $hydrator; $this->_tokenizer = new Doctrine_Query_Tokenizer(); $this->_resultCacheTTL = $this->_conn->getAttribute(Doctrine::ATTR_RESULT_CACHE_LIFESPAN); $this->_queryCacheTTL = $this->_conn->getAttribute(Doctrine::ATTR_QUERY_CACHE_LIFESPAN); } public function setOption($name, $value) { if ( ! isset($this->_options[$name])) { throw new Doctrine_Query_Exception('Unknown option ' . $name); } $this->_options[$name] = $value; } public function hasTableAlias($sqlTableAlias) { return $this->hasSqlTableAlias($sqlTableAlias); } public function hasSqlTableAlias($sqlTableAlias) { return (isset($this->_tableAliasMap[$sqlTableAlias])); } public function getTableAliases() { return $this->getTableAliasMap(); } public function getTableAliasMap() { return $this->_tableAliasMap; } public function getDql() { $q = ''; if ($this->_type == self::SELECT) { $q .= ( ! empty($this->_dqlParts['select'])) ? 'SELECT ' . implode(', ', $this->_dqlParts['select']) : ''; $q .= ( ! empty($this->_dqlParts['from'])) ? ' FROM ' . implode(' ', $this->_dqlParts['from']) : ''; } else if ($this->_type == self::DELETE) { $q .= 'DELETE'; $q .= ( ! empty($this->_dqlParts['from'])) ? ' FROM ' . implode(' ', $this->_dqlParts['from']) : ''; } else if ($this->_type == self::UPDATE) { $q .= 'UPDATE '; $q .= ( ! empty($this->_dqlParts['from'])) ? implode(' ', $this->_dqlParts['from']) : ''; $q .= ( ! empty($this->_dqlParts['set'])) ? ' SET ' . implode(' ', $this->_dqlParts['set']) : ''; } $q .= ( ! empty($this->_dqlParts['where'])) ? ' WHERE ' . implode(' ', $this->_dqlParts['where']) : ''; $q .= ( ! empty($this->_dqlParts['groupby'])) ? ' GROUP BY ' . implode(', ', $this->_dqlParts['groupby']) : ''; $q .= ( ! empty($this->_dqlParts['having'])) ? ' HAVING ' . implode(' AND ', $this->_dqlParts['having']) : ''; $q .= ( ! empty($this->_dqlParts['orderby'])) ? ' ORDER BY ' . implode(', ', $this->_dqlParts['orderby']) : ''; $q .= ( ! empty($this->_dqlParts['limit'])) ? ' LIMIT ' . implode(' ', $this->_dqlParts['limit']) : ''; $q .= ( ! empty($this->_dqlParts['offset'])) ? ' OFFSET ' . implode(' ', $this->_dqlParts['offset']) : ''; return $q; } public function getQueryPart($part) { return $this->getSqlQueryPart($part); } public function getSqlQueryPart($part) { if ( ! isset($this->_sqlParts[$part])) { throw new Doctrine_Query_Exception('Unknown SQL query part ' . $part); } return $this->_sqlParts[$part]; } public function setQueryPart($name, $part) { return $this->setSqlQueryPart($name, $part); } public function setSqlQueryPart($name, $part) { if ( ! isset($this->_sqlParts[$name])) { throw new Doctrine_Query_Exception('Unknown query part ' . $name); } if ($name !== 'limit' && $name !== 'offset') { if (is_array($part)) { $this->_sqlParts[$name] = $part; } else { $this->_sqlParts[$name] = array($part); } } else { $this->_sqlParts[$name] = $part; } return $this; } public function addQueryPart($name, $part) { return $this->addSqlQueryPart($name, $part); } public function addSqlQueryPart($name, $part) { if ( ! isset($this->_sqlParts[$name])) { throw new Doctrine_Query_Exception('Unknown query part ' . $name); } if (is_array($part)) { $this->_sqlParts[$name] = array_merge($this->_sqlParts[$name], $part); } else { $this->_sqlParts[$name][] = $part; } return $this; } public function removeQueryPart($name) { return $this->removeSqlQueryPart($name); } public function removeSqlQueryPart($name) { if ( ! isset($this->_sqlParts[$name])) { throw new Doctrine_Query_Exception('Unknown query part ' . $name); } if ($name == 'limit' || $name == 'offset') { $this->_sqlParts[$name] = false; } else { $this->_sqlParts[$name] = array(); } return $this; } public function removeDqlQueryPart($name) { if ( ! isset($this->_dqlParts[$name])) { throw new Doctrine_Query_Exception('Unknown query part ' . $name); } if ($name == 'limit' || $name == 'offset') { $this->_dqlParts[$name] = false; } else { $this->_dqlParts[$name] = array(); } return $this; } public function getParams($params = array()) { return array_merge($params, $this->_params['join'], $this->_params['set'], $this->_params['where'], $this->_params['having']); } public function getRawParams() { return $this->_params; } public function setParams(array $params = array()) { $this->_params = $params; } public function setView(Doctrine_View $view) { $this->_view = $view; } public function getView() { return $this->_view; } public function isLimitSubqueryUsed() { return $this->_isLimitSubqueryUsed; } public function getInheritanceCondition($componentAlias) { $map = $this->_queryComponents[$componentAlias]['table']->inheritanceMap; if (empty($map)) { return; } $tableAlias = $this->getSqlTableAlias($componentAlias); if ($this->_type !== Doctrine_Query::SELECT) { $tableAlias = ''; } else { $tableAlias .= '.'; } $field = key($map); $value = current($map); $identifier = $this->_conn->quoteIdentifier($tableAlias . $field); return $identifier . ' = ' . $this->_conn->quote($value);; } public function getTableAlias($componentAlias, $tableName = null) { return $this->getSqlTableAlias($componentAlias, $tableName); } public function getSqlTableAlias($componentAlias, $tableName = null) { $alias = array_search($componentAlias, $this->_tableAliasMap); if ($alias !== false) { return $alias; } if ($tableName === null) { throw new Doctrine_Query_Exception("Couldn't get short alias for " . $componentAlias); } return $this->generateTableAlias($componentAlias, $tableName); } public function generateNewTableAlias($oldAlias) { return $this->generateNewSqlTableAlias($oldAlias); } public function generateNewSqlTableAlias($oldAlias) { if (isset($this->_tableAliasMap[$oldAlias])) { $name = substr($oldAlias, 0, 1); $i = ((int) substr($oldAlias, 1)); if ( ! isset($this->_tableAliasSeeds[$name])) { $this->_tableAliasSeeds[$name] = 1; } $newIndex = ($this->_tableAliasSeeds[$name] + (($i == 0) ? 1 : $i)); return $name . $newIndex; } return $oldAlias; } public function getTableAliasSeed($sqlTableAlias) { return $this->getSqlTableAliasSeed($sqlTableAlias); } public function getSqlTableAliasSeed($sqlTableAlias) { if ( ! isset($this->_tableAliasSeeds[$sqlTableAlias])) { return 0; } return $this->_tableAliasSeeds[$sqlTableAlias]; } public function hasAliasDeclaration($componentAlias) { return isset($this->_queryComponents[$componentAlias]); } public function getAliasDeclaration($componentAlias) { return $this->getQueryComponent($componentAlias); } public function getQueryComponent($componentAlias) { if ( ! isset($this->_queryComponents[$componentAlias])) { throw new Doctrine_Query_Exception('Unknown component alias ' . $componentAlias); } return $this->_queryComponents[$componentAlias]; } public function copySubqueryInfo(Doctrine_Query_Abstract $query) { $this->_params =& $query->_params; $this->_tableAliasMap =& $query->_tableAliasMap; $this->_queryComponents =& $query->_queryComponents; $this->_tableAliasSeeds = $query->_tableAliasSeeds; return $this; } public function getRootAlias() { if ( ! $this->_queryComponents) { $this->getSql(); } reset($this->_queryComponents); return key($this->_queryComponents); } public function getRootDeclaration() { $map = reset($this->_queryComponents); return $map; } public function getRoot() { $map = reset($this->_queryComponents); if ( ! isset($map['table'])) { throw new Doctrine_Query_Exception('Root component not initialized.'); } return $map['table']; } public function generateTableAlias($componentAlias, $tableName) { return $this->generateSqlTableAlias($componentAlias, $tableName); } public function generateSqlTableAlias($componentAlias, $tableName) { preg_match('/([^_])/', $tableName, $matches); $char = strtolower($matches[0]); $alias = $char; if ( ! isset($this->_tableAliasSeeds[$alias])) { $this->_tableAliasSeeds[$alias] = 1; } while (isset($this->_tableAliasMap[$alias])) { if ( ! isset($this->_tableAliasSeeds[$alias])) { $this->_tableAliasSeeds[$alias] = 1; } $alias = $char . ++$this->_tableAliasSeeds[$alias]; } $this->_tableAliasMap[$alias] = $componentAlias; return $alias; } public function getComponentAlias($sqlTableAlias) { $sqlTableAlias = trim($sqlTableAlias, '[]`"'); if ( ! isset($this->_tableAliasMap[$sqlTableAlias])) { throw new Doctrine_Query_Exception('Unknown table alias ' . $sqlTableAlias); } return $this->_tableAliasMap[$sqlTableAlias]; } public function calculateQueryCacheHash() { $dql = $this->getDql(); $hash = md5($dql . 'DOCTRINE_QUERY_CACHE_SALT'); return $hash; } public function calculateResultCacheHash($params = array()) { $dql = $this->getDql(); $params = $this->getParams($params); $hash = md5($dql . var_export($params, true)); return $hash; } protected function _execute($params) { $params = $this->_conn->convertBooleans($params); if ( ! $this->_view) { if ($this->_queryCache !== false && ($this->_queryCache || $this->_conn->getAttribute(Doctrine::ATTR_QUERY_CACHE))) { $queryCacheDriver = $this->getQueryCacheDriver(); $hash = $this->calculateQueryCacheHash(); $cached = $queryCacheDriver->fetch($hash); if ($cached) { $query = $this->_constructQueryFromCache($cached); } else { $query = $this->getSqlQuery($params); $serializedQuery = $this->getCachedForm($query); $queryCacheDriver->save($hash, $serializedQuery, $this->getQueryCacheLifeSpan()); } } else { $query = $this->getSqlQuery($params); } } else { $query = $this->_view->getSelectSql(); } if ($this->isLimitSubqueryUsed() && $this->_conn->getAttribute(Doctrine::ATTR_DRIVER_NAME) !== 'mysql') { $params = array_merge($params, $params); } if ($this->_type !== self::SELECT) { return $this->_conn->exec($query, $params); } $stmt = $this->_conn->execute($query, $params); return $stmt; } public function execute($params = array(), $hydrationMode = null) { if (empty($this->_dqlParts['from']) && empty($this->_sqlParts['from'])) { throw new Doctrine_Query_Exception('You must have at least one component specified in your from.'); } $preQueryParams = $this->getParams($params); $this->_preQuery($preQueryParams); if ($hydrationMode !== null) { $this->_hydrator->setHydrationMode($hydrationMode); } $params = $this->getParams($params); if ($this->_resultCache && $this->_type == self::SELECT) { $cacheDriver = $this->getResultCacheDriver(); $hash = $this->calculateResultCacheHash($params); $cached = ($this->_expireResultCache) ? false : $cacheDriver->fetch($hash); if ($cached === false) { $stmt = $this->_execute($params); $this->_hydrator->setQueryComponents($this->_queryComponents); $result = $this->_hydrator->hydrateResultSet($stmt, $this->_tableAliasMap); $cached = $this->getCachedForm($result); $cacheDriver->save($hash, $cached, $this->getResultCacheLifeSpan()); } else { $result = $this->_constructQueryFromCache($cached); } } else { $stmt = $this->_execute($params); if (is_integer($stmt)) { $result = $stmt; } else { $this->_hydrator->setQueryComponents($this->_queryComponents); $result = $this->_hydrator->hydrateResultSet($stmt, $this->_tableAliasMap); } } return $result; } protected function _getDqlCallback() { $callback = false; if ( ! empty($this->_dqlParts['from'])) { switch ($this->_type) { case self::DELETE: $callback = array( 'callback' => 'preDqlDelete', 'const' => Doctrine_Event::RECORD_DQL_DELETE ); break; case self::UPDATE: $callback = array( 'callback' => 'preDqlUpdate', 'const' => Doctrine_Event::RECORD_DQL_UPDATE ); break; case self::SELECT: $callback = array( 'callback' => 'preDqlSelect', 'const' => Doctrine_Event::RECORD_DQL_SELECT ); break; } } return $callback; } protected function _preQuery($params = array()) { if ( ! $this->_preQueried && $this->getConnection()->getAttribute('use_dql_callbacks')) { $this->_preQueried = true; $callback = $this->_getDqlCallback(); if ( ! $callback) { return; } foreach ($this->_getDqlCallbackComponents($params) as $alias => $component) { $table = $component['table']; $record = $table->getRecordInstance(); $params = array('component' => $component, 'alias' => $alias); $event = new Doctrine_Event($record, $callback['const'], $this, $params); $record->$callback['callback']($event); $table->getRecordListener()->$callback['callback']($event); } } $this->preQuery(); } protected function _getDqlCallbackComponents($params = array()) { $componentsBefore = array(); if ($this->isSubquery()) { $componentsBefore = $this->getQueryComponents(); } $copy = $this->copy(); $copy->getSqlQuery($params); $componentsAfter = $copy->getQueryComponents(); if ($componentsBefore !== $componentsAfter) { return array_diff($componentsAfter, $componentsBefore); } else { return $componentsAfter; } } public function preQuery() { } protected function _constructQueryFromCache($cached) { $cached = unserialize($cached); $this->_tableAliasMap = $cached[2]; $customComponent = $cached[0]; $queryComponents = array(); $cachedComponents = $cached[1]; foreach ($cachedComponents as $alias => $components) { $e = explode('.', $components[0]); if (count($e) === 1) { $queryComponents[$alias]['table'] = $this->_conn->getTable($e[0]); } else { $queryComponents[$alias]['parent'] = $e[0]; $queryComponents[$alias]['relation'] = $queryComponents[$e[0]]['table']->getRelation($e[1]); $queryComponents[$alias]['table'] = $queryComponents[$alias]['relation']->getTable(); } if (isset($components[1])) { $queryComponents[$alias]['agg'] = $components[1]; } if (isset($components[2])) { $queryComponents[$alias]['map'] = $components[2]; } } $this->_queryComponents = $queryComponents; return $customComponent; } public function getCachedForm($customComponent = null) { $componentInfo = array(); foreach ($this->getQueryComponents() as $alias => $components) { if ( ! isset($components['parent'])) { $componentInfo[$alias][] = $components['table']->getComponentName(); } else { $componentInfo[$alias][] = $components['parent'] . '.' . $components['relation']->getAlias(); } if (isset($components['agg'])) { $componentInfo[$alias][] = $components['agg']; } if (isset($components['map'])) { $componentInfo[$alias][] = $components['map']; } } return serialize(array($customComponent, $componentInfo, $this->getTableAliasMap())); } public function addSelect($select) { return $this->_addDqlQueryPart('select', $select, true); } public function addTableAlias($tableAlias, $componentAlias) { return $this->addSqlTableAlias($tableAlias, $componentAlias); } public function addSqlTableAlias($sqlTableAlias, $componentAlias) { $this->_tableAliasMap[$sqlTableAlias] = $componentAlias; return $this; } public function addFrom($from) { return $this->_addDqlQueryPart('from', $from, true); } public function addWhere($where, $params = array()) { return $this->andWhere($where, $params); } public function andWhere($where, $params = array()) { if (is_array($params)) { $this->_params['where'] = array_merge($this->_params['where'], $params); } else { $this->_params['where'][] = $params; } if ($this->_hasDqlQueryPart('where')) { $this->_addDqlQueryPart('where', 'AND', true); } return $this->_addDqlQueryPart('where', $where, true); } public function orWhere($where, $params = array()) { if (is_array($params)) { $this->_params['where'] = array_merge($this->_params['where'], $params); } else { $this->_params['where'][] = $params; } if ($this->_hasDqlQueryPart('where')) { $this->_addDqlQueryPart('where', 'OR', true); } return $this->_addDqlQueryPart('where', $where, true); } public function whereIn($expr, $params = array(), $not = false) { return $this->andWhereIn($expr, $params, $not); } public function andWhereIn($expr, $params = array(), $not = false) { if ( ! count($params)) { return $this; } if ($this->_hasDqlQueryPart('where')) { $this->_addDqlQueryPart('where', 'AND', true); } return $this->_addDqlQueryPart('where', $this->_processWhereIn($expr, $params, $not), true); } public function orWhereIn($expr, $params = array(), $not = false) { if ( ! count($params)) { return $this; } if ($this->_hasDqlQueryPart('where')) { $this->_addDqlQueryPart('where', 'OR', true); } return $this->_addDqlQueryPart('where', $this->_processWhereIn($expr, $params, $not), true); } protected function _processWhereIn($expr, $params = array(), $not = false) { $params = (array) $params; if ( ! count($params)) { return $this; } $a = array(); foreach ($params as $k => $value) { if ($value instanceof Doctrine_Expression) { $value = $value->getSql(); unset($params[$k]); } else { $value = '?'; } $a[] = $value; } $this->_params['where'] = array_merge($this->_params['where'], $params); return $expr . ($not === true ? ' NOT ':'') . ' IN (' . implode(', ', $a) . ')'; } public function whereNotIn($expr, $params = array()) { return $this->whereIn($expr, $params, true); } public function andWhereNotIn($expr, $params = array()) { return $this->andWhereIn($expr, $params, true); } public function orWhereNotIn($expr, $params = array()) { return $this->orWhereIn($expr, $params, true); } public function addGroupBy($groupby) { return $this->_addDqlQueryPart('groupby', $groupby, true); } public function addHaving($having, $params = array()) { if (is_array($params)) { $this->_params['having'] = array_merge($this->_params['having'], $params); } else { $this->_params['having'][] = $params; } return $this->_addDqlQueryPart('having', $having, true); } public function addOrderBy($orderby) { return $this->_addDqlQueryPart('orderby', $orderby, true); } public function select($select) { return $this->_addDqlQueryPart('select', $select); } public function distinct($flag = true) { $this->_sqlParts['distinct'] = (bool) $flag; return $this; } public function forUpdate($flag = true) { $this->_sqlParts['forUpdate'] = (bool) $flag; return $this; } public function delete($from = null) { $this->_type = self::DELETE; if ($from != null) { return $this->_addDqlQueryPart('from', $from); } return $this; } public function update($from = null) { $this->_type = self::UPDATE; if ($from != null) { return $this->_addDqlQueryPart('from', $from); } return $this; } public function set($key, $value, $params = null) { if (is_array($key)) { foreach ($key as $k => $v) { $this->set($k, '?', array($v)); } return $this; } else { if ($params !== null) { if (is_array($params)) { $this->_params['set'] = array_merge($this->_params['set'], $params); } else { $this->_params['set'][] = $params; } } return $this->_addDqlQueryPart('set', $key . ' = ' . $value, true); } } public function from($from) { return $this->_addDqlQueryPart('from', $from); } public function innerJoin($join, $params = array()) { if (is_array($params)) { $this->_params['join'] = array_merge($this->_params['join'], $params); } else { $this->_params['join'][] = $params; } return $this->_addDqlQueryPart('from', 'INNER JOIN ' . $join, true); } public function leftJoin($join, $params = array()) { if (is_array($params)) { $this->_params['join'] = array_merge($this->_params['join'], $params); } else { $this->_params['join'][] = $params; } return $this->_addDqlQueryPart('from', 'LEFT JOIN ' . $join, true); } public function groupBy($groupby) { return $this->_addDqlQueryPart('groupby', $groupby); } public function where($where, $params = array()) { $this->_params['where'] = array(); if (is_array($params)) { $this->_params['where'] = $params; } else { $this->_params['where'][] = $params; } return $this->_addDqlQueryPart('where', $where); } public function having($having, $params = array()) { $this->_params['having'] = array(); if (is_array($params)) { $this->_params['having'] = $params; } else { $this->_params['having'][] = $params; } return $this->_addDqlQueryPart('having', $having); } public function orderBy($orderby) { return $this->_addDqlQueryPart('orderby', $orderby); } public function limit($limit) { return $this->_addDqlQueryPart('limit', $limit); } public function offset($offset) { return $this->_addDqlQueryPart('offset', $offset); } public function getSql($params = array()) { return $this->getSqlQuery($params); } protected function clear() { $this->_sqlParts = array( 'select' => array(), 'distinct' => false, 'forUpdate' => false, 'from' => array(), 'set' => array(), 'join' => array(), 'where' => array(), 'groupby' => array(), 'having' => array(), 'orderby' => array(), 'limit' => false, 'offset' => false, ); } public function setHydrationMode($hydrationMode) { $this->_hydrator->setHydrationMode($hydrationMode); return $this; } public function getAliasMap() { return $this->_queryComponents; } public function getQueryComponents() { return $this->_queryComponents; } public function getParts() { return $this->getSqlParts(); } public function getSqlParts() { return $this->_sqlParts; } public function getType() { return $this->_type; } public function useCache($driver = true, $timeToLive = null) { return $this->useResultCache($driver, $timeToLive); } public function useResultCache($driver = true, $timeToLive = null) { if ($driver !== null && $driver !== true && ! ($driver instanceOf Doctrine_Cache_Interface)) { $msg = 'First argument should be instance of Doctrine_Cache_Interface or null.'; throw new Doctrine_Query_Exception($msg); } $this->_resultCache = $driver; if ($timeToLive !== null) { $this->setResultCacheLifeSpan($timeToLive); } return $this; } public function useQueryCache($driver = true, $timeToLive = null) { if ($driver !== null && $driver !== true && $driver !== false && ! ($driver instanceOf Doctrine_Cache_Interface)) { $msg = 'First argument should be instance of Doctrine_Cache_Interface or null.'; throw new Doctrine_Query_Exception($msg); } $this->_queryCache = $driver; if ($timeToLive !== null) { $this->setQueryCacheLifeSpan($timeToLive); } return $this; } public function expireCache($expire = true) { return $this->expireResultCache($expire); } public function expireResultCache($expire = true) { $this->_expireResultCache = true; return $this; } public function expireQueryCache($expire = true) { $this->_expireQueryCache = true; return $this; } public function setCacheLifeSpan($timeToLive) { return $this->setResultCacheLifeSpan($timeToLive); } public function setResultCacheLifeSpan($timeToLive) { if ($timeToLive !== null) { $timeToLive = (int) $timeToLive; } $this->_resultCacheTTL = $timeToLive; return $this; } public function getResultCacheLifeSpan() { return $this->_resultCacheTTL; } public function setQueryCacheLifeSpan($timeToLive) { if ($timeToLive !== null) { $timeToLive = (int) $timeToLive; } $this->_queryCacheTTL = $timeToLive; return $this; } public function getQueryCacheLifeSpan() { return $this->_queryCacheTTL; } public function getCacheDriver() { return $this->getResultCacheDriver(); } public function getResultCacheDriver() { if ($this->_resultCache instanceof Doctrine_Cache_Interface) { return $this->_resultCache; } else { return $this->_conn->getResultCacheDriver(); } } public function getQueryCacheDriver() { if ($this->_queryCache instanceof Doctrine_Cache_Interface) { return $this->_queryCache; } else { return $this->_conn->getQueryCacheDriver(); } } public function getConnection() { return $this->_conn; } protected function _hasDqlQueryPart($queryPartName) { return count($this->_dqlParts[$queryPartName]) > 0; } protected function _addDqlQueryPart($queryPartName, $queryPart, $append = false) { if ($queryPart === null) { throw new Doctrine_Query_Exception('Cannot define NULL as part of query when defining \'' . $queryPartName . '\'.'); } if ($append) { $this->_dqlParts[$queryPartName][] = $queryPart; } else { $this->_dqlParts[$queryPartName] = array($queryPart); } $this->_state = Doctrine_Query::STATE_DIRTY; return $this; } protected function _processDqlQueryPart($queryPartName, $queryParts) { $this->removeSqlQueryPart($queryPartName); if (is_array($queryParts) && ! empty($queryParts)) { foreach ($queryParts as $queryPart) { $parser = $this->_getParser($queryPartName); $sql = $parser->parse($queryPart); if (isset($sql)) { if ($queryPartName == 'limit' || $queryPartName == 'offset') { $this->setSqlQueryPart($queryPartName, $sql); } else { $this->addSqlQueryPart($queryPartName, $sql); } } } } } protected function _getParser($name) { if ( ! isset($this->_parsers[$name])) { $class = 'Doctrine_Query_' . ucwords(strtolower($name)); Doctrine::autoload($class); if ( ! class_exists($class)) { throw new Doctrine_Query_Exception('Unknown parser ' . $name); } $this->_parsers[$name] = new $class($this, $this->_tokenizer); } return $this->_parsers[$name]; } abstract public function getSqlQuery($params = array()); abstract public function parseDqlQuery($query); public function parseQuery($query) { return $this->parseDqlQuery($query); } public function getQuery($params = array()) { return $this->getSqlQuery($params); } } class Doctrine_Query_JoinCondition extends Doctrine_Query_Condition { public function load($condition) { $condition = trim($condition); $e = $this->_tokenizer->sqlExplode($condition); if (($l = count($e)) > 2) { $leftExpr = $this->query->parseClause($e[0]); $operator = $e[1]; if ($l == 4) { $operator .= ' ' . $e[2]; $e[2] = $e[3]; unset($e[3]); } else if ($l >= 5) { $e[2] .= ' ' . $e[3] . ' ' . $e[4]; unset($e[3], $e[4]); } if (substr(trim($e[2]), 0, 1) != '(') { $expr = new Doctrine_Expression($e[2], $this->query->getConnection()); $e[2] = $expr->getSql(); } $rightMatches = array(); $hasRightAggExpression = $this->_processPossibleAggExpression($e[2], $rightMatches); $value = $e[2]; if (substr($value, 0, 1) == '(') { $trimmed = $this->_tokenizer->bracketTrim($value); $trimmed_upper = strtoupper($trimmed); if (substr($trimmed_upper, 0, 4) == 'FROM' || substr($trimmed_upper, 0, 6) == 'SELECT') { $q = $this->query->createSubquery()->parseQuery($trimmed, false); $value = '(' . $q->getSql() . ')'; } elseif (substr($trimmed_upper, 0, 4) == 'SQL:') { $value = substr($trimmed, 4); } else { $e = $this->_tokenizer->sqlExplode($trimmed, ','); $value = array(); foreach ($e as $part) { $value[] = $this->parseLiteralValue($part); } $value = '(' . implode(', ', $value) . ')'; } } else { $e = $this->_tokenizer->bracketExplode($value, array(' AND ', ' \&\& '), '(', ')'); $value = array(); foreach ($e as $part) { $value[] = $this->parseLiteralValue($part); } $value = implode(' AND ', $value); } switch ($operator) { case '<': case '>': case '=': case '!=': default: $rightExpr = (($hasRightAggExpression) ? $rightMatches[1] . '(' : '') . $value . (($hasRightAggExpression) ? $rightMatches[3] . ')' : '') ; $condition = $leftExpr . ' ' . $operator . ' ' . $rightExpr; } return $condition; } $parser = new Doctrine_Query_Where($this->query, $this->_tokenizer); return $parser->parse($condition); } protected function _processPossibleAggExpression(& $expr, & $matches = array()) { $hasAggExpr = preg_match('/(.*[^\s\(\=])\(([^\)]*)\)(.*)/', $expr, $matches); if ($hasAggExpr) { $expr = $matches[2]; if (substr(trim($matches[3]), 0, 1) == ',') { $xplod = $this->_tokenizer->sqlExplode(trim($matches[3], ' )'), ','); $matches[3] = array(); foreach ($xplod as $part) { if ($part != '') { $matches[3][] = $this->parseLiteralValue($part); } } $matches[3] = '), ' . implode(', ', $matches[3]); } } return $hasAggExpr; } } class Doctrine_Query_Having extends Doctrine_Query_Condition { private function parseAggregateFunction($func) { $pos = strpos($func, '('); if ($pos !== false) { $funcs = array(); $name = substr($func, 0, $pos); $func = substr($func, ($pos + 1), -1); $params = $this->_tokenizer->bracketExplode($func, ',', '(', ')'); foreach ($params as $k => $param) { $params[$k] = $this->parseAggregateFunction($param); } $funcs = $name . '(' . implode(', ', $params) . ')'; return $funcs; } else { if ( ! is_numeric($func)) { $a = explode('.', $func); if (count($a) > 1) { $field = array_pop($a); $reference = implode('.', $a); $map = $this->query->load($reference, false); $field = $map['table']->getColumnName($field); $func = $this->query->getTableAlias($reference) . '.' . $field; } else { $field = end($a); $func = $this->query->getAggregateAlias($field); } return $this->query->getConnection()->quoteIdentifier($func); } else { return $this->query->getConnection()->quoteIdentifier($func); } } } final public function load($having) { $tokens = $this->_tokenizer->bracketExplode($having, ' ', '(', ')'); $part = $this->parseAggregateFunction(array_shift($tokens)); $operator = array_shift($tokens); $value = implode(' ', $tokens); $part .= ' ' . $operator . ' ' . $value; if (strpos($value, '(') !== false) { $value = $this->parseAggregateFunction($value); } return $part; } } class Doctrine_Query_Where extends Doctrine_Query_Condition { public function load($where) { $where = $this->_tokenizer->bracketTrim(trim($where)); $conn = $this->query->getConnection(); $terms = $this->_tokenizer->sqlExplode($where); if (count($terms) > 1) { if (substr($where, 0, 6) == 'EXISTS') { return $this->parseExists($where, true); } elseif (substr($where, 0, 10) == 'NOT EXISTS') { return $this->parseExists($where, false); } } if (count($terms) < 3) { $terms = $this->_tokenizer->sqlExplode($where, array('=', '<', '<>', '>', '!=')); } if (count($terms) > 1) { $first = array_shift($terms); $value = array_pop($terms); $operator = trim(substr($where, strlen($first), -strlen($value))); $table = null; $field = null; if (strpos($first, "'") === false && strpos($first, '(') === false) { $a = explode('.', $first); $field = array_pop($a); $reference = implode('.', $a); if (empty($reference)) { $map = $this->query->getRootDeclaration(); $alias = $this->query->getTableAlias($this->query->getRootAlias()); $table = $map['table']; } else { $map = $this->query->load($reference, false); $alias = $this->query->getTableAlias($reference); $table = $map['table']; } } $first = $this->query->parseClause($first); $sql = $first . ' ' . $operator . ' ' . $this->parseValue($value, $table, $field); return $sql; } else { return $where; } } public function parseValue($value, Doctrine_Table $table = null, $field = null) { $conn = $this->query->getConnection(); if (substr($value, 0, 1) == '(') { $trimmed = $this->_tokenizer->bracketTrim($value); if (substr($trimmed, 0, 4) == 'FROM' || substr($trimmed, 0, 6) == 'SELECT') { $q = $this->query->createSubquery()->parseQuery($trimmed, false); $sql = $q->getSql(); $value = '(' . $sql . ')'; } elseif (substr($trimmed, 0, 4) == 'SQL:') { $value = '(' . substr($trimmed, 4) . ')'; } else { $e = $this->_tokenizer->sqlExplode($trimmed, ','); $value = array(); $index = false; foreach ($e as $part) { $value[] = $this->parseLiteralValue($part); } $value = '(' . implode(', ', $value) . ')'; } } else { $value = $this->parseLiteralValue($value); } return $value; } public function parseExists($where, $negation) { $operator = ($negation) ? 'EXISTS' : 'NOT EXISTS'; $pos = strpos($where, '('); if ($pos == false) { throw new Doctrine_Query_Exception('Unknown expression, expected a subquery with () -marks'); } $sub = $this->_tokenizer->bracketTrim(substr($where, $pos)); return $operator . ' (' . $this->query->createSubquery()->parseQuery($sub, false)->getQuery() . ')'; } } class Doctrine_Query_Tokenizer { public function tokenizeQuery($query) { $parts = array(); $tokens = $this->sqlExplode($query, ' '); foreach ($tokens as $index => $token) { $token = trim($token); switch (strtolower($token)) { case 'delete': case 'update': case 'select': case 'set': case 'from': case 'where': case 'limit': case 'offset': case 'having': $p = $token; $parts[$token] = ''; break; case 'order': case 'group': $i = ($index + 1); if (isset($tokens[$i]) && strtolower($tokens[$i]) === 'by') { $p = $token; $parts[$token] = ''; } else { $parts[$p] .= "$token "; } break; case 'by': continue; default: if ( ! isset($p)) { throw new Doctrine_Query_Tokenizer_Exception( "Couldn't tokenize query. Encountered invalid token: '$token'."); } $parts[$p] .= "$token "; } } return $parts; } public function bracketTrim($str, $e1 = '(', $e2 = ')') { if (substr($str, 0, 1) === $e1 && substr($str, -1) === $e2) { return substr($str, 1, -1); } else { return $str; } } public function bracketExplode($str, $d = ' ', $e1 = '(', $e2 = ')') { if (is_array($d)) { $a = preg_split('#('.implode('|', $d).')#i', $str); $d = stripslashes($d[0]); } else { $a = explode($d, $str); } $i = 0; $term = array(); foreach($a as $key=>$val) { if (empty($term[$i])) { $term[$i] = trim($val); $s1 = substr_count($term[$i], $e1); $s2 = substr_count($term[$i], $e2); if ($s1 == $s2) { $i++; } } else { $term[$i] .= $d . trim($val); $c1 = substr_count($term[$i], $e1); $c2 = substr_count($term[$i], $e2); if ($c1 == $c2) { $i++; } } } return $term; } public function quoteExplode($str, $d = ' ') { if (is_array($d)) { $a = preg_split('/('.implode('|', $d).')/', $str); $d = stripslashes($d[0]); } else { $a = explode($d, $str); } $i = 0; $term = array(); foreach ($a as $key => $val) { if (empty($term[$i])) { $term[$i] = trim($val); if ( ! (substr_count($term[$i], "'") & 1)) { $i++; } } else { $term[$i] .= $d . trim($val); if ( ! (substr_count($term[$i], "'") & 1)) { $i++; } } } return $term; } public function sqlExplode($str, $d = ' ', $e1 = '(', $e2 = ')') { if ($d == ' ') { $d = array(' ', '\s'); } if (is_array($d)) { $d = array_map('preg_quote', $d); if (in_array(' ', $d)) { $d[] = '\s'; } $split = '#(' . implode('|', $d) . ')#'; $str = preg_split($split, $str); $d = stripslashes($d[0]); } else { $str = explode($d, $str); } $i = 0; $term = array(); foreach ($str as $key => $val) { if (empty($term[$i])) { $term[$i] = trim($val); $s1 = substr_count($term[$i], $e1); $s2 = substr_count($term[$i], $e2); if (strpos($term[$i], '(') !== false) { if ($s1 == $s2) { $i++; } } else { if ( ! (substr_count($term[$i], "'") & 1) && ! (substr_count($term[$i], "\"") & 1)) { $i++; } } } else { $term[$i] .= $d . trim($val); $c1 = substr_count($term[$i], $e1); $c2 = substr_count($term[$i], $e2); if (strpos($term[$i], '(') !== false) { if ($c1 == $c2) { $i++; } } else { if ( ! (substr_count($term[$i], "'") & 1) && ! (substr_count($term[$i], "\"") & 1)) { $i++; } } } } return $term; } public function clauseExplode($str, array $d, $e1 = '(', $e2 = ')') { if (is_array($d)) { $d = array_map('preg_quote', $d); if (in_array(' ', $d)) { $d[] = '\s'; } $split = '#(' . implode('|', $d) . ')#'; $str = preg_split($split, $str, -1, PREG_SPLIT_DELIM_CAPTURE); } $i = 0; $term = array(); foreach ($str as $key => $val) { if ($key & 1) { if (isset($term[($i - 1)]) && ! is_array($term[($i - 1)])) { $term[($i - 1)] = array($term[($i - 1)], $val); } continue; } if (empty($term[$i])) { $term[$i] = $val; } else { $term[$i] .= $str[($key - 1)] . $val; } $c1 = substr_count($term[$i], $e1); $c2 = substr_count($term[$i], $e2); if (strpos($term[$i], '(') !== false) { if ($c1 == $c2) { $i++; } } else { if ( ! (substr_count($term[$i], "'") & 1) && ! (substr_count($term[$i], "\"") & 1)) { $i++; } } } if (isset($term[$i - 1])) { $term[$i - 1] = array($term[$i - 1], ''); } return $term; } } class Doctrine_Query_Orderby extends Doctrine_Query_Part { public function parse($str, $append = false) { $ret = array(); foreach (explode(',', trim($str)) as $r) { $r = $this->query->parseClause($r); $ret[] = $r; } return $ret; } } class Doctrine_Import extends Doctrine_Connection_Module { protected $sql = array(); public function listDatabases() { if ( ! isset($this->sql['listDatabases'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listDatabases']); } public function listFunctions() { if ( ! isset($this->sql['listFunctions'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listFunctions']); } public function listTriggers($database = null) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listSequences($database = null) { if ( ! isset($this->sql['listSequences'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listSequences']); } public function listTableConstraints($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableRelations($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableColumns($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableIndexes($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTables($database = null) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableTriggers($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listTableViews($table) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } public function listUsers() { if ( ! isset($this->sql['listUsers'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listUsers']); } public function listViews($database = null) { if ( ! isset($this->sql['listViews'])) { throw new Doctrine_Import_Exception(__FUNCTION__ . ' not supported by this driver.'); } return $this->conn->fetchColumn($this->sql['listViews']); } public function databaseExists($database) { return in_array($database, $this->listDatabases()); } public function functionExists($function) { return in_array($function, $this->listFunctions()); } public function triggerExists($trigger, $database = null) { return in_array($trigger, $this->listTriggers($database)); } public function sequenceExists($sequence, $database = null) { return in_array($sequence, $this->listSequences($database)); } public function tableConstraintExists($constraint, $table) { return in_array($constraint, $this->listTableConstraints($table)); } public function tableColumnExists($column, $table) { return in_array($column, $this->listTableColumns($table)); } public function tableIndexExists($index, $table) { return in_array($index, $this->listTableIndexes($table)); } public function tableExists($table, $database = null) { return in_array($table, $this->listTables($database)); } public function tableTriggerExists($trigger, $table) { return in_array($trigger, $this->listTableTriggers($table)); } public function tableViewExists($view, $table) { return in_array($view, $this->listTableViews($table)); } public function userExists($user) { return in_array($user, $this->listUsers()); } public function viewExists($view, $database = null) { return in_array($view, $this->listViews($database)); } public function importSchema($directory, array $databases = array(), array $options = array()) { $connections = Doctrine_Manager::getInstance()->getConnections(); foreach ($connections as $name => $connection) { if ( ! empty($databases) && ! in_array($name, $databases)) { continue; } $builder = new Doctrine_Import_Builder(); $builder->setTargetPath($directory); $builder->setOptions($options); $definitions = array(); $classes = array(); foreach ($connection->import->listTables() as $table) { $definition = array(); $definition['tableName'] = $table; $classTable = Doctrine_Inflector::tableize($table); $definition['className'] = Doctrine_Inflector::classify($classTable); $definition['columns'] = $connection->import->listTableColumns($table); try { $definition['relations'] = array(); $relations = $connection->import->listTableRelations($table); $classes = array(); foreach ($relations as $relation) { $table = $relation['table']; $relClassTable = Doctrine_Inflector::tableize($table); $class = Doctrine_Inflector::classify($relClassTable); if (in_array($class, $classes)) { $alias = $class . '_' . (count($classes) + 1); } else { $alias = $class; } $classes[] = $class; $definition['relations'][$alias] = array('alias' => $alias, 'class' => $class, 'local' => $relation['local'], 'foreign' => $relation['foreign']); } } catch (Exception $e) {} $definitions[$definition['className']] = $definition; $classes[] = $definition['className']; } foreach ($definitions as $definition) { $builder->buildRecord($definition); } } return $classes; } }class Doctrine_Import_Builder extends Doctrine_Builder { protected $_path = ''; protected $_packagesPrefix = 'Package'; protected $_packagesPath = ''; protected $_packagesFolderName = 'packages'; protected $_suffix = '.php'; protected $_generateBaseClasses = true; protected $_generateTableClasses = false; protected $_baseClassPrefix = 'Base'; protected $_baseClassesDirectory = 'generated'; protected $_baseClassName = 'Doctrine_Record'; protected $_generateAccessors = false; protected static $_tpl; public function __construct() { $this->loadTemplate(); } public function setTargetPath($path) { if ($path) { if ( ! $this->_packagesPath) { $this->setPackagesPath($path . DIRECTORY_SEPARATOR . $this->_packagesFolderName); } $this->_path = $path; } } public function setPackagesPrefix($packagesPrefix) { $this->_packagesPrefix = $packagesPrefix; } public function setPackagesPath($packagesPath) { if ($packagesPath) { $this->_packagesPath = $packagesPath; } } public function generateBaseClasses($bool = null) { if ($bool !== null) { $this->_generateBaseClasses = $bool; } return $this->_generateBaseClasses; } public function generateTableClasses($bool = null) { if ($bool !== null) { $this->_generateTableClasses = $bool; } return $this->_generateTableClasses; } public function generateAccessors($bool = null) { if ($bool !== null) { $this->_generateAccessors = $bool; } return $this->_generateAccessors; } public function setBaseClassPrefix($prefix) { $this->_baseClassPrefix = $prefix; } public function getBaseClassPrefix() { return $this->_baseClassPrefix; } public function setBaseClassesDirectory($baseClassesDirectory) { $this->_baseClassesDirectory = $baseClassesDirectory; } public function setBaseClassName($className) { $this->_baseClassName = $className; } public function setSuffix($suffix) { $this->_suffix = $suffix; } public function getTargetPath() { return $this->_path; } public function setOptions($options) { if ( ! empty($options)) { foreach ($options as $key => $value) { $this->setOption($key, $value); } } } public function setOption($key, $value) { $name = 'set' . Doctrine_Inflector::classify($key); if (method_exists($this, $name)) { $this->$name($value); } else { $key = '_' . $key; $this->$key = $value; } } public function loadTemplate() { if (isset(self::$_tpl)) { return; } self::$_tpl = '/**' . PHP_EOL . ' * This class has been auto-generated by the Doctrine ORM Framework' . PHP_EOL . ' */' . PHP_EOL . '%sclass %s extends %s' . PHP_EOL . '{' . '%s' . PHP_EOL . '%s' . PHP_EOL . '}'; } public function buildTableDefinition(array $definition) { if (isset($definition['inheritance']['type']) && ($definition['inheritance']['type'] == 'simple' || $definition['inheritance']['type'] == 'column_aggregation')) { return; } $ret = array(); $i = 0; if (isset($definition['inheritance']['type']) && $definition['inheritance']['type'] == 'concrete') { $ret[$i] = "    parent::setTableDefinition();"; $i++; } if (isset($definition['tableName']) && !empty($definition['tableName'])) { $ret[$i] = "    ".'$this->setTableName(\''. $definition['tableName'].'\');'; $i++; } if (isset($definition['columns']) && is_array($definition['columns']) && !empty($definition['columns'])) { $ret[$i] = $this->buildColumns($definition['columns']); $i++; } if (isset($definition['indexes']) && is_array($definition['indexes']) && !empty($definition['indexes'])) { $ret[$i] = $this->buildIndexes($definition['indexes']); $i++; } if (isset($definition['attributes']) && is_array($definition['attributes']) && !empty($definition['attributes'])) { $ret[$i] = $this->buildAttributes($definition['attributes']); $i++; } if (isset($definition['options']) && is_array($definition['options']) && !empty($definition['options'])) { $ret[$i] = $this->buildOptions($definition['options']); $i++; } if (isset($definition['checks']) && is_array($definition['checks']) && !empty($definition['checks'])) { $ret[$i] = $this->buildChecks($definition['checks']); $i++; } if (isset($definition['inheritance']['subclasses']) && ! empty($definition['inheritance']['subclasses'])) { $ret[$i] = "    ".'$this->setSubClasses('. $this->varExport($definition['inheritance']['subclasses']).');'; $i++; } $code = implode(PHP_EOL, $ret); $code = trim($code); return PHP_EOL . "  public function setTableDefinition()" . PHP_EOL . '  {' . PHP_EOL . '    ' . $code . PHP_EOL . '  }'; } public function buildSetUp(array $definition) { $ret = array(); $i = 0; if (isset($definition['relations']) && is_array($definition['relations']) && ! empty($definition['relations'])) { foreach ($definition['relations'] as $name => $relation) { $class = isset($relation['class']) ? $relation['class']:$name; $alias = (isset($relation['alias']) && $relation['alias'] !== $relation['class']) ? ' as ' . $relation['alias'] : ''; if ( ! isset($relation['type'])) { $relation['type'] = Doctrine_Relation::ONE; } if ($relation['type'] === Doctrine_Relation::ONE) { $ret[$i] = "    ".'$this->hasOne(\'' . $class . $alias . '\''; } else { $ret[$i] = "    ".'$this->hasMany(\'' . $class . $alias . '\''; } $a = array(); if (isset($relation['refClass'])) { $a[] = '\'refClass\' => ' . $this->varExport($relation['refClass']); } if (isset($relation['refClassRelationAlias'])) { $a[] = '\'refClassRelationAlias\' => ' . $this->varExport($relation['refClassRelationAlias']); } if (isset($relation['deferred']) && $relation['deferred']) { $a[] = '\'default\' => ' . $this->varExport($relation['deferred']); } if (isset($relation['local']) && $relation['local']) { $a[] = '\'local\' => ' . $this->varExport($relation['local']); } if (isset($relation['foreign']) && $relation['foreign']) { $a[] = '\'foreign\' => ' . $this->varExport($relation['foreign']); } if (isset($relation['onDelete']) && $relation['onDelete']) { $a[] = '\'onDelete\' => ' . $this->varExport($relation['onDelete']); } if (isset($relation['onUpdate']) && $relation['onUpdate']) { $a[] = '\'onUpdate\' => ' . $this->varExport($relation['onUpdate']); } if (isset($relation['cascade']) && $relation['cascade']) { $a[] = '\'cascade\' => ' . $this->varExport($relation['cascade']); } if (isset($relation['equal']) && $relation['equal']) { $a[] = '\'equal\' => ' . $this->varExport($relation['equal']); } if (isset($relation['owningSide']) && $relation['owningSide']) { $a[] = '\'owningSide\' => ' . $this->varExport($relation['owningSide']); } if ( ! empty($a)) { $ret[$i] .= ', ' . 'array('; $length = strlen($ret[$i]); $ret[$i] .= implode(',' . PHP_EOL . str_repeat(' ', $length), $a) . ')'; } $ret[$i] .= ');'.PHP_EOL; $i++; } } if (isset($definition['actAs']) && is_array($definition['actAs']) && !empty($definition['actAs'])) { $ret[$i] = $this->buildActAs($definition['actAs']); $i++; } if (isset($definition['listeners']) && is_array($definition['listeners']) && !empty($definition['listeners'])) { $ret[$i] = $this->buildListeners($definition['listeners']); $i++; } $code = implode(PHP_EOL, $ret); $code = trim($code); if ($code) { if ($code && isset($definition['inheritance']['type']) && $definition['inheritance']['type'] != 'class_table') { $code = "parent::setUp();" . PHP_EOL . '    ' . $code; } } if ($code) { return '  public function setUp()' . PHP_EOL . '  {' . PHP_EOL . '    ' . $code . PHP_EOL . '  }'; } } public function buildChecks($checks) { $build = ''; foreach ($checks as $check) { $build .= "    \$this->check('" . $check . "');" . PHP_EOL; } return $build; } public function buildColumns(array $columns) { $build = null; foreach ($columns as $name => $column) { $columnName = isset($column['name']) ? $column['name']:$name; $build .= "    ".'$this->hasColumn(\'' . $columnName . '\', \'' . $column['type'] . '\''; if ($column['length']) { $build .= ', ' . $column['length']; } else { $build .= ', null'; } $options = $column; unset($options['name']); unset($options['alltypes']); unset($options['ntype']); if (isset($options['primary']) && $options['primary'] == true && (isset($options['notnull']) && $options['notnull'] == true)) { unset($options['notnull']); } if (isset($options['primary']) && $options['primary'] == true && (isset($options['default']) && $options['default'] == 0)) { unset($options['default']); } $remove = array('fixed', 'primary', 'notnull', 'autoincrement', 'unsigned'); foreach ($remove as $key) { if (isset($options[$key]) && empty($options[$key])) { unset($options[$key]); } } foreach ($options as $key => $value) { if (is_null($value) || (is_array($value) && empty($value))) { unset($options[$key]); } } if (is_array($options) && !empty($options)) { $build .= ', ' . $this->varExport($options); } $build .= ');' . PHP_EOL; } return $build; } public function buildAccessors(array $definition) { $accessors = array(); foreach (array_keys($definition['columns']) as $name) { $accessors[] = $name; } foreach ($definition['relations'] as $relation) { $accessors[] = $relation['alias']; } $ret = ''; foreach ($accessors as $name) { $ret .= PHP_EOL . '  public function get' . Doctrine_Inflector::classify(Doctrine_Inflector::tableize($name)) . "(\$load = true)" . PHP_EOL; $ret .= "  {" . PHP_EOL; $ret .= "    return \$this->get('{$name}', \$load);" . PHP_EOL; $ret .= "  }" . PHP_EOL; $ret .= PHP_EOL . '  public function set' . Doctrine_Inflector::classify(Doctrine_Inflector::tableize($name)) . "(\${$name}, \$load = true)" . PHP_EOL; $ret .= "  {" . PHP_EOL; $ret .= "    return \$this->set('{$name}', \${$name}, \$load);" . PHP_EOL; $ret .= "  }" . PHP_EOL; } return $ret; } private function emitAssign($level, $name, $option) { $classname = $name; if (class_exists("Doctrine_Template_$name", true)) { $classname = "Doctrine_Template_$name"; } return "    \$" . strtolower($name) . "$level = new $classname($option);". PHP_EOL; } private function emitAddChild($level, $parent, $name) { return "    \$" . strtolower($parent) . ($level - 1) . "->addChild(\$" . strtolower($name) . "$level);" . PHP_EOL; } private function emitActAs($level, $name) { return "    \$this->actAs(\$" . strtolower($name) . "$level);" . PHP_EOL; } public function buildActAs($actAs) { $emittedActAs = array(); $build = $this->innerBuildActAs($actAs, 0, null, $emittedActAs); foreach($emittedActAs as $str) { $build .= $str; } return $build; } private function innerBuildActAs($actAs, $level = 0, $parent = null, array &$emittedActAs) { if(is_array($actAs) && isset($actAs[0]) && !is_array($actAs[0])) { $actAs = array_flip($actAs); } $build = ''; $currentParent = $parent; if(is_array($actAs)) { foreach($actAs as $template => $options) { if ($template == 'actAs') { $build .= $this->innerBuildActAs($options, $level + 1, $parent, $emittedActAs); } else if (is_array($options)) { $realOptions = array(); $leftActAs = array(); foreach($options as $name => $value) { if ($name != 'actAs') { $realOptions[$name] = $options[$name]; } else { $leftActAs[$name] = $options[$name]; } } $optionPHP = $this->varExport($realOptions); $build .= $this->emitAssign($level, $template, $optionPHP); if ($level == 0) { $emittedActAs[] = $this->emitActAs($level, $template); } else { $build .= $this->emitAddChild($level, $currentParent, $template); } $parent = $template; $build .= $this->innerBuildActAs($leftActAs, $level, $template, $emittedActAs); } else { $build .= $this->emitAssign($level, $template, null); if ($level == 0) { $emittedActAs[] = $this->emitActAs($level, $template); } else { $build .= $this->emitAddChild($level, $currentParent, $template); } $parent = $template; } } } else { $build .= $this->emitAssign($level, $actAs, null); if ($level == 0) { $emittedActAs[] = $this->emitActAs($level, $actAs); } else { $build .= $this->emitAddChild($level, $currentParent, $actAs); } } return $build; } public function buildListeners($listeners) { $build = ''; foreach($listeners as $listener) { $build .= "    \$this->addListener(new " . $listener . "());" . PHP_EOL; } return $build; } public function buildAttributes(array $attributes) { $build = PHP_EOL; foreach ($attributes as $key => $value) { $values = array(); if (is_bool($value)) { $values[] = $value ? 'true':'false'; } else { if ( ! is_array($value)) { $value = array($value); } foreach ($value as $attr) { $const = "Doctrine::" . strtoupper($key) . "_" . strtoupper($attr); if (defined($const)) { $values[] = $const; } else { $values[] = "'" . $attr . "'"; } } } $string = implode(' ^ ', $values); $build .= "    \$this->setAttribute(Doctrine::ATTR_" . strtoupper($key) . ", " . $string . ");" . PHP_EOL; } return $build; } public function buildOptions(array $options) { $build = ''; foreach ($options as $name => $value) { $build .= "    \$this->option('$name', " . $this->varExport($value) . ");" . PHP_EOL; } return $build; } public function buildIndexes(array $indexes) { $build = ''; foreach ($indexes as $indexName => $definitions) { $build .= PHP_EOL . "    \$this->index('" . $indexName . "'"; $build .= ', ' . $this->varExport($definitions); $build .= ');'; } return $build; } public function buildDefinition(array $definition) { if ( ! isset($definition['className'])) { throw new Doctrine_Import_Builder_Exception('Missing class name.'); } $abstract = isset($definition['abstract']) && $definition['abstract'] === true ? 'abstract ':null; $className = $definition['className']; $extends = isset($definition['inheritance']['extends']) ? $definition['inheritance']['extends']:$this->_baseClassName; if ( ! (isset($definition['no_definition']) && $definition['no_definition'] === true)) { $tableDefinitionCode = $this->buildTableDefinition($definition); $setUpCode = $this->buildSetUp($definition); } else { $tableDefinitionCode = null; $setUpCode = null; } if ($tableDefinitionCode && $setUpCode) { $setUpCode = PHP_EOL . $setUpCode; } $content = sprintf(self::$_tpl, $abstract, $className, $extends, $tableDefinitionCode, $setUpCode); return $content; } public function buildRecord(array $definition) { if ( ! isset($definition['className'])) { throw new Doctrine_Import_Builder_Exception('Missing class name.'); } $definition['topLevelClassName'] = $definition['className']; if ($this->generateBaseClasses()) { $definition['is_package'] = (isset($definition['package']) && $definition['package']) ? true:false; if ($definition['is_package']) { $e = explode('.', trim($definition['package'])); $definition['package_name'] = $e[0]; $definition['package_path'] = ! empty($e) ? implode(DIRECTORY_SEPARATOR, $e):$definition['package_name']; } $topLevel = $definition; unset($topLevel['tableName']); $topLevel['inheritance']['extends'] = (isset($topLevel['package']) && $topLevel['package']) ? $this->_packagesPrefix . $topLevel['className']:$this->_baseClassPrefix . $topLevel['className']; $topLevel['no_definition'] = true; $topLevel['generate_once'] = true; $topLevel['is_main_class'] = true; unset($topLevel['connection']); if (isset($definition['package'])) { $packageLevel = $definition; $packageLevel['className'] = $topLevel['inheritance']['extends']; $packageLevel['inheritance']['extends'] = $this->_baseClassPrefix . $topLevel['className']; $packageLevel['no_definition'] = true; $packageLevel['abstract'] = true; $packageLevel['override_parent'] = true; $packageLevel['generate_once'] = true; $packageLevel['is_package_class'] = true; unset($packageLevel['connection']); $packageLevel['tableClassName'] = $packageLevel['className'] . 'Table'; $packageLevel['inheritance']['tableExtends'] = isset($definition['inheritance']['extends']) ? $definition['inheritance']['extends'] . 'Table':'Doctrine_Table'; $topLevel['tableClassName'] = $topLevel['topLevelClassName'] . 'Table'; $topLevel['inheritance']['tableExtends'] = $packageLevel['className'] . 'Table'; } else { $topLevel['tableClassName'] = $topLevel['className'] . 'Table'; $topLevel['inheritance']['tableExtends'] = isset($definition['inheritance']['extends']) ? $definition['inheritance']['extends'] . 'Table':'Doctrine_Table'; } $baseClass = $definition; $baseClass['className'] = $this->_baseClassPrefix . $baseClass['className']; $baseClass['abstract'] = true; $baseClass['override_parent'] = false; $baseClass['is_base_class'] = true; $this->writeDefinition($baseClass); if ( ! empty($packageLevel)) { $this->writeDefinition($packageLevel); } $this->writeDefinition($topLevel); } else { $this->writeDefinition($definition); } } public function writeTableDefinition($className, $path, $options = array()) { $content = '<?php' . PHP_EOL; $content .= sprintf(self::$_tpl, false, $className, isset($options['extends']) ? $options['extends']:'Doctrine_Table', null, null, null ); Doctrine_Lib::makeDirectories($path); $writePath = $path . DIRECTORY_SEPARATOR . $className . $this->_suffix; Doctrine::loadModel($className, $writePath); if ( ! file_exists($writePath)) { file_put_contents($writePath, $content); } } public function writeDefinition(array $definition) { $definitionCode = $this->buildDefinition($definition); $fileName = $definition['className'] . $this->_suffix; $packagesPath = $this->_packagesPath ? $this->_packagesPath:$this->_path; if (isset($definition['is_main_class']) && $definition['is_main_class']) { if (isset($definition['is_package']) && $definition['is_package']) { $writePath = $this->_path . DIRECTORY_SEPARATOR . $definition['package_name']; } else { $writePath = $this->_path; } if ($this->generateTableClasses()) { $this->writeTableDefinition($definition['tableClassName'], $writePath, array('extends' => $definition['inheritance']['tableExtends'])); } } else if (isset($definition['is_package_class']) && $definition['is_package_class']) { $writePath = $packagesPath . DIRECTORY_SEPARATOR . $definition['package_path']; if ($this->generateTableClasses()) { $this->writeTableDefinition($definition['tableClassName'], $writePath, array('extends' => $definition['inheritance']['tableExtends'])); } } else if (isset($definition['is_base_class']) && $definition['is_base_class']) { if (isset($definition['is_package']) && $definition['is_package']) { $basePath = $this->_path . DIRECTORY_SEPARATOR . $definition['package_name']; $writePath = $basePath . DIRECTORY_SEPARATOR . $this->_baseClassesDirectory; } else { $writePath = $this->_path . DIRECTORY_SEPARATOR . $this->_baseClassesDirectory; } } if (isset($writePath)) { Doctrine_Lib::makeDirectories($writePath); $writePath .= DIRECTORY_SEPARATOR . $fileName; } else { Doctrine_Lib::makeDirectories($this->_path); $writePath = $this->_path . DIRECTORY_SEPARATOR . $fileName; } $code = "<?php" . PHP_EOL; if (isset($definition['connection']) && $definition['connection']) { $code .= "// Connection Component Binding" . PHP_EOL; $code .= "Doctrine_Manager::getInstance()->bindComponent('" . $definition['connectionClassName'] . "', '" . $definition['connection'] . "');" . PHP_EOL; } $code .= PHP_EOL . $definitionCode; if (isset($definition['generate_once']) && $definition['generate_once'] === true) { if ( ! file_exists($writePath)) { $bytes = file_put_contents($writePath, $code); } } else { $bytes = file_put_contents($writePath, $code); } if (isset($bytes) && $bytes === false) { throw new Doctrine_Import_Builder_Exception("Couldn't write file " . $writePath); } Doctrine::loadModel($definition['className'], $writePath); } }abstract class Doctrine_Import_Reader { abstract public function read( ); }class Doctrine_Import_Reader_Db extends Doctrine_Import_Reader { private $pdo; public function setPdo( $pdo ) { } public function read() { $dataDict = Doctrine_Manager::getInstance()->getCurrentConnection()->getDataDict(); $schema = new Doctrine_Schema(); $db = new Doctrine_Schema_Database(); $schema->addDatabase($db); $dbName = 'XXtest'; $this->conn->set("name",$dbName); $tableNames = $dataDict->listTables(); foreach ($tableNames as $tableName) { $table = new Doctrine_Schema_Table(); $table->set("name",$tableName); $tableColumns = $dataDict->listTableColumns($tableName); foreach ($tableColumns as $tableColumn) { $table->addColumn($tableColumn); } $this->conn->addTable($table); if ($fks = $dataDict->listTableConstraints($tableName)) { foreach ($fks as $fk) { $relation = new Doctrine_Schema_Relation(); $relation->setRelationBetween($fk['referencingColumn'],$fk['referencedTable'],$fk['referencedColumn']); $table->setRelation($relation); } } } return $schema; } }class Doctrine_Import_Reader_Xml_Propel extends Doctrine_Import_Reader { private $xml; public function setXml( $xml ) { } public function read() { } }class Doctrine_Import_Reader_Exception { }class Doctrine_Import_Exception extends Doctrine_Exception { }class Doctrine_Import_Builder_Exception extends Doctrine_Import_Exception { }class Doctrine_Import_Builder_BaseClass extends Doctrine_Import_Builder { }class Doctrine_Import_Pgsql extends Doctrine_Import { protected $sql = array( 'listDatabases' => 'SELECT datname FROM pg_database', 'listFunctions' => "SELECT
                                                proname
                                            FROM
                                                pg_proc pr,
                                                pg_type tp
                                            WHERE
                                                tp.oid = pr.prorettype
                                                AND pr.proisagg = FALSE
                                                AND tp.typname <> 'trigger'
                                                AND pr.pronamespace IN
                                                    (SELECT oid FROM pg_namespace
                                                     WHERE nspname NOT LIKE 'pg_%' AND nspname != 'information_schema'", 'listSequences' => "SELECT
                                                relname
                                            FROM
                                                pg_class
                                            WHERE relkind = 'S' AND relnamespace IN
                                                (SELECT oid FROM pg_namespace
                                                 WHERE nspname NOT LIKE 'pg_%' AND nspname != 'information_schema')", 'listTables' => "SELECT
                                                c.relname AS table_name
                                            FROM pg_class c, pg_user u
                                            WHERE c.relowner = u.usesysid
                                                AND c.relkind = 'r'
                                                AND NOT EXISTS (SELECT 1 FROM pg_views WHERE viewname = c.relname)
                                                AND c.relname !~ '^(pg_|sql_)'
                                            UNION
                                            SELECT c.relname AS table_name
                                            FROM pg_class c
                                            WHERE c.relkind = 'r'
                                                AND NOT EXISTS (SELECT 1 FROM pg_views WHERE viewname = c.relname)
                                                AND NOT EXISTS (SELECT 1 FROM pg_user WHERE usesysid = c.relowner)
                                                AND c.relname !~ '^pg_'", 'listViews' => 'SELECT viewname FROM pg_views', 'listUsers' => 'SELECT usename FROM pg_user', 'listTableConstraints' => "SELECT
                                                        relname
                                                   FROM
                                                        pg_class
                                                   WHERE oid IN (
                                                        SELECT indexrelid
                                                        FROM pg_index, pg_class
                                                        WHERE pg_class.relname = %s
                                                            AND pg_class.oid = pg_index.indrelid
                                                            AND (indisunique = 't' OR indisprimary = 't')
                                                        )", 'listTableIndexes' => "SELECT
                                                        relname
                                                   FROM
                                                        pg_class
                                                   WHERE oid IN (
                                                        SELECT indexrelid
                                                        FROM pg_index, pg_class
                                                        WHERE pg_class.relname = %s
                                                            AND pg_class.oid=pg_index.indrelid
                                                            AND indisunique != 't'
                                                            AND indisprimary != 't'
                                                        )", 'listTableColumns' => "SELECT
                                                        a.attnum,
                                                        a.attname AS field,
                                                        t.typname AS type,
                                                        format_type(a.atttypid, a.atttypmod) AS complete_type,
                                                        a.attnotnull AS isnotnull,
                                                        (SELECT 't'
                                                          FROM pg_index
                                                          WHERE c.oid = pg_index.indrelid
                                                          AND pg_index.indkey[0] = a.attnum
                                                          AND pg_index.indisprimary = 't'
                                                        ) AS pri,
                                                        (SELECT pg_attrdef.adsrc
                                                          FROM pg_attrdef
                                                          WHERE c.oid = pg_attrdef.adrelid
                                                          AND pg_attrdef.adnum=a.attnum
                                                        ) AS default
                                                  FROM pg_attribute a, pg_class c, pg_type t
                                                  WHERE c.relname = %s
                                                        AND a.attnum > 0
                                                        AND a.attrelid = c.oid
                                                        AND a.atttypid = t.oid
                                                  ORDER BY a.attnum", ); public function listTriggers($database = null) { } public function listTableConstraints($table) { $table = $this->conn->quote($table); $query = sprintf($this->sql['listTableConstraints'], $table); return $this->conn->fetchColumn($query); } public function listTableColumns($table) { $table = $this->conn->quote($table); $query = sprintf($this->sql['listTableColumns'], $table); $result = $this->conn->fetchAssoc($query); $columns = array(); foreach ($result as $key => $val) { $val = array_change_key_case($val, CASE_LOWER); if (strtolower($val['type']) === 'varchar') { $length = preg_replace('~.*\(([0-9]*)\).*~', '$1', $val['complete_type']); $val['length'] = $length; } $decl = $this->conn->dataDict->getPortableDeclaration($val); $description = array( 'name' => $val['field'], 'ntype' => $val['type'], 'type' => $decl['type'][0], 'alltypes' => $decl['type'], 'length' => $decl['length'], 'fixed' => $decl['fixed'], 'unsigned' => $decl['unsigned'], 'notnull' => ($val['isnotnull'] == true), 'default' => $val['default'], 'primary' => ($val['pri'] == 't'), ); $matches = array(); if (preg_match("/^nextval\('(.*)'(::.*)?\)$/", $description['default'], $matches)) { $description['sequence'] = $this->conn->formatter->fixSequenceName($matches[1]); $description['default'] = null; } $columns[$val['field']] = $description; } return $columns; } public function listTableIndexes($table) { $table = $this->conn->quote($table); $query = sprintf($this->sql['listTableIndexes'], $table); return $this->conn->fetchColumn($query); } public function listTables($database = null) { return $this->conn->fetchColumn($this->sql['listTables']); } public function listTableTriggers($table) { $query = 'SELECT trg.tgname AS trigger_name
                    FROM pg_trigger trg,
                         pg_class tbl
                   WHERE trg.tgrelid = tbl.oid'; if ($table !== null) { $table = $this->conn->quote(strtoupper($table), 'string'); $query .= " AND tbl.relname = $table"; } return $this->conn->fetchColumn($query); } public function listTableViews($table) { return $this->conn->fetchColumn($table); } }class Doctrine_Import_Schema { protected $_relations = array(); protected $_options = array('packagesPrefix' => 'Package', 'packagesPath' => '', 'packagesFolderName' => 'packages', 'suffix' => '.php', 'generateBaseClasses' => true, 'generateTableClasses' => false, 'generateAccessors' => false, 'baseClassesPrefix' => 'Base', 'baseClassesDirectory' => 'generated', 'baseClassName' => 'Doctrine_Record'); protected $_validation = array('root' => array('abstract', 'connection', 'className', 'tableName', 'connection', 'relations', 'columns', 'indexes', 'attributes', 'templates', 'actAs', 'options', 'package', 'inheritance', 'detect_relations', 'listeners', 'checks'), 'column' => array('name', 'format', 'fixed', 'primary', 'autoincrement', 'type', 'length', 'size', 'default', 'scale', 'values', 'comment', 'sequence', 'protected', 'zerofill', 'owner', 'extra'), 'relation' => array('key', 'class', 'alias', 'type', 'refClass', 'local', 'foreign', 'foreignClass', 'foreignAlias', 'foreignType', 'autoComplete', 'cascade', 'onDelete', 'onUpdate', 'equal', 'owningSide', 'refClassRelationAlias'), 'inheritance'=> array('type', 'extends', 'keyField', 'keyValue')); protected $_validators = array(); public function getValidators() { if (empty($this->_validators)) { $this->_validators = Doctrine_Lib::getValidators(); } return $this->_validators; } public function getOption($name) { if (isset($this->_options[$name])) { return $this->_options[$name]; } } public function getOptions() { return $this->_options; } public function setOption($name, $value) { if (isset($this->_options[$name])) { $this->_options[$name] = $value; } } public function setOptions($options) { if ( ! empty($options)) { $this->_options = $options; } } public function buildSchema($schema, $format) { $array = array(); foreach ((array) $schema AS $s) { if (is_file($s)) { $array = array_merge($array, $this->parseSchema($s, $format)); } else if (is_dir($s)) { $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($s), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($it as $file) { $e = explode('.', $file->getFileName()); if (end($e) === $format) { $array = array_merge($array, $this->parseSchema($file->getPathName(), $format)); } } } else { $array = array_merge($array, $this->parseSchema($s, $format)); } } $array = $this->_buildRelationships($array); $array = $this->_processInheritance($array); return $array; } public function importSchema($schema, $format = 'yml', $directory = null, $models = array()) { $builder = new Doctrine_Import_Builder(); $builder->setTargetPath($directory); $builder->setOptions($this->getOptions()); $array = $this->buildSchema($schema, $format); foreach ($array as $name => $definition) { if ( ! empty($models) && !in_array($definition['className'], $models)) { continue; } $builder->buildRecord($definition); } } public function parseSchema($schema, $type) { $defaults = array('abstract' => false, 'className' => null, 'tableName' => null, 'connection' => null, 'relations' => array(), 'indexes' => array(), 'attributes' => array(), 'templates' => array(), 'actAs' => array(), 'options' => array(), 'package' => null, 'inheritance' => array(), 'detect_relations' => false); $array = Doctrine_Parser::load($schema, $type); $globals = array(); $globalKeys = array('connection', 'attributes', 'templates', 'actAs', 'options', 'package', 'inheritance', 'detect_relations'); foreach ($array as $key => $value) { if (in_array($key, $globalKeys)) { unset($array[$key]); $globals[$key] = $value; } } foreach ($array as $className => $table) { foreach ($globals as $key => $value) { if (!isset($array[$className][$key])) { $array[$className][$key] = $value; } } } $build = array(); foreach ($array as $className => $table) { $table = (array) $table; $this->_validateSchemaElement('root', array_keys($table), $className); $columns = array(); $className = isset($table['className']) ? (string) $table['className']:(string) $className; if (isset($table['inheritance']['keyField']) || isset($table['inheritance']['keyValue'])) { $table['inheritance']['type'] = 'column_aggregation'; } if (isset($table['tableName']) && $table['tableName']) { $tableName = $table['tableName']; } else { if (isset($table['inheritance']['type']) && ($table['inheritance']['type'] == 'column_aggregation')) { $tableName = null; } else { $tableName = Doctrine_Inflector::tableize($className); } } $connection = isset($table['connection']) ? $table['connection']:'current'; $columns = isset($table['columns']) ? $table['columns']:array(); if ( ! empty($columns)) { foreach ($columns as $columnName => $field) { if ( ! is_array($field)) { $original = $field; $field = array(); $field['type'] = $original; } $colDesc = array(); if (isset($field['name'])) { $colDesc['name'] = $field['name']; } else { $colDesc['name'] = $columnName; } $this->_validateSchemaElement('column', array_keys($field), $className . '->columns->' . $colDesc['name']); $e = explode('(', $field['type']); if (isset($e[0]) && isset($e[1])) { $colDesc['type'] = $e[0]; $value = substr($e[1], 0, strlen($e[1]) - 1); $e = explode(',', $value); $colDesc['length'] = $e[0]; if (isset($e[1]) && $e[1]) { $colDesc['scale'] = $e[1]; } } else { $colDesc['type'] = isset($field['type']) ? (string) $field['type']:null; $colDesc['length'] = isset($field['length']) ? (int) $field['length']:null; $colDesc['length'] = isset($field['size']) ? (int) $field['size']:$colDesc['length']; } $colDesc['fixed'] = isset($field['fixed']) ? (int) $field['fixed']:null; $colDesc['primary'] = isset($field['primary']) ? (bool) (isset($field['primary']) && $field['primary']):null; $colDesc['default'] = isset($field['default']) ? $field['default']:null; $colDesc['autoincrement'] = isset($field['autoincrement']) ? (bool) (isset($field['autoincrement']) && $field['autoincrement']):null; $colDesc['sequence'] = isset($field['sequence']) ? (string) $field['sequence']:null; $colDesc['values'] = isset($field['values']) ? (array) $field['values']:null; $validators = $this->getValidators(); foreach ($validators as $validator) { if (isset($field[$validator])) { $colDesc[$validator] = $field[$validator]; } } $columns[(string) $columnName] = $colDesc; } } foreach ($defaults as $key => $defaultValue) { if (isset($table[$key]) && ! isset($build[$className][$key])) { $build[$className][$key] = $table[$key]; } else { $build[$className][$key] = isset($build[$className][$key]) ? $build[$className][$key]:$defaultValue; } } $build[$className]['className'] = $className; $build[$className]['tableName'] = $tableName; $build[$className]['columns'] = $columns; $build[$className] = Doctrine_Lib::arrayDeepMerge($table, $build[$className]); $build[$className]['connectionClassName'] = $build[$className]['className']; } return $build; } protected function _processInheritance($array) { foreach ($array as $className => $definition) { if ( ! empty($array[$className]['inheritance'])) { $this->_validateSchemaElement('inheritance', array_keys($definition['inheritance']), $className . '->inheritance'); if ( ! isset($array[$className]['inheritance']['type'])) { $array[$className]['inheritance']['type'] = 'concrete'; } if ($array[$className]['inheritance']['type'] == 'column_aggregation') { if ( ! isset($array[$className]['inheritance']['keyField'])) { $array[$className]['inheritance']['keyField'] = 'type'; } if ( ! isset($array[$className]['inheritance']['keyValue'])) { $array[$className]['inheritance']['keyValue'] = $className; } if ( ! isset($array[$array[$className]['inheritance']['extends']]['columns'][$array[$className]['inheritance']['keyField']])) { $array[$definition['inheritance']['extends']]['columns'][$array[$className]['inheritance']['keyField']] = array('name' => $array[$className]['inheritance']['keyField'], 'type' => 'string', 'length' => 255); } } } } $moves = array('columns' => array(), 'indexes' => array(), 'attributes' => array(), 'options' => array(), 'checks' => array()); foreach ($array as $className => $definition) { if (isset($definition['inheritance']['extends']) && isset($definition['inheritance']['type']) && ($definition['inheritance']['type'] == 'simple' || $definition['inheritance']['type'] == 'column_aggregation')) { $parent = $this->_findBaseSuperClass($array, $definition['className']); foreach ($moves as $move => $resetValue) { if (isset($array[$parent][$move]) && isset($definition[$move])) { $array[$parent][$move] = Doctrine_Lib::arrayDeepMerge($array[$parent][$move], $definition[$move]); $array[$definition['className']][$move] = $resetValue; } } if ($definition['inheritance']['type'] == 'column_aggregation') { $array[$parent]['inheritance']['subclasses'][$definition['className']] = array($definition['inheritance']['keyField'] => $definition['inheritance']['keyValue']); } } } return $array; } protected function _findBaseSuperClass($array, $class) { if (isset($array[$class]['inheritance']['extends']) && isset($array[$class]['inheritance']['type']) && ($array[$class]['inheritance']['type'] == 'simple' || $array[$class]['inheritance']['type'] == 'column_aggregation')) { return $this->_findBaseSuperClass($array, $array[$class]['inheritance']['extends']); } else { return $class; } } protected function _buildRelationships($array) { foreach ($array as $className => $properties) { if (isset($properties['columns']) && ! empty($properties['columns']) && isset($properties['detect_relations']) && $properties['detect_relations']) { foreach ($properties['columns'] as $column) { if (strpos($column['name'], '_id')) { $columnClassName = Doctrine_Inflector::classify(str_replace('_id', '', $column['name'])); if (isset($array[$columnClassName]) && !isset($array[$className]['relations'][$columnClassName])) { $array[$className]['relations'][$columnClassName] = array(); $type = isset($array[$columnClassName]['columns']['id']['type']) ? $array[$columnClassName]['columns']['id']['type']:'integer'; $length = isset($array[$columnClassName]['columns']['id']['length']) ? $array[$columnClassName]['columns']['id']['length']:8; $array[$className]['columns'][$column['name']]['type'] = $type; $array[$className]['columns'][$column['name']]['length'] = $length; } } } } } foreach ($array as $name => $properties) { if ( ! isset($properties['relations'])) { continue; } $className = $properties['className']; $relations = $properties['relations']; foreach ($relations as $alias => $relation) { $class = isset($relation['class']) ? $relation['class']:$alias; if ( ! isset($array[$class])) { continue; } $relation['class'] = $class; $relation['alias'] = isset($relation['alias']) ? $relation['alias'] : $alias; if (isset($relation['refClass'])) { $relation['local'] = isset($relation['local']) ? $relation['local']:Doctrine_Inflector::tableize($name) . '_id'; $relation['foreign'] = isset($relation['foreign']) ? $relation['foreign']:Doctrine_Inflector::tableize($class) . '_id'; } else { $relation['local'] = isset($relation['local']) ? $relation['local']:Doctrine_Inflector::tableize($relation['class']) . '_id'; $relation['foreign'] = isset($relation['foreign']) ? $relation['foreign']:'id'; } if (isset($relation['refClass'])) { $relation['type'] = 'many'; } if (isset($relation['type']) && $relation['type']) { $relation['type'] = $relation['type'] === 'one' ? Doctrine_Relation::ONE:Doctrine_Relation::MANY; } else { $relation['type'] = Doctrine_Relation::ONE; } if (isset($relation['foreignType']) && $relation['foreignType']) { $relation['foreignType'] = $relation['foreignType'] === 'one' ? Doctrine_Relation::ONE:Doctrine_Relation::MANY; } $relation['key'] = $this->_buildUniqueRelationKey($relation); $this->_validateSchemaElement('relation', array_keys($relation), $className . '->relation->' . $relation['alias']); $this->_relations[$className][$alias] = $relation; } } $this->_autoCompleteOppositeRelations(); $this->_fixDuplicateRelations(); foreach ($this->_relations as $className => $relations) { $array[$className]['relations'] = $relations; } return $array; } protected function _autoCompleteOppositeRelations() { foreach($this->_relations as $className => $relations) { foreach ($relations AS $alias => $relation) { if ((isset($relation['equal']) && $relation['equal']) || (isset($relation['autoComplete']) && $relation['autoComplete'] === false)) { continue; } $newRelation = array(); $newRelation['foreign'] = $relation['local']; $newRelation['local'] = $relation['foreign']; $newRelation['class'] = isset($relation['foreignClass']) ? $relation['foreignClass']:$className; $newRelation['alias'] = isset($relation['foreignAlias']) ? $relation['foreignAlias']:$className; $newRelation['autogenerated'] = true; if (isset($relation['refClass'])) { $newRelation['refClass'] = $relation['refClass']; $newRelation['type'] = isset($relation['foreignType']) ? $relation['foreignType']:$relation['type']; } else { if(isset($relation['foreignType'])) { $newRelation['type'] = $relation['foreignType']; } else { $newRelation['type'] = $relation['type'] === Doctrine_Relation::ONE ? Doctrine_Relation::MANY:Doctrine_Relation::ONE; } } if ( ! isset($this->_relations[$relation['class']][$newRelation['alias']])) { $newRelation['key'] = $this->_buildUniqueRelationKey($newRelation); $this->_relations[$relation['class']][$newRelation['alias']] = $newRelation; } } } } protected function _fixDuplicateRelations() { foreach($this->_relations as $className => $relations) { $existingRelations = array(); $uniqueRelations = array(); foreach ($relations as $relation) { if ( ! in_array($relation['key'], $existingRelations)) { $existingRelations[] = $relation['key']; $uniqueRelations = array_merge($uniqueRelations, array($relation['alias'] => $relation)); } else { if ( ! isset($relation['autogenerated']) || $relation['autogenerated'] != true) { $uniqueRelations = array_merge($uniqueRelations, array($relation['alias'] => $relation)); } } } $this->_relations[$className] = $uniqueRelations; } } protected function _buildUniqueRelationKey($relation) { return md5($relation['local'].$relation['foreign'].$relation['class'].(isset($relation['refClass']) ? $relation['refClass']:null)); } protected function _validateSchemaElement($name, $element, $path) { $element = (array) $element; $validation = $this->_validation[$name]; if ($name == 'column') { $validators = $this->getValidators(); $validation = array_merge($validation, $validators); } $validation = array_flip($validation); foreach ($element as $key => $value) { if ( ! isset($validation[$value])) { throw new Doctrine_Import_Exception( sprintf('Invalid schema element named "' . $value . '" at path "' . $path . '"') ); } } } }class Doctrine_Table_Repository_Exception extends Doctrine_Exception { }class Doctrine_Table_Repository implements Countable, IteratorAggregate { private $table; private $registry = array(); public function __construct(Doctrine_Table $table) { $this->table = $table; } public function getTable() { return $this->table; } public function add(Doctrine_Record $record) { $oid = $record->getOID(); if (isset($this->registry[$oid])) { return false; } $this->registry[$oid] = $record; return true; } public function get($oid) { if ( ! isset($this->registry[$oid])) { throw new Doctrine_Table_Repository_Exception("Unknown object identifier"); } return $this->registry[$oid]; } public function count() { return count($this->registry); } public function evict($oid) { if ( ! isset($this->registry[$oid])) { return false; } unset($this->registry[$oid]); return true; } public function evictAll() { $evicted = 0; foreach ($this->registry as $oid=>$record) { if ($this->evict($oid)) { $evicted++; } } return $evicted; } public function getIterator() { return new ArrayIterator($this->registry); } public function contains($oid) { return isset($this->registry[$oid]); } public function loadAll() { $this->table->findAll(); } }class Doctrine_Table_Exception extends Doctrine_Exception { public function __construct($message = "Couldn't initialize table. One instance of this
                            table already exists. Always use Doctrine_Session::getTable(\$name)
                            to get on instance of a Doctrine_Table.") { parent::__construct($message); } }class Doctrine_Validator_Unique { public function validate($value) { $table = $this->invoker->getTable(); $pks = $table->getIdentifier(); if ( is_array($pks) ) { $pks = join(',', $pks); } $sql = 'SELECT ' . $pks . ' FROM ' . $table->getTableName() . ' WHERE ' . $this->field . ' = ?'; $values = array(); $values[] = $value; $state = $this->invoker->state(); if ( ! ($state == Doctrine_Record::STATE_TDIRTY || $state == Doctrine_Record::STATE_TCLEAN)) { foreach ((array) $table->getIdentifier() as $pk) { $sql .= " AND {$pk} != ?"; $values[] = $this->invoker->$pk; } } $stmt = $table->getConnection()->getDbh()->prepare($sql); $stmt->execute($values); return ( ! is_array($stmt->fetch())); } }class Doctrine_Validator_Past { public function validate($value) { if ($value === null) { return true; } $e = explode('-', $value); if (count($e) !== 3) { return false; } if (is_array($this->args) && isset($this->args['timezone'])) { switch (strtolower($this->args['timezone'])) { case 'gmt': $now = gmdate("U") - date("Z"); break; default: $now = getdate(); break; } } else { $now = getdate(); } if ($now['year'] < $e[0]) { return false; } else if ($now['year'] == $e[0]) { if ($now['mon'] < $e[1]) { return false; } else if ($now['mon'] == $e[1]) { return $now['mday'] > $e[2]; } else { return true; } } else { return true; } } }class Doctrine_Validator_Range { public function validate($value) { if (is_null($value)) { return true; } if (isset($this->args[0]) && $value < $this->args[0]) { return false; } if (isset($this->args[1]) && $value > $this->args[1]) { return false; } return true; } }class Doctrine_Validator_Ip { public function validate($value) { return (bool) ip2long(str_replace("\0", '', $value)); } }class Doctrine_Validator_Driver { protected $_args = array(); public function __get($arg) { if (isset($this->_args[$arg])) { return $this->_args[$arg]; } return null; } public function __isset($arg) { return isset($this->_args[$arg]); } public function __set($arg, $value) { $this->_args[$arg] = $value; return $this; } public function getArg($arg) { if ( ! isset($this->_args[$arg])) { throw new Doctrine_Validator_Exception('Unknown option ' . $arg); } return $this->_args[$arg]; } public function setArg($arg, $value) { $this->_args[$arg] = $value; return $this; } public function getArgs() { return $this->_args; } }class Doctrine_Validator_Notblank extends Doctrine_Validator_Driver { public function validate($value) { return (trim($value) !== '' && $value !== null); } }class Doctrine_Validator_Unsigned { public function validate($value) { if(is_null($value) || $value == '') { return true; } if (preg_match('/[^0-9\-\.]/', $value)) { return false; } if(strpos($value, '.') === false) { $number = (int) $value; } else { $number = (float) $value; } if ((string) $number == $value && $number >= 0) { return true; } return false; } }class Doctrine_Validator_ErrorStack extends Doctrine_Access implements Countable, IteratorAggregate { protected $_errors = array(); protected $_validators = array(); protected $_className; public function __construct($className) { $this->_className = $className; } public function add($invalidFieldName, $errorCode = 'general') { if (is_object($errorCode) && strpos(get_class($errorCode), 'Doctrine_Validator_') !== false) { $validator = $errorCode; $this->_validators[$invalidFieldName][] = $validator; $className = get_class($errorCode); $errorCode = strtolower(substr($className, strlen('Doctrine_Validator_'), strlen($className))); } $this->_errors[$invalidFieldName][] = $errorCode; } public function remove($fieldName) { if (isset($this->_errors[$fieldName])) { unset($this->_errors[$fieldName]); } } public function get($fieldName) { return isset($this->_errors[$fieldName]) ? $this->_errors[$fieldName] : null; } public function set($fieldName, $errorCode) { $this->add($fieldName, $errorCode); } public function contains($fieldName) { return array_key_exists($fieldName, $this->_errors); } public function clear() { $this->_errors = array(); } public function getIterator() { return new ArrayIterator($this->_errors); } public function toArray() { return $this->_errors; } public function count() { return count($this->_errors); } public function getClassname() { return $this->_className; } public function getValidators() { return $this->_validators; } }class Doctrine_Validator_Nospace extends Doctrine_Validator_Driver { public function validate($value) { return ($value === null || ! preg_match('/\s/', $value)); } } class Doctrine_Validator_Creditcard { public function validate($value) { $cardType = ""; $card_regexes = array( "/^4\d{12}(\d\d\d){0,1}$/" => 'visa', "/^5[12345]\d{14}$/" => 'mastercard', "/^3[47]\d{13}$/" => 'amex', "/^6011\d{12}$/" => 'discover', "/^30[012345]\d{11}$/" => 'diners', "/^3[68]\d{12}$/" => 'diners', ); foreach ($card_regexes as $regex => $type) { if (preg_match($regex, $value)) { $cardType = $type; break; } } if ( ! $cardType) { return false; } $revcode = strrev($value); $checksum = 0; for ($i = 0; $i < strlen($revcode); $i++) { $currentNum = intval($revcode[$i]); if ($i & 1) { $currentNum *= 2; } $checksum += $currentNum % 10; if ($currentNum > 9) { $checksum += 1; } } if ($checksum % 10 == 0) { return true; } else { return false; } } }class Doctrine_Validator_Regexp { public function validate($value) { if ( ! isset($this->args)) { return true; } if (is_array($this->args)) { foreach ($this->args as $regexp) { if ( ! preg_match($regexp, $value)) { return false; } } return true; } else { if (preg_match($this->args, $value)) { return true; } } return false; } }class Doctrine_Validator_Exception extends Doctrine_Exception implements Countable, IteratorAggregate { private $invalid = array(); public function __construct(array $invalid) { $this->invalid = $invalid; parent::__construct($this->generateMessage()); } public function getInvalidRecords() { return $this->invalid; } public function getIterator() { return new ArrayIterator($this->invalid); } public function count() { return count($this->invalid); } public function __toString() { return parent::__toString(); } private function generateMessage() { $message = ""; foreach ($this->invalid as $record) { $message .= "Validation error in class " . get_class($record) . " "; } return $message; } public function inspect($function) { foreach ($this->invalid as $record) { call_user_func($function, $record->getErrorStack()); } } }class Doctrine_Validator_Time { public function validate($value) { if ($value === null) { return true; } $e = explode(':', $value); if (count($e) !== 3) { return false; } if ( ! preg_match('/^ *\d{2}:\d{2}:\d{2}(.\d{6}\+\d{2})? *$/', $value)) { return false; } $hr = intval($e[0], 10); $min = intval($e[1], 10); $sec = intval($e[2], 10); return $hr >= 0 && $hr <= 23 && $min >= 0 && $min <= 59 && $sec >= 0 && $sec <= 59; } }class Doctrine_Validator_Future { public function validate($value) { if ($value === null) { return true; } $e = explode('-', $value); if (count($e) !== 3) { return false; } if (is_array($this->args) && isset($this->args['timezone'])) { switch (strtolower($this->args['timezone'])) { case 'gmt': $now = gmdate("U") - date("Z"); break; default: $now = getdate(); break; } } else { $now = getdate(); } if ($now['year'] > $e[0]) { return false; } else if ($now['year'] == $e[0]) { if ($now['mon'] > $e[1]) { return false; } else if ($now['mon'] == $e[1]) { return $now['mday'] < $e[2]; } else { return true; } } else { return true; } } }class Doctrine_Validator_Notnull extends Doctrine_Validator_Driver { public function validate($value) { return ($value !== null); } }class Doctrine_Validator_Readonly { public function validate($value) { $modified = $this->invoker->getModified(); return array_key_exists($this->field, $modified) ? false : true; } } class Doctrine_Validator_HtmlColor { public function validate($value) { if ( ! preg_match("/^#{0,1}[0-9a-fA-F]{6}$/", $value)) { return false; } return true; } }class Doctrine_Validator_Date { public function validate($value) { if ($value === null) { return true; } $e = explode('-', $value); if (count($e) !== 3) { return false; } return checkdate($e[1], $e[2], $e[0]); } }class Doctrine_Validator_Timestamp { public function validate($value) { if ($value === null) { return true; } if ( ! preg_match('/^ *\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(.\d{6}\+\d{2})? *$/', $value)) { return false; } list($date, $time) = explode(' ', trim($value)); $dateValidator = Doctrine_Validator::getValidator('date'); $timeValidator = Doctrine_Validator::getValidator('time'); if ( ! $dateValidator->validate($date)) { return false; } if ( ! $timeValidator->validate($time)) { return false; } return true; } }class Doctrine_Validator_Minlength { public function validate($value) { if (isset($this->args) && strlen($value) < $this->args) { return false; } return true; } }class Doctrine_Validator_Usstate { private static $states = array( 'AK' => true, 'AL' => true, 'AR' => true, 'AZ' => true, 'CA' => true, 'CO' => true, 'CT' => true, 'DC' => true, 'DE' => true, 'FL' => true, 'GA' => true, 'HI' => true, 'IA' => true, 'ID' => true, 'IL' => true, 'IN' => true, 'KS' => true, 'KY' => true, 'LA' => true, 'MA' => true, 'MD' => true, 'ME' => true, 'MI' => true, 'MN' => true, 'MO' => true, 'MS' => true, 'MT' => true, 'NC' => true, 'ND' => true, 'NE' => true, 'NH' => true, 'NJ' => true, 'NM' => true, 'NV' => true, 'NY' => true, 'OH' => true, 'OK' => true, 'OR' => true, 'PA' => true, 'PR' => true, 'RI' => true, 'SC' => true, 'SD' => true, 'TN' => true, 'TX' => true, 'UT' => true, 'VA' => true, 'VI' => true, 'VT' => true, 'WA' => true, 'WI' => true, 'WV' => true, 'WY' => true ); public function getStates() { return self::$states; } public function validate($value) { return isset(self::$states[$value]); } }class Doctrine_Validator_Email { public function validate($value) { if ($value === null) { return true; } if (isset($this->args)) { $parts = explode('@', $value); if (isset($parts[1]) && function_exists('checkdnsrr')) { if ( ! checkdnsrr($parts[1], 'MX')) { return false; } } } $qtext = '[^\\x0d\\x22\\x5c\\x80-\\xff]'; $dtext = '[^\\x0d\\x5b-\\x5d\\x80-\\xff]'; $atom = '[^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+'; $quotedPair = '\\x5c[\\x00-\\x7f]'; $domainLiteral = "\\x5b($dtext|$quotedPair)*\\x5d"; $quotedString = "\\x22($qtext|$quotedPair)*\\x22"; $domain_ref = $atom; $subDomain = "($domain_ref|$domainLiteral)"; $word = "($atom|$quotedString)"; $domain = "$subDomain(\\x2e$subDomain)+"; $localPart = "$word(\\x2e$word)*"; $addrSpec = "$localPart\\x40$domain"; return (bool) preg_match("!^$addrSpec$!D", $value); } }class Doctrine_Validator_Country { private static $countries = array( 'ad' => 'Andorra', 'ae' => 'United Arab Emirates', 'af' => 'Afghanistan', 'ag' => 'Antigua and Barbuda', 'ai' => 'Anguilla', 'al' => 'Albania', 'am' => 'Armenia', 'an' => 'Netherlands Antilles', 'ao' => 'Angola', 'aq' => 'Antarctica', 'ar' => 'Argentina', 'as' => 'American Samoa', 'at' => 'Austria', 'au' => 'Australia', 'aw' => 'Aruba', 'az' => 'Azerbaijan', 'ba' => 'Bosnia Hercegovina', 'bb' => 'Barbados', 'bd' => 'Bangladesh', 'be' => 'Belgium', 'bf' => 'Burkina Faso', 'bg' => 'Bulgaria', 'bh' => 'Bahrain', 'bi' => 'Burundi', 'bj' => 'Benin', 'bm' => 'Bermuda', 'bn' => 'Brunei Darussalam', 'bo' => 'Bolivia', 'br' => 'Brazil', 'bs' => 'Bahamas', 'bt' => 'Bhutan', 'bv' => 'Bouvet Island', 'bw' => 'Botswana', 'by' => 'Belarus (Byelorussia)', 'bz' => 'Belize', 'ca' => 'Canada', 'cc' => 'Cocos Islands', 'cd' => 'Congo, The Democratic Republic of the', 'cf' => 'Central African Republic', 'cg' => 'Congo', 'ch' => 'Switzerland', 'ci' => 'Ivory Coast', 'ck' => 'Cook Islands', 'cl' => 'Chile', 'cm' => 'Cameroon', 'cn' => 'China', 'co' => 'Colombia', 'cr' => 'Costa Rica', 'cs' => 'Czechoslovakia', 'cu' => 'Cuba', 'cv' => 'Cape Verde', 'cx' => 'Christmas Island', 'cy' => 'Cyprus', 'cz' => 'Czech Republic', 'de' => 'Germany', 'dj' => 'Djibouti', 'dk' => 'Denmark', 'dm' => 'Dominica', 'do' => 'Dominican Republic', 'dz' => 'Algeria', 'ec' => 'Ecuador', 'ee' => 'Estonia', 'eg' => 'Egypt', 'eh' => 'Western Sahara', 'er' => 'Eritrea', 'es' => 'Spain', 'et' => 'Ethiopia', 'fi' => 'Finland', 'fj' => 'Fiji', 'fk' => 'Falkland Islands', 'fm' => 'Micronesia', 'fo' => 'Faroe Islands', 'fr' => 'France', 'fx' => 'France, Metropolitan FX', 'ga' => 'Gabon', 'gb' => 'United Kingdom (Great Britain)', 'gd' => 'Grenada', 'ge' => 'Georgia', 'gf' => 'French Guiana', 'gh' => 'Ghana', 'gi' => 'Gibraltar', 'gl' => 'Greenland', 'gm' => 'Gambia', 'gn' => 'Guinea', 'gp' => 'Guadeloupe', 'gq' => 'Equatorial Guinea', 'gr' => 'Greece', 'gs' => 'South Georgia and the South Sandwich Islands', 'gt' => 'Guatemala', 'gu' => 'Guam', 'gw' => 'Guinea-bissau', 'gy' => 'Guyana', 'hk' => 'Hong Kong', 'hm' => 'Heard and McDonald Islands', 'hn' => 'Honduras', 'hr' => 'Croatia', 'ht' => 'Haiti', 'hu' => 'Hungary', 'id' => 'Indonesia', 'ie' => 'Ireland', 'il' => 'Israel', 'in' => 'India', 'io' => 'British Indian Ocean Territory', 'iq' => 'Iraq', 'ir' => 'Iran', 'is' => 'Iceland', 'it' => 'Italy', 'jm' => 'Jamaica', 'jo' => 'Jordan', 'jp' => 'Japan', 'ke' => 'Kenya', 'kg' => 'Kyrgyzstan', 'kh' => 'Cambodia', 'ki' => 'Kiribati', 'km' => 'Comoros', 'kn' => 'Saint Kitts and Nevis', 'kp' => 'North Korea', 'kr' => 'South Korea', 'kw' => 'Kuwait', 'ky' => 'Cayman Islands', 'kz' => 'Kazakhstan', 'la' => 'Laos', 'lb' => 'Lebanon', 'lc' => 'Saint Lucia', 'li' => 'Lichtenstein', 'lk' => 'Sri Lanka', 'lr' => 'Liberia', 'ls' => 'Lesotho', 'lt' => 'Lithuania', 'lu' => 'Luxembourg', 'lv' => 'Latvia', 'ly' => 'Libya', 'ma' => 'Morocco', 'mc' => 'Monaco', 'md' => 'Moldova Republic', 'mg' => 'Madagascar', 'mh' => 'Marshall Islands', 'mk' => 'Macedonia, The Former Yugoslav Republic of', 'ml' => 'Mali', 'mm' => 'Myanmar', 'mn' => 'Mongolia', 'mo' => 'Macau', 'mp' => 'Northern Mariana Islands', 'mq' => 'Martinique', 'mr' => 'Mauritania', 'ms' => 'Montserrat', 'mt' => 'Malta', 'mu' => 'Mauritius', 'mv' => 'Maldives', 'mw' => 'Malawi', 'mx' => 'Mexico', 'my' => 'Malaysia', 'mz' => 'Mozambique', 'na' => 'Namibia', 'nc' => 'New Caledonia', 'ne' => 'Niger', 'nf' => 'Norfolk Island', 'ng' => 'Nigeria', 'ni' => 'Nicaragua', 'nl' => 'Netherlands', 'no' => 'Norway', 'np' => 'Nepal', 'nr' => 'Nauru', 'nt' => 'Neutral Zone', 'nu' => 'Niue', 'nz' => 'New Zealand', 'om' => 'Oman', 'pa' => 'Panama', 'pe' => 'Peru', 'pf' => 'French Polynesia', 'pg' => 'Papua New Guinea', 'ph' => 'Philippines', 'pk' => 'Pakistan', 'pl' => 'Poland', 'pm' => 'St. Pierre and Miquelon', 'pn' => 'Pitcairn', 'pr' => 'Puerto Rico', 'pt' => 'Portugal', 'pw' => 'Palau', 'py' => 'Paraguay', 'qa' => 'Qatar', 're' => 'Reunion', 'ro' => 'Romania', 'ru' => 'Russia', 'rw' => 'Rwanda', 'sa' => 'Saudi Arabia', 'sb' => 'Solomon Islands', 'sc' => 'Seychelles', 'sd' => 'Sudan', 'se' => 'Sweden', 'sg' => 'Singapore', 'sh' => 'St. Helena', 'si' => 'Slovenia', 'sj' => 'Svalbard and Jan Mayen Islands', 'sk' => 'Slovakia (Slovak Republic)', 'sl' => 'Sierra Leone', 'sm' => 'San Marino', 'sn' => 'Senegal', 'so' => 'Somalia', 'sr' => 'Suriname', 'st' => 'Sao Tome and Principe', 'sv' => 'El Salvador', 'sy' => 'Syria', 'sz' => 'Swaziland', 'tc' => 'Turks and Caicos Islands', 'td' => 'Chad', 'tf' => 'French Southern Territories', 'tg' => 'Togo', 'th' => 'Thailand', 'tj' => 'Tajikistan', 'tk' => 'Tokelau', 'tm' => 'Turkmenistan', 'tn' => 'Tunisia', 'to' => 'Tonga', 'tp' => 'East Timor', 'tr' => 'Turkey', 'tt' => 'Trinidad, Tobago', 'tv' => 'Tuvalu', 'tw' => 'Taiwan', 'tz' => 'Tanzania', 'ua' => 'Ukraine', 'ug' => 'Uganda', 'uk' => 'United Kingdom', 'um' => 'United States Minor Islands', 'us' => 'United States of America', 'uy' => 'Uruguay', 'uz' => 'Uzbekistan', 'va' => 'Vatican City', 'vc' => 'Saint Vincent, Grenadines', 've' => 'Venezuela', 'vg' => 'Virgin Islands (British)', 'vi' => 'Virgin Islands (USA)', 'vn' => 'Viet Nam', 'vu' => 'Vanuatu', 'wf' => 'Wallis and Futuna Islands', 'ws' => 'Samoa', 'ye' => 'Yemen', 'yt' => 'Mayotte', 'yu' => 'Yugoslavia', 'za' => 'South Africa', 'zm' => 'Zambia', 'zr' => 'Zaire', 'zw' => 'Zimbabwe'); public static function getCountries() { return self::$countries; } public function validate($value) { $value = strtolower($value); return isset(self::$countries[$value]); } }class Doctrine_Transaction extends Doctrine_Connection_Module { const STATE_SLEEP = 0; const STATE_ACTIVE = 1; const STATE_BUSY = 2; protected $_nestingLevel = 0; protected $_internalNestingLevel = 0; protected $invalid = array(); protected $savePoints = array(); protected $_collections = array(); public function addCollection(Doctrine_Collection $coll) { $this->_collections[] = $coll; return $this; } public function getState() { switch ($this->_nestingLevel) { case 0: return Doctrine_Transaction::STATE_SLEEP; break; case 1: return Doctrine_Transaction::STATE_ACTIVE; break; default: return Doctrine_Transaction::STATE_BUSY; } } public function addInvalid(Doctrine_Record $record) { if (in_array($record, $this->invalid, true)) { return false; } $this->invalid[] = $record; return true; } public function getInvalid() { return $this->invalid; } public function getTransactionLevel() { return $this->_nestingLevel; } public function getInternalTransactionLevel() { return $this->_internalNestingLevel; } public function beginTransaction($savepoint = null) { $this->conn->connect(); $listener = $this->conn->getAttribute(Doctrine::ATTR_LISTENER); if ( ! is_null($savepoint)) { $this->savePoints[] = $savepoint; $event = new Doctrine_Event($this, Doctrine_Event::SAVEPOINT_CREATE); $listener->preSavepointCreate($event); if ( ! $event->skipOperation) { $this->createSavePoint($savepoint); } $listener->postSavepointCreate($event); } else { if ($this->_nestingLevel == 0) { $event = new Doctrine_Event($this, Doctrine_Event::TX_BEGIN); $listener->preTransactionBegin($event); if ( ! $event->skipOperation) { try { $this->_doBeginTransaction(); } catch (Exception $e) { throw new Doctrine_Transaction_Exception($e->getMessage()); } } $listener->postTransactionBegin($event); } } $level = ++$this->_nestingLevel; return $level; } public function commit($savepoint = null) { if ($this->_nestingLevel == 0) { throw new Doctrine_Transaction_Exception("Commit failed. There is no active transaction."); } $this->conn->connect(); $listener = $this->conn->getAttribute(Doctrine::ATTR_LISTENER); if ( ! is_null($savepoint)) { $this->_nestingLevel -= $this->removeSavePoints($savepoint); $event = new Doctrine_Event($this, Doctrine_Event::SAVEPOINT_COMMIT); $listener->preSavepointCommit($event); if ( ! $event->skipOperation) { $this->releaseSavePoint($savepoint); } $listener->postSavepointCommit($event); } else { if ($this->_nestingLevel == 1 || $this->_internalNestingLevel == 1) { if ( ! empty($this->invalid)) { if ($this->_internalNestingLevel == 1) { $tmp = $this->invalid; $this->invalid = array(); throw new Doctrine_Validator_Exception($tmp); } } if ($this->_nestingLevel == 1) { foreach ($this->_collections as $coll) { $coll->takeSnapshot(); } $this->_collections = array(); $event = new Doctrine_Event($this, Doctrine_Event::TX_COMMIT); $listener->preTransactionCommit($event); if ( ! $event->skipOperation) { $this->_doCommit(); } $listener->postTransactionCommit($event); } } if ($this->_nestingLevel > 0) { $this->_nestingLevel--; } if ($this->_internalNestingLevel > 0) { $this->_internalNestingLevel--; } } return true; } public function rollback($savepoint = null) { if ($this->_nestingLevel == 0) { throw new Doctrine_Transaction_Exception("Rollback failed. There is no active transaction."); } $this->conn->connect(); if ($this->_internalNestingLevel >= 1 && $this->_nestingLevel > 1) { $this->_internalNestingLevel--; $this->_nestingLevel--; return false; } else if ($this->_nestingLevel > 1) { $this->_nestingLevel--; return false; } $listener = $this->conn->getAttribute(Doctrine::ATTR_LISTENER); if ( ! is_null($savepoint)) { $this->_nestingLevel -= $this->removeSavePoints($savepoint); $event = new Doctrine_Event($this, Doctrine_Event::SAVEPOINT_ROLLBACK); $listener->preSavepointRollback($event); if ( ! $event->skipOperation) { $this->rollbackSavePoint($savepoint); } $listener->postSavepointRollback($event); } else { $event = new Doctrine_Event($this, Doctrine_Event::TX_ROLLBACK); $listener->preTransactionRollback($event); if ( ! $event->skipOperation) { $this->_nestingLevel = 0; $this->_internalNestingLevel = 0; try { $this->_doRollback(); } catch (Exception $e) { throw new Doctrine_Transaction_Exception($e->getMessage()); } } $listener->postTransactionRollback($event); } return true; } protected function createSavePoint($savepoint) { throw new Doctrine_Transaction_Exception('Savepoints not supported by this driver.'); } protected function releaseSavePoint($savepoint) { throw new Doctrine_Transaction_Exception('Savepoints not supported by this driver.'); } protected function rollbackSavePoint($savepoint) { throw new Doctrine_Transaction_Exception('Savepoints not supported by this driver.'); } protected function _doRollback() { $this->conn->getDbh()->rollback(); } protected function _doCommit() { $this->conn->getDbh()->commit(); } protected function _doBeginTransaction() { $this->conn->getDbh()->beginTransaction(); } private function removeSavePoints($savepoint) { $this->savePoints = array_values($this->savePoints); $found = false; $i = 0; foreach ($this->savePoints as $key => $sp) { if ( ! $found) { if ($sp === $savepoint) { $found = true; } } if ($found) { $i++; unset($this->savePoints[$key]); } } return $i; } public function setIsolation($isolation) { throw new Doctrine_Transaction_Exception('Transaction isolation levels not supported by this driver.'); } public function getIsolation() { throw new Doctrine_Transaction_Exception('Fetching transaction isolation level not supported by this driver.'); } public function beginInternalTransaction($savepoint = null) { $this->_internalNestingLevel++; return $this->beginTransaction($savepoint); } } class Doctrine_Hook { protected $query; protected $joins; protected $hooks = array( 'where', 'orderby', 'limit', 'offset' ); protected $fieldParsers = array(); protected $typeParsers = array( 'char' => 'Doctrine_Hook_WordLike', 'string' => 'Doctrine_Hook_WordLike', 'varchar' => 'Doctrine_Hook_WordLike', 'integer' => 'Doctrine_Hook_Integer', 'enum' => 'Doctrine_Hook_Integer', 'time' => 'Doctrine_Hook_Time', 'date' => 'Doctrine_Hook_Date', ); public function __construct($query) { if (is_string($query)) { $this->query = new Doctrine_Query(); $this->query->parseQuery($query); } elseif ($query instanceof Doctrine_Query) { $this->query = $query; } else { throw new Doctrine_Exception('Constructor argument should be either Doctrine_Query object or valid DQL query'); } $this->query->getQuery(); } public function getQuery() { return $this->query; } public function setTypeParser($type, $parser) { $this->typeParsers[$type] = $parser; } public function setFieldParser($field, $parser) { $this->fieldParsers[$field] = $parser; } public function hookWhere($params) { if ( ! is_array($params)) { return false; } foreach ($params as $name => $value) { if ($value === '' || $value === '-') { continue; } $e = explode('.', $name); if (count($e) == 2) { list($alias, $column) = $e; $map = $this->query->getAliasDeclaration($alias); $table = $map['table']; if ( ! $table) { throw new Doctrine_Exception('Unknown alias ' . $alias); } if ($def = $table->getDefinitionOf($column)) { $def[0] = gettype($value); if (isset($this->typeParsers[$def[0]])) { $name = $this->typeParsers[$def[0]]; $parser = new $name; } $parser->parse($alias, $column, $value); $this->query->addWhere($parser->getCondition(), $parser->getParams()); } } } return true; } public function hookOrderby($params) { if ( ! is_array($params)) { return false; } foreach ($params as $name) { $e = explode(' ', $name); $order = 'ASC'; if (count($e) > 1) { $order = ($e[1] == 'DESC') ? 'DESC' : 'ASC'; } $e = explode('.', $e[0]); if (count($e) == 2) { list($alias, $column) = $e; $map = $this->query->getAliasDeclaration($alias); $table = $map['table']; if ($def = $table->getDefinitionOf($column)) { $this->query->addOrderBy($alias . '.' . $column . ' ' . $order); } } } return true; } public function hookLimit($limit) { $this->query->limit((int) $limit); } public function hookOffset($offset) { $this->query->offset((int) $offset); } } class Doctrine_Compiler_Exception extends Doctrine_Exception { }class Doctrine_Parser_Spyc_YamlNode { var $parent; var $id; var $data; var $indent; var $children = false; function __construct($nodeId) { $this->id = $nodeId; } }class Doctrine_Parser_Spyc { function YAMLLoad($input) { $spyc = new Doctrine_Spyc; return $spyc->load($input); } function YAMLDump($array,$indent = false,$wordwrap = false) { $spyc = new Doctrine_Spyc; return $spyc->dump($array,$indent,$wordwrap); } function load($input) { if ( ! empty($input) && (strpos($input, "\n") === false) && file_exists($input)) { $yaml = file($input); } else { $yaml = explode("\n",$input); } $base = new Doctrine_Parser_Spyc_YamlNode (1); $base->indent = 0; $this->_lastIndent = 0; $this->_lastNode = $base->id; $this->_inBlock = false; $this->_isInline = false; $this->_nodeId = 2; foreach ($yaml as $linenum => $line) { $ifchk = trim($line); if (preg_match('/^(\t)+(\w+)/', $line)) { $err = 'ERROR: Line '. ($linenum + 1) .' in your input YAML begins'. ' with a tab.  YAML only recognizes spaces.  Please reformat.'; die($err); } if ($this->_inBlock === false && empty($ifchk)) { continue; } elseif ($this->_inBlock == true && empty($ifchk)) { $last =& $this->_allNodes[$this->_lastNode]; $last->data[key($last->data)] .= "\n"; } elseif ($ifchk{0} != '#' && substr($ifchk,0,3) != '---') { $node = new Doctrine_Parser_Spyc_YamlNode ($this->_nodeId); $this->_nodeId++; $node->indent = $this->_getIndent($line); if ($this->_lastIndent == $node->indent) { if ($this->_inBlock === true) { $parent =& $this->_allNodes[$this->_lastNode]; $parent->data[key($parent->data)] .= trim($line).$this->_blockEnd; } else { if (isset($this->_allNodes[$this->_lastNode])) { $node->parent = $this->_allNodes[$this->_lastNode]->parent; } } } elseif ($this->_lastIndent < $node->indent) { if ($this->_inBlock === true) { $parent =& $this->_allNodes[$this->_lastNode]; $parent->data[key($parent->data)] .= trim($line).$this->_blockEnd; } elseif ($this->_inBlock === false) { $node->parent = $this->_lastNode; $parent =& $this->_allNodes[$node->parent]; $this->_allNodes[$node->parent]->children = true; if (is_array($parent->data)) { $chk = ''; if (isset ($parent->data[key($parent->data)])) $chk = $parent->data[key($parent->data)]; if ($chk === '>') { $this->_inBlock = true; $this->_blockEnd = ' '; $parent->data[key($parent->data)] = str_replace('>','',$parent->data[key($parent->data)]); $parent->data[key($parent->data)] .= trim($line).' '; $this->_allNodes[$node->parent]->children = false; $this->_lastIndent = $node->indent; } elseif ($chk === '|') { $this->_inBlock = true; $this->_blockEnd = "\n"; $parent->data[key($parent->data)] = str_replace('|','',$parent->data[key($parent->data)]); $parent->data[key($parent->data)] .= trim($line)."\n"; $this->_allNodes[$node->parent]->children = false; $this->_lastIndent = $node->indent; } } } } elseif ($this->_lastIndent > $node->indent) { if ($this->_inBlock === true) { $this->_inBlock = false; if ($this->_blockEnd = "\n") { $last =& $this->_allNodes[$this->_lastNode]; $last->data[key($last->data)] = trim($last->data[key($last->data)]); } } foreach ($this->_indentSort[$node->indent] as $n) { if ($n->indent == $node->indent) { $node->parent = $n->parent; } } } if ($this->_inBlock === false) { $this->_lastIndent = $node->indent; $this->_lastNode = $node->id; $node->data = $this->_parseLine($line); $this->_allNodes[$node->id] = $node; $this->_allParent[intval($node->parent)][] = $node->id; $this->_indentSort[$node->indent][] =& $this->_allNodes[$node->id]; if ( ( (is_array($node->data)) && isset($node->data[key($node->data)]) && ( ! is_array($node->data[key($node->data)])) ) && ( (preg_match('/^&([^ ]+)/',$node->data[key($node->data)])) || (preg_match('/^\*([^ ]+)/',$node->data[key($node->data)])) ) ) { $this->_haveRefs[] =& $this->_allNodes[$node->id]; } elseif ( ( (is_array($node->data)) && isset($node->data[key($node->data)]) && (is_array($node->data[key($node->data)])) ) ) { foreach ($node->data[key($node->data)] as $d) { if ( !is_array($d) && ( (preg_match('/^&([^ ]+)/',$d)) || (preg_match('/^\*([^ ]+)/',$d)) ) ) { $this->_haveRefs[] =& $this->_allNodes[$node->id]; } } } } } } unset($node); $this->_linkReferences(); $trunk = $this->_buildArray(); return $trunk; } function dump($array,$indent = false,$wordwrap = false) { if ($indent === false or !is_numeric($indent)) { $this->_dumpIndent = 2; } else { $this->_dumpIndent = $indent; } if ($wordwrap === false or !is_numeric($wordwrap)) { $this->_dumpWordWrap = 40; } else { $this->_dumpWordWrap = $wordwrap; } $string = "---\n"; foreach ($array as $key => $value) { $string .= $this->_yamlize($key,$value,0); } return $string; } var $_haveRefs; var $_allNodes; var $_allParent; var $_lastIndent; var $_lastNode; var $_inBlock; var $_isInline; var $_dumpIndent; var $_dumpWordWrap; var $_nodeId; function _yamlize($key,$value,$indent) { if (is_array($value)) { $string = $this->_dumpNode($key,NULL,$indent); $indent += $this->_dumpIndent; $string .= $this->_yamlizeArray($value,$indent); } elseif ( ! is_array($value)) { $string = $this->_dumpNode($key,$value,$indent); } return $string; } function _yamlizeArray($array,$indent) { if (is_array($array)) { $string = ''; foreach ($array as $key => $value) { $string .= $this->_yamlize($key,$value,$indent); } return $string; } else { return false; } } function _dumpNode($key,$value,$indent) { if (strpos($value,"\n") !== false || strpos($value,": ") !== false || strpos($value,"- ") !== false) { $value = $this->_doLiteralBlock($value,$indent); } else { $value = $this->_doFolding($value,$indent); } if (is_bool($value)) { $value = ($value) ? "true" : "false"; } $spaces = str_repeat(' ',$indent); if (is_int($key)) { $string = $spaces.'- '.$value."\n"; } else { $string = $spaces.$key.': '.$value."\n"; } return $string; } function _doLiteralBlock($value,$indent) { $exploded = explode("\n",$value); $newValue = '|'; $indent += $this->_dumpIndent; $spaces = str_repeat(' ',$indent); foreach ($exploded as $line) { $newValue .= "\n" . $spaces . trim($line); } return $newValue; } function _doFolding($value,$indent) { if ($this->_dumpWordWrap === 0) { return $value; } if (strlen($value) > $this->_dumpWordWrap) { $indent += $this->_dumpIndent; $indent = str_repeat(' ',$indent); $wrapped = wordwrap($value,$this->_dumpWordWrap,"\n$indent"); $value = ">\n".$indent.$wrapped; } return $value; } function _getIndent($line) { preg_match('/^\s{1,}/',$line,$match); if ( ! empty($match[0])) { $indent = substr_count($match[0],' '); } else { $indent = 0; } return $indent; } function _parseLine($line) { $line = trim($line); if(!preg_match("/\\\#/", $line)) { $line = trim(preg_replace('/#.*$/', '', $line)); } $array = array(); if (preg_match('/^-(.*):$/',$line)) { $key = trim(substr(substr($line,1),0,-1)); $array[$key] = ''; } elseif ($line[0] == '-' && substr($line,0,3) != '---') { if (strlen($line) > 1) { $value = trim(substr($line,1)); $value = $this->_toType($value); $array[] = $value; } else { $array[] = array(); } } elseif (preg_match('/^(.+):/',$line,$key)) { if (preg_match('/^(["\'](.*)["\'](\s)*:)/',$line,$matches)) { $value = trim(str_replace($matches[1],'',$line)); $key = $matches[2]; } else { $explode = explode(':',$line); $key = trim($explode[0]); array_shift($explode); $value = trim(implode(':',$explode)); } $value = $this->_toType($value); if (empty($key)) { $array[] = $value; } else { $array[$key] = $value; } } return $array; } function _toType($value) { if (preg_match('/^("(.*)"|\'(.*)\')/',$value,$matches)) { $value = (string)preg_replace('/(\'\'|\\\\\')/',"'",end($matches)); $value = preg_replace('/\\\\"/','"',$value); } elseif (preg_match('/^\\[(.*)\\]$/',$value,$matches)) { $explode = empty($matches[1]) ? array() : $this->_inlineEscape($matches[1]); $value = array(); foreach ($explode as $v) { $value[] = $this->_toType($v); } } elseif (strpos($value,': ')!==false && !preg_match('/^{(.+)/',$value)) { $array = explode(': ',$value); $key = trim($array[0]); array_shift($array); $value = trim(implode(': ',$array)); $value = $this->_toType($value); $value = array($key => $value); } elseif (preg_match("/{(.+)}$/",$value,$matches)) { $explode = $this->_inlineEscape($matches[1]); $array = array(); foreach ($explode as $v) { $array = $array + $this->_toType($v); } $value = $array; } elseif (strtolower($value) == 'null' or $value == '' or $value == '~') { $value = NULL; } elseif (preg_match ('/^[0-9]+$/', $value)) { $raw = $value; $value = (int) $value; if ((string) $value != (string) $raw) { $value = (string) $raw; } } elseif (in_array(strtolower($value), array('true', 'on', '+', 'yes', 'y'))) { $value = true; } elseif (in_array(strtolower($value), array('false', 'off', '-', 'no', 'n'))) { $value = false; } elseif (is_numeric($value)) { $raw = $value; $value = (float) $value; if ((string) $value != (string) $raw) { $value = (string) $raw; } } else { $value = trim(preg_replace('/#(.+)$/','',$value)); } return $value; } function _inlineEscape($inline) { $saved_strings = array(); $regex = '/(?:(")|(?:\'))((?(1)[^"]+|[^\']+))(?(1)"|\')/'; if (preg_match_all($regex,$inline,$strings)) { $saved_strings = $strings[0]; $inline = preg_replace($regex,'YAMLString',$inline); } unset($regex); if (preg_match_all('/\[(.+)\]/U',$inline,$seqs)) { $inline = preg_replace('/\[(.+)\]/U','YAMLSeq',$inline); $seqs = $seqs[0]; } if (preg_match_all('/{(.+)}/U',$inline,$maps)) { $inline = preg_replace('/{(.+)}/U','YAMLMap',$inline); $maps = $maps[0]; } $explode = explode(', ',$inline); if ( ! empty($seqs)) { $i = 0; foreach ($explode as $key => $value) { if (strpos($value,'YAMLSeq') !== false) { $explode[$key] = str_replace('YAMLSeq',$seqs[$i],$value); ++$i; } } } if ( ! empty($maps)) { $i = 0; foreach ($explode as $key => $value) { if (strpos($value,'YAMLMap') !== false) { $explode[$key] = str_replace('YAMLMap',$maps[$i],$value); ++$i; } } } if ( ! empty($saved_strings)) { $i = 0; foreach ($explode as $key => $value) { while (strpos($value,'YAMLString') !== false) { $explode[$key] = preg_replace('/YAMLString/',$saved_strings[$i],$value, 1); ++$i; $value = $explode[$key]; } } } return $explode; } function _buildArray() { $trunk = array(); if ( ! isset($this->_indentSort[0])) { return $trunk; } foreach ($this->_indentSort[0] as $n) { if (empty($n->parent)) { $this->_nodeArrayizeData($n); $this->_makeReferences($n); $trunk = $this->_array_kmerge($trunk,$n->data); } } return $trunk; } function _linkReferences() { if (is_array($this->_haveRefs)) { foreach ($this->_haveRefs as $node) { if ( ! empty($node->data)) { $key = key($node->data); if (is_array($node->data[$key])) { foreach ($node->data[$key] as $k => $v) { $this->_linkRef($node,$key,$k,$v); } } else { $this->_linkRef($node,$key); } } } } return true; } function _linkRef(&$n,$key,$k = NULL,$v = NULL) { if (empty($k) && empty($v)) { if (preg_match('/^&([^ ]+)/',$n->data[$key],$matches)) { $this->_allNodes[$n->id]->ref = substr($matches[0],1); $this->_allNodes[$n->id]->data[$key] = substr($n->data[$key],strlen($matches[0])+1); } elseif (preg_match('/^\*([^ ]+)/',$n->data[$key],$matches)) { $ref = substr($matches[0],1); $this->_allNodes[$n->id]->refKey = $ref; } } elseif ( ! empty($k) && !empty($v)) { if (preg_match('/^&([^ ]+)/',$v,$matches)) { $this->_allNodes[$n->id]->ref = substr($matches[0],1); $this->_allNodes[$n->id]->data[$key][$k] = substr($v,strlen($matches[0])+1); } elseif (preg_match('/^\*([^ ]+)/',$v,$matches)) { $ref = substr($matches[0],1); $this->_allNodes[$n->id]->refKey = $ref; } } } function _gatherChildren($nid) { $return = array(); $node =& $this->_allNodes[$nid]; if (is_array ($this->_allParent[$node->id])) { foreach ($this->_allParent[$node->id] as $nodeZ) { $z =& $this->_allNodes[$nodeZ]; $this->_nodeArrayizeData($z); $this->_makeReferences($z); $return = $this->_array_kmerge($return,$z->data); } } return $return; } function _nodeArrayizeData(&$node) { if (is_array($node->data) && $node->children == true) { $childs = $this->_gatherChildren($node->id); $key = key($node->data); $key = empty($key) ? 0 : $key; if (isset ($node->data[$key])) { if (is_array($node->data[$key])) { $node->data[$key] = $this->_array_kmerge($node->data[$key],$childs); } else { $node->data[$key] = $childs; } } else { $node->data[$key] = $childs; } } elseif ( ! is_array($node->data) && $node->children == true) { $childs = $this->_gatherChildren($node->id); $node->data = array(); $node->data[] = $childs; } return true; } function _makeReferences(&$z) { if (isset($z->ref)) { $key = key($z->data); $this->ref[$z->ref] =& $z->data[$key]; } elseif (isset($z->refKey)) { if (isset($this->ref[$z->refKey])) { $key = key($z->data); $z->data[$key] =& $this->ref[$z->refKey]; } } return true; } function _array_kmerge($arr1,$arr2) { if( ! is_array($arr1)) $arr1 = array(); if( ! is_array($arr2)) $arr2 = array(); $keys = array_merge(array_keys($arr1),array_keys($arr2)); $vals = array_merge(array_values($arr1),array_values($arr2)); $ret = array(); foreach($keys as $key) { list($unused,$val) = each($vals); if (isset($ret[$key]) and is_int($key)) $ret[] = $val; else $ret[$key] = $val; } return $ret; } }class Doctrine_Parser_YamlSf_Parser { protected $value = '', $offset = 0, $lines = array(), $currentLineNb = -1, $currentLine = '', $refs = array(); public function __construct($offset = 0) { $this->offset = $offset; } public function parse($value) { $this->value = $this->cleanup($value); $this->currentLineNb = -1; $this->currentLine = ''; $this->lines = explode("\n", $this->value); $data = array(); while ($this->moveToNextLine()) { if ($this->isCurrentLineEmpty()) { continue; } if (preg_match('#^\t+#', $this->currentLine)) { throw new InvalidArgumentException(sprintf('A YAML file cannot contain tabs as indentation at line %d (%s).', $this->getRealCurrentLineNb(), $this->currentLine)); } $isRef = $isInPlace = false; if (preg_match('#^\-(\s+(?P<value>.+?))?\s*$#', $this->currentLine, $values)) { if (isset($values['value']) && preg_match('#^&(?P<ref>[^ ]+) *(?P<value>.*)#', $values['value'], $matches)) { $isRef = $matches['ref']; $values['value'] = $matches['value']; } if (!isset($values['value']) || '' == trim($values['value'], ' ') || 0 === strpos(ltrim($values['value'], ' '), '#')) { $c = $this->getRealCurrentLineNb() + 1; $parser = new Doctrine_Parser_YamlSf_Parser($c); $parser->refs =& $this->refs; $data[] = $parser->parse($this->getNextEmbedBlock()); } else { if (preg_match('/^([^ ]+)\: +({.*?)$/', $values['value'], $matches)) { $data[] = array($matches[1] => Doctrine_Parser_YamlSf_Inline::load($matches[2])); } else { $data[] = $this->parseValue($values['value']); } } } else if (preg_match('#^(?P<key>[^ ].*?) *\:(\s+(?P<value>.+?))?\s*$#', $this->currentLine, $values)) { $key = Doctrine_Parser_YamlSf_Inline::parseScalar($values['key']); if ('<<' === $key) { if (isset($values['value']) && '*' === substr($values['value'], 0, 1)) { $isInPlace = substr($values['value'], 1); if (!array_key_exists($isInPlace, $this->refs)) { throw new InvalidArgumentException(sprintf('Reference "%s" does not exist on line %s.', $isInPlace, $this->currentLine)); } } else { throw new InvalidArgumentException(sprintf('In place substitution must point to a reference on line %s.', $this->currentLine)); } } else if (isset($values['value']) && preg_match('#^&(?P<ref>[^ ]+) *(?P<value>.*)#', $values['value'], $matches)) { $isRef = $matches['ref']; $values['value'] = $matches['value']; } if (!isset($values['value']) || '' == trim($values['value'], ' ') || 0 === strpos(ltrim($values['value'], ' '), '#')) { if ($this->isNextLineIndented()) { $data[$key] = null; } else { $c = $this->getRealCurrentLineNb() + 1; $parser = new Doctrine_Parser_YamlSf_Parser($c); $parser->refs =& $this->refs; $data[$key] = $parser->parse($this->getNextEmbedBlock()); } } else { if ($isInPlace) { $data = $this->refs[$isInPlace]; } else { $data[$key] = $this->parseValue($values['value']); } } } else { if (1 == count(explode("\n", rtrim($this->value, "\n")))) { return Doctrine_Parser_YamlSf_Inline::load($this->lines[0]); } throw new InvalidArgumentException(sprintf('Unable to parse line %d (%s).', $this->getRealCurrentLineNb(), $this->currentLine)); } if ($isRef) { $this->refs[$isRef] = end($data); } } return empty($data) ? null : $data; } protected function getRealCurrentLineNb() { return $this->currentLineNb + $this->offset; } protected function getCurrentLineIndentation() { return strlen($this->currentLine) - strlen(ltrim($this->currentLine, ' ')); } protected function getNextEmbedBlock() { $this->moveToNextLine(); $newIndent = $this->getCurrentLineIndentation(); if (!$this->isCurrentLineEmpty() && 0 == $newIndent) { throw new InvalidArgumentException(sprintf('Indentation problem at line %d (%s)', $this->getRealCurrentLineNb(), $this->currentLine)); } $data = array(substr($this->currentLine, $newIndent)); while ($this->moveToNextLine()) { if ($this->isCurrentLineEmpty()) { if ($this->isCurrentLineBlank()) { $data[] = substr($this->currentLine, $newIndent); } continue; } $indent = $this->getCurrentLineIndentation(); if (preg_match('#^(?P<text> *)$#', $this->currentLine, $match)) { $data[] = $match['text']; } else if ($indent >= $newIndent) { $data[] = substr($this->currentLine, $newIndent); } else if (0 == $indent) { $this->moveToPreviousLine(); break; } else { throw new InvalidArgumentException(sprintf('Indentation problem at line %d (%s)', $this->getRealCurrentLineNb(), $this->currentLine)); } } return implode("\n", $data); } protected function moveToNextLine() { if ($this->currentLineNb >= count($this->lines) - 1) { return false; } $this->currentLine = $this->lines[++$this->currentLineNb]; return true; } protected function moveToPreviousLine() { $this->currentLine = $this->lines[--$this->currentLineNb]; } protected function parseValue($value) { if ('*' === substr($value, 0, 1)) { if (false !== $pos = strpos($value, '#')) { $value = substr($value, 1, $pos - 2); } else { $value = substr($value, 1); } if (!array_key_exists($value, $this->refs)) { throw new InvalidArgumentException(sprintf('Reference "%s" does not exist (%s).', $value, $this->currentLine)); } return $this->refs[$value]; } if (preg_match('/^(?P<separator>\||>)(?P<modifiers>\+|\-|\d+|\+\d+|\-\d+|\d+\+|\d+\-)?(?P<comments> +#.*)?$/', $value, $matches)) { $modifiers = isset($matches['modifiers']) ? $matches['modifiers'] : ''; return $this->parseFoldedScalar($matches['separator'], preg_replace('#\d+#', '', $modifiers), intval(abs($modifiers))); } else { return Doctrine_Parser_YamlSf_Inline::load($value); } } protected function parseFoldedScalar($separator, $indicator = '', $indentation = 0) { $separator = '|' == $separator ? "\n" : ' '; $text = ''; $notEOF = $this->moveToNextLine(); while ($notEOF && $this->isCurrentLineBlank()) { $text .= "\n"; $notEOF = $this->moveToNextLine(); } if (!$notEOF) { return ''; } if (!preg_match('#^(?P<indent>'.($indentation ? str_repeat(' ', $indentation) : ' +').')(?P<text>.*)$#', $this->currentLine, $matches)) { $this->moveToPreviousLine(); return ''; } $textIndent = $matches['indent']; $previousIndent = 0; $text .= $matches['text'].$separator; while ($this->currentLineNb + 1 < count($this->lines)) { $this->moveToNextLine(); if (preg_match('#^(?P<indent> {'.strlen($textIndent).',})(?P<text>.+)$#', $this->currentLine, $matches)) { if (' ' == $separator && $previousIndent != $matches['indent']) { $text = substr($text, 0, -1)."\n"; } $previousIndent = $matches['indent']; $text .= str_repeat(' ', $diff = strlen($matches['indent']) - strlen($textIndent)).$matches['text'].($diff ? "\n" : $separator); } else if (preg_match('#^(?P<text> *)$#', $this->currentLine, $matches)) { $text .= preg_replace('#^ {1,'.strlen($textIndent).'}#', '', $matches['text'])."\n"; } else { $this->moveToPreviousLine(); break; } } if (' ' == $separator) { $text = preg_replace('/ (\n*)$/', "\n$1", $text); } switch ($indicator) { case '': $text = preg_replace('#\n+$#s', "\n", $text); break; case '+': break; case '-': $text = preg_replace('#\n+$#s', '', $text); break; } return $text; } protected function isNextLineIndented() { $currentIndentation = $this->getCurrentLineIndentation(); $notEOF = $this->moveToNextLine(); while ($notEOF && $this->isCurrentLineEmpty()) { $notEOF = $this->moveToNextLine(); } if (false === $notEOF) { return false; } $ret = false; if ($this->getCurrentLineIndentation() <= $currentIndentation) { $ret = true; } $this->moveToPreviousLine(); return $ret; } protected function isCurrentLineEmpty() { return $this->isCurrentLineBlank() || $this->isCurrentLineComment(); } protected function isCurrentLineBlank() { return '' == trim($this->currentLine, ' '); } protected function isCurrentLineComment() { return 0 === strpos(ltrim($this->currentLine, ' '), '#'); } protected function cleanup($value) { $value = str_replace(array("\r\n", "\r"), "\n", $value); if (!preg_match("#\n$#", $value)) { $value .= "\n"; } preg_replace('#^\%YAML[: ][\d\.]+.*\n#s', '', $value); $value = preg_replace('#^\-\-\-.*?\n#s', '', $value); return $value; } }class Doctrine_Parser_YamlSf_Inline { static public function load($value) { $value = trim($value); if (0 == strlen($value)) { return ''; } switch ($value[0]) { case '[': return self::parseSequence($value); case '{': return self::parseMapping($value); default: return self::parseScalar($value); } } static public function dump($value) { switch (true) { case is_resource($value): throw new InvalidArgumentException('Unable to dump PHP resources in a YAML file.'); case is_object($value): return '!!php/object:'.serialize($value); case is_array($value): return self::dumpArray($value); case is_null($value): return 'null'; case true === $value: return 'true'; case false === $value: return 'false'; case ctype_digit($value): return is_string($value) ? "'$value'" : (int) $value; case is_numeric($value): return is_infinite($value) ? str_ireplace('INF', '.Inf', strval($value)) : (is_string($value) ? "'$value'" : $value); case false !== strpos($value, "\n"): return sprintf('"%s"', str_replace(array('"', "\n", "\r"), array('\\"', '\n', ''), $value)); case preg_match('/[ \s \' " \: \{ \} \[ \] , & \*]/x', $value): return sprintf("'%s'", str_replace('\'', '\'\'', $value)); case '' == $value: return "''"; case preg_match(self::getTimestampRegex(), $value): return "'$value'"; case in_array(strtolower($value), array('true', 'on', '+', 'yes', 'y')): return "'$value'"; case in_array(strtolower($value), array('false', 'off', '-', 'no', 'n')): return "'$value'"; default: return $value; } } static protected function dumpArray($value) { $keys = array_keys($value); if ( (1 == count($keys) && '0' == $keys[0]) || (count($keys) > 1 && array_reduce($keys, create_function('$v,$w', 'return (integer) $v + $w;'), 0) == count($keys) * (count($keys) - 1) / 2)) { $output = array(); foreach ($value as $val) { $output[] = self::dump($val); } return sprintf('[%s]', implode(', ', $output)); } $output = array(); foreach ($value as $key => $val) { $output[] = sprintf('%s: %s', self::dump($key), self::dump($val)); } return sprintf('{ %s }', implode(', ', $output)); } static public function parseScalar($scalar, $delimiters = null, $stringDelimiters = array('"', "'"), &$i = 0, $evaluate = true) { if (in_array($scalar[$i], $stringDelimiters)) { $output = self::parseQuotedScalar($scalar, $i); ++$i; } else { if (!$delimiters) { $output = substr($scalar, $i); $i += strlen($output); if (false !== $strpos = strpos($output, ' #')) { $output = rtrim(substr($output, 0, $strpos)); } } else if (preg_match('/^(.+?)('.implode('|', $delimiters).')/', substr($scalar, $i), $match)) { $output = $match[1]; $i += strlen($output); } else { throw new InvalidArgumentException(sprintf('Malformed inline YAML string (%s).', $scalar)); } $output = $evaluate ? self::evaluateScalar($output) : $output; } return $output; } static protected function parseQuotedScalar($scalar, &$i) { $delimiter = $scalar[$i]; ++$i; $buffer = ''; $len = strlen($scalar); $escaped = '"' == $delimiter ? '\\"' : "''"; while ($i < $len) { if (isset($scalar[$i + 1]) && $escaped == $scalar[$i].$scalar[$i + 1]) { $buffer .= $delimiter; ++$i; } else if ($delimiter == $scalar[$i]) { break; } else { $buffer .= $scalar[$i]; } ++$i; } if ('"' == $delimiter) { $buffer = str_replace('\\n', "\n", $buffer); } return $buffer; } static protected function parseSequence($sequence, &$i = 0) { $output = array(); $len = strlen($sequence); $i += 1; while ($i < $len) { switch ($sequence[$i]) { case '[': $output[] = self::parseSequence($sequence, $i); break; case '{': $output[] = self::parseMapping($sequence, $i); break; case ']': return $output; case ',': case ' ': break; default: $isQuoted = in_array($sequence[$i], array('"', "'")); $value = self::parseScalar($sequence, array(',', ']'), array('"', "'"), $i); if (!$isQuoted && false !== strpos($value, ': ')) { try { $value = self::parseMapping('{'.$value.'}'); } catch (InvalidArgumentException $e) { } } $output[] = $value; --$i; } ++$i; } throw new InvalidArgumentException(sprintf('Malformed inline YAML string %s', $sequence)); } static protected function parseMapping($mapping, &$i = 0) { $output = array(); $len = strlen($mapping); $i += 1; while ($i < $len) { switch ($mapping[$i]) { case ' ': case ',': ++$i; continue 2; case '}': return $output; } $key = self::parseScalar($mapping, array(':', ' '), array('"', "'"), $i, false); $done = false; while ($i < $len) { switch ($mapping[$i]) { case '[': $output[$key] = self::parseSequence($mapping, $i); $done = true; break; case '{': $output[$key] = self::parseMapping($mapping, $i); $done = true; break; case ':': case ' ': break; default: $output[$key] = self::parseScalar($mapping, array(',', '}'), array('"', "'"), $i); $done = true; --$i; } ++$i; if ($done) { continue 2; } } } throw new InvalidArgumentException(sprintf('Malformed inline YAML string %s', $mapping)); } static protected function evaluateScalar($scalar) { $scalar = trim($scalar); switch (true) { case 'null' == strtolower($scalar): case '' == $scalar: case '~' == $scalar: return null; case 0 === strpos($scalar, '!str'): return (string) substr($scalar, 5); case 0 === strpos($scalar, '! '): return intval(self::parseScalar(substr($scalar, 2))); case 0 === strpos($scalar, '!!php/object:'): return unserialize(substr($scalar, 13)); case ctype_digit($scalar): $raw = $scalar; $cast = intval($scalar); return '0' == $scalar[0] ? octdec($scalar) : (((string) $raw == (string) $cast) ? strval($cast) : $raw); case in_array(strtolower($scalar), array('true', 'on', '+', 'yes', 'y')): return true; case in_array(strtolower($scalar), array('false', 'off', '-', 'no', 'n')): return false; case is_numeric($scalar): return '0x' == $scalar[0].$scalar[1] ? hexdec($scalar) : floatval($scalar); case 0 == strcasecmp($scalar, '.inf'): case 0 == strcasecmp($scalar, '.NaN'): return -log(0); case 0 == strcasecmp($scalar, '-.inf'): return log(0); case preg_match('/^(-|\+)?[0-9,]+(\.[0-9]+)?$/', $scalar): return floatval(str_replace(',', '', $scalar)); case preg_match(self::getTimestampRegex(), $scalar): return strtotime($scalar); default: return (string) $scalar; } } static protected function getTimestampRegex() { return <<<EOF
    ~^
    (?P<year>[0-9][0-9][0-9][0-9])
    -(?P<month>[0-9][0-9]?)
    -(?P<day>[0-9][0-9]?)
    (?:(?:[Tt]|[ \t]+)
    (?P<hour>[0-9][0-9]?)
    :(?P<minute>[0-9][0-9])
    :(?P<second>[0-9][0-9])
    (?:\.(?P<fraction>[0-9]*))?
    (?:[ \t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)
    (?::(?P<tz_minute>[0-9][0-9]))?))?)?
    $~x
EOF;
} }class Doctrine_Parser_YamlSf_Dumper { public function dump($input, $inline = 0, $indent = 0) { $output = ''; $prefix = $indent ? str_repeat(' ', $indent) : ''; if ($inline <= 0 || !is_array($input) || empty($input)) { $output .= $prefix.Doctrine_Parser_YamlSf_Inline::dump($input); } else { $isAHash = count(array_diff_key($input, array_fill(0, count($input), true))); foreach ($input as $key => $value) { $willBeInlined = $inline - 1 <= 0 || !is_array($value) || empty($value); $output .= sprintf('%s%s%s%s', $prefix, $isAHash ? Doctrine_Parser_YamlSf_Inline::dump($key).':' : '-', $willBeInlined ? ' ' : "\n", $this->dump($value, $inline - 1, $willBeInlined ? 0 : $indent + 2) ).($willBeInlined ? "\n" : ''); } } return $output; } }class Doctrine_Parser_Xml extends Doctrine_Parser { public function dumpData($array, $path = null) { $data = $this->arrayToXml($array); return $this->doDump($data, $path); } public function arrayToXml($array, $rootNodeName = 'data', $xml = null) { if ($xml === null) { $xml = new SimpleXmlElement("<?xml version=\"1.0\" encoding=\"utf-8\"?><$rootNodeName/>"); } foreach($array as $key => $value) { if (is_array($value)) { $node = $xml->addChild($key); $this->arrayToXml($value, $rootNodeName, $node); } else if (is_int($key)) { $xml->addChild($value, 'true'); } else { $value = htmlentities($value); $xml->addChild($key, $value); } } return $xml->asXML(); } public function loadData($path) { $contents = $this->doLoad($path); $simpleXml = simplexml_load_string($contents); return $this->prepareData($simpleXml); } public function prepareData($simpleXml) { if ($simpleXml instanceof SimpleXMLElement) { $children = $simpleXml->children(); $return = null; } foreach ($children as $element => $value) { if ($value instanceof SimpleXMLElement) { $values = (array) $value->children(); if (count($values) > 0) { $return[$element] = $this->prepareData($value); } else { if ( ! isset($return[$element])) { $return[$element] = (string) $value; } else { if ( ! is_array($return[$element])) { $return[$element] = array($return[$element], (string) $value); } else { $return[$element][] = (string) $value; } } } } } if (is_array($return)) { return $return; } else { return array(); } } } class Doctrine_YamlNode { var $parent; var $id; var $data; var $indent; var $children = false; function Doctrine_YamlNode($nodeId) { $this->id = $nodeId; } } class Doctrine_Spyc { function YAMLLoad($input) { $spyc = new Doctrine_Spyc; return $spyc->load($input); } function YAMLDump($array,$indent = false,$wordwrap = false) { $spyc = new Doctrine_Spyc; return $spyc->dump($array,$indent,$wordwrap); } function load($input) { if ( ! empty($input) && (strpos($input, "\n") === false) && file_exists($input)) { $yaml = file($input); } else { $yaml = explode("\n",$input); } $base = new Doctrine_YamlNode (1); $base->indent = 0; $this->_lastIndent = 0; $this->_lastNode = $base->id; $this->_inBlock = false; $this->_isInline = false; $this->_nodeId = 2; foreach ($yaml as $linenum => $line) { $ifchk = trim($line); if (preg_match('/^(\t)+(\w+)/', $line)) { $err = 'ERROR: Line '. ($linenum + 1) .' in your input YAML begins'. ' with a tab.  YAML only recognizes spaces.  Please reformat.'; die($err); } if ($this->_inBlock === false && empty($ifchk)) { continue; } elseif ($this->_inBlock == true && empty($ifchk)) { $last =& $this->_allNodes[$this->_lastNode]; $last->data[key($last->data)] .= "\n"; } elseif ($ifchk{0} != '#' && substr($ifchk,0,3) != '---') { $node = new Doctrine_YamlNode ($this->_nodeId); $this->_nodeId++; $node->indent = $this->_getIndent($line); if ($this->_lastIndent == $node->indent) { if ($this->_inBlock === true) { $parent =& $this->_allNodes[$this->_lastNode]; $parent->data[key($parent->data)] .= trim($line).$this->_blockEnd; } else { if (isset($this->_allNodes[$this->_lastNode])) { $node->parent = $this->_allNodes[$this->_lastNode]->parent; } } } elseif ($this->_lastIndent < $node->indent) { if ($this->_inBlock === true) { $parent =& $this->_allNodes[$this->_lastNode]; $parent->data[key($parent->data)] .= trim($line).$this->_blockEnd; } elseif ($this->_inBlock === false) { $node->parent = $this->_lastNode; $parent =& $this->_allNodes[$node->parent]; $this->_allNodes[$node->parent]->children = true; if (is_array($parent->data)) { $chk = ''; if (isset ($parent->data[key($parent->data)])) $chk = $parent->data[key($parent->data)]; if ($chk === '>') { $this->_inBlock = true; $this->_blockEnd = ' '; $parent->data[key($parent->data)] = str_replace('>','',$parent->data[key($parent->data)]); $parent->data[key($parent->data)] .= trim($line).' '; $this->_allNodes[$node->parent]->children = false; $this->_lastIndent = $node->indent; } elseif ($chk === '|') { $this->_inBlock = true; $this->_blockEnd = "\n"; $parent->data[key($parent->data)] = str_replace('|','',$parent->data[key($parent->data)]); $parent->data[key($parent->data)] .= trim($line)."\n"; $this->_allNodes[$node->parent]->children = false; $this->_lastIndent = $node->indent; } } } } elseif ($this->_lastIndent > $node->indent) { if ($this->_inBlock === true) { $this->_inBlock = false; if ($this->_blockEnd = "\n") { $last =& $this->_allNodes[$this->_lastNode]; $last->data[key($last->data)] = trim($last->data[key($last->data)]); } } foreach ($this->_indentSort[$node->indent] as $n) { if ($n->indent == $node->indent) { $node->parent = $n->parent; } } } if ($this->_inBlock === false) { $this->_lastIndent = $node->indent; $this->_lastNode = $node->id; $node->data = $this->_parseLine($line); $this->_allNodes[$node->id] = $node; $this->_allParent[intval($node->parent)][] = $node->id; $this->_indentSort[$node->indent][] =& $this->_allNodes[$node->id]; if ( ( (is_array($node->data)) && isset($node->data[key($node->data)]) && ( ! is_array($node->data[key($node->data)])) ) && ( (preg_match('/^&([^ ]+)/',$node->data[key($node->data)])) || (preg_match('/^\*([^ ]+)/',$node->data[key($node->data)])) ) ) { $this->_haveRefs[] =& $this->_allNodes[$node->id]; } elseif ( ( (is_array($node->data)) && isset($node->data[key($node->data)]) && (is_array($node->data[key($node->data)])) ) ) { foreach ($node->data[key($node->data)] as $d) { if ( !is_array($d) && ( (preg_match('/^&([^ ]+)/',$d)) || (preg_match('/^\*([^ ]+)/',$d)) ) ) { $this->_haveRefs[] =& $this->_allNodes[$node->id]; } } } } } } unset($node); $this->_linkReferences(); $trunk = $this->_buildArray(); return $trunk; } function dump($array,$indent = false,$wordwrap = false) { if ($indent === false or !is_numeric($indent)) { $this->_dumpIndent = 2; } else { $this->_dumpIndent = $indent; } if ($wordwrap === false or !is_numeric($wordwrap)) { $this->_dumpWordWrap = 40; } else { $this->_dumpWordWrap = $wordwrap; } $string = "---\n"; foreach ($array as $key => $value) { $string .= $this->_yamlize($key,$value,0); } return $string; } var $_haveRefs; var $_allNodes; var $_allParent; var $_lastIndent; var $_lastNode; var $_inBlock; var $_isInline; var $_dumpIndent; var $_dumpWordWrap; var $_nodeId; function _yamlize($key,$value,$indent) { if (is_array($value)) { $string = $this->_dumpNode($key,NULL,$indent); $indent += $this->_dumpIndent; $string .= $this->_yamlizeArray($value,$indent); } elseif ( ! is_array($value)) { $string = $this->_dumpNode($key,$value,$indent); } return $string; } function _yamlizeArray($array,$indent) { if (is_array($array)) { $string = ''; foreach ($array as $key => $value) { $string .= $this->_yamlize($key,$value,$indent); } return $string; } else { return false; } } function _dumpNode($key,$value,$indent) { if (strpos($value,"\n") !== false || strpos($value,": ") !== false || strpos($value,"- ") !== false) { $value = $this->_doLiteralBlock($value,$indent); } else { $value = $this->_doFolding($value,$indent); } if (is_bool($value)) { $value = ($value) ? "true" : "false"; } $spaces = str_repeat(' ',$indent); if (is_int($key)) { $string = $spaces.'- '.$value."\n"; } else { $string = $spaces.$key.': '.$value."\n"; } return $string; } function _doLiteralBlock($value,$indent) { $exploded = explode("\n",$value); $newValue = '|'; $indent += $this->_dumpIndent; $spaces = str_repeat(' ',$indent); foreach ($exploded as $line) { $newValue .= "\n" . $spaces . trim($line); } return $newValue; } function _doFolding($value,$indent) { if ($this->_dumpWordWrap === 0) { return $value; } if (strlen($value) > $this->_dumpWordWrap) { $indent += $this->_dumpIndent; $indent = str_repeat(' ',$indent); $wrapped = wordwrap($value,$this->_dumpWordWrap,"\n$indent"); $value = ">\n".$indent.$wrapped; } return $value; } function _getIndent($line) { preg_match('/^\s{1,}/',$line,$match); if ( ! empty($match[0])) { $indent = substr_count($match[0],' '); } else { $indent = 0; } return $indent; } function _parseLine($line) { $line = trim($line); if(!preg_match("/\\\#/", $line)) { $line = trim(preg_replace('/#.*$/', '', $line)); } $array = array(); if (preg_match('/^-(.*):$/',$line)) { $key = trim(substr(substr($line,1),0,-1)); $array[$key] = ''; } elseif ($line[0] == '-' && substr($line,0,3) != '---') { if (strlen($line) > 1) { $value = trim(substr($line,1)); $value = $this->_toType($value); $array[] = $value; } else { $array[] = array(); } } elseif (preg_match('/^(.+):/',$line,$key)) { if (preg_match('/^(["\'](.*)["\'](\s)*:)/',$line,$matches)) { $value = trim(str_replace($matches[1],'',$line)); $key = $matches[2]; } else { $explode = explode(':',$line); $key = trim($explode[0]); array_shift($explode); $value = trim(implode(':',$explode)); } $value = $this->_toType($value); if (empty($key)) { $array[] = $value; } else { $array[$key] = $value; } } return $array; } function _toType($value) { if (preg_match('/^("(.*)"|\'(.*)\')/',$value,$matches)) { $value = (string)preg_replace('/(\'\'|\\\\\')/',"'",end($matches)); $value = preg_replace('/\\\\"/','"',$value); } elseif (preg_match('/^\\[(.+)\\]$/',$value,$matches)) { $explode = $this->_inlineEscape($matches[1]); $value = array(); foreach ($explode as $v) { $value[] = $this->_toType($v); } } elseif (strpos($value,': ')!==false && !preg_match('/^{(.+)/',$value)) { $array = explode(': ',$value); $key = trim($array[0]); array_shift($array); $value = trim(implode(': ',$array)); $value = $this->_toType($value); $value = array($key => $value); } elseif (preg_match("/{(.+)}$/",$value,$matches)) { $explode = $this->_inlineEscape($matches[1]); $array = array(); foreach ($explode as $v) { $array = $array + $this->_toType($v); } $value = $array; } elseif (strtolower($value) == 'null' or $value == '' or $value == '~') { $value = NULL; } elseif (preg_match ('/^[0-9]+$/', $value)) { $value = (int)$value; } elseif (in_array(strtolower($value), array('true', 'on', '+', 'yes', 'y'))) { $value = true; } elseif (in_array(strtolower($value), array('false', 'off', '-', 'no', 'n'))) { $value = false; } elseif (is_numeric($value)) { $value = (float)$value; } else { $value = trim(preg_replace('/#(.+)$/','',$value)); } return $value; } function _inlineEscape($inline) { $saved_strings = array(); $regex = '/(?:(")|(?:\'))((?(1)[^"]+|[^\']+))(?(1)"|\')/'; if (preg_match_all($regex,$inline,$strings)) { $saved_strings = $strings[0]; $inline = preg_replace($regex,'YAMLString',$inline); } unset($regex); if (preg_match_all('/\[(.+)\]/U',$inline,$seqs)) { $inline = preg_replace('/\[(.+)\]/U','YAMLSeq',$inline); $seqs = $seqs[0]; } if (preg_match_all('/{(.+)}/U',$inline,$maps)) { $inline = preg_replace('/{(.+)}/U','YAMLMap',$inline); $maps = $maps[0]; } $explode = explode(', ',$inline); if ( ! empty($seqs)) { $i = 0; foreach ($explode as $key => $value) { if (strpos($value,'YAMLSeq') !== false) { $explode[$key] = str_replace('YAMLSeq',$seqs[$i],$value); ++$i; } } } if ( ! empty($maps)) { $i = 0; foreach ($explode as $key => $value) { if (strpos($value,'YAMLMap') !== false) { $explode[$key] = str_replace('YAMLMap',$maps[$i],$value); ++$i; } } } if ( ! empty($saved_strings)) { $i = 0; foreach ($explode as $key => $value) { while (strpos($value,'YAMLString') !== false) { $explode[$key] = preg_replace('/YAMLString/',$saved_strings[$i],$value, 1); ++$i; $value = $explode[$key]; } } } return $explode; } function _buildArray() { $trunk = array(); if ( ! isset($this->_indentSort[0])) { return $trunk; } foreach ($this->_indentSort[0] as $n) { if (empty($n->parent)) { $this->_nodeArrayizeData($n); $this->_makeReferences($n); $trunk = $this->_array_kmerge($trunk,$n->data); } } return $trunk; } function _linkReferences() { if (is_array($this->_haveRefs)) { foreach ($this->_haveRefs as $node) { if ( ! empty($node->data)) { $key = key($node->data); if (is_array($node->data[$key])) { foreach ($node->data[$key] as $k => $v) { $this->_linkRef($node,$key,$k,$v); } } else { $this->_linkRef($node,$key); } } } } return true; } function _linkRef(&$n,$key,$k = NULL,$v = NULL) { if (empty($k) && empty($v)) { if (preg_match('/^&([^ ]+)/',$n->data[$key],$matches)) { $this->_allNodes[$n->id]->ref = substr($matches[0],1); $this->_allNodes[$n->id]->data[$key] = substr($n->data[$key],strlen($matches[0])+1); } elseif (preg_match('/^\*([^ ]+)/',$n->data[$key],$matches)) { $ref = substr($matches[0],1); $this->_allNodes[$n->id]->refKey = $ref; } } elseif ( ! empty($k) && !empty($v)) { if (preg_match('/^&([^ ]+)/',$v,$matches)) { $this->_allNodes[$n->id]->ref = substr($matches[0],1); $this->_allNodes[$n->id]->data[$key][$k] = substr($v,strlen($matches[0])+1); } elseif (preg_match('/^\*([^ ]+)/',$v,$matches)) { $ref = substr($matches[0],1); $this->_allNodes[$n->id]->refKey = $ref; } } } function _gatherChildren($nid) { $return = array(); $node =& $this->_allNodes[$nid]; if (is_array ($this->_allParent[$node->id])) { foreach ($this->_allParent[$node->id] as $nodeZ) { $z =& $this->_allNodes[$nodeZ]; $this->_nodeArrayizeData($z); $this->_makeReferences($z); $return = $this->_array_kmerge($return,$z->data); } } return $return; } function _nodeArrayizeData(&$node) { if (is_array($node->data) && $node->children == true) { $childs = $this->_gatherChildren($node->id); $key = key($node->data); $key = empty($key) ? 0 : $key; if (isset ($node->data[$key])) { if (is_array($node->data[$key])) { $node->data[$key] = $this->_array_kmerge($node->data[$key],$childs); } else { $node->data[$key] = $childs; } } else { $node->data[$key] = $childs; } } elseif ( ! is_array($node->data) && $node->children == true) { $childs = $this->_gatherChildren($node->id); $node->data = array(); $node->data[] = $childs; } return true; } function _makeReferences(&$z) { if (isset($z->ref)) { $key = key($z->data); $this->ref[$z->ref] =& $z->data[$key]; } elseif (isset($z->refKey)) { if (isset($this->ref[$z->refKey])) { $key = key($z->data); $z->data[$key] =& $this->ref[$z->refKey]; } } return true; } function _array_kmerge($arr1,$arr2) { if( ! is_array($arr1)) $arr1 = array(); if( ! is_array($arr2)) $arr2 = array(); $keys = array_merge(array_keys($arr1),array_keys($arr2)); $vals = array_merge(array_values($arr1),array_values($arr2)); $ret = array(); foreach($keys as $key) { list($unused,$val) = each($vals); if (isset($ret[$key]) and is_int($key)) $ret[] = $val; else $ret[$key] = $val; } return $ret; } } class Doctrine_Parser_Exception extends Doctrine_Exception { }class Doctrine_Parser_Yml extends Doctrine_Parser { public function dumpData($array, $path = null) { try { $data = Doctrine_Parser_YamlSf::dump($array); return $this->doDump($data, $path); } catch(InvalidArgumentException $e) { $rethrowed_exception = new Doctrine_Parser_Exception($e->getMessage(), $e->getCode()); throw $rethrowed_exception; } } public function loadData($path) { try { $contents = $this->doLoad($path); $array = Doctrine_Parser_YamlSf::load($contents); return $array; } catch(InvalidArgumentException $e) { $rethrowed_exception = new Doctrine_Parser_Exception($e->getMessage(), $e->getCode()); throw $rethrowed_exception; } } }class Doctrine_Parser_Serialize extends Doctrine_Parser { public function dumpData($array, $path = null) { $data = serialize($array); return $this->doDump($data, $path); } public function loadData($path) { $contents = $this->doLoad($path); return unserialize($contents); } }class Doctrine_Parser_YamlSf { public static function load($input) { $file = ''; if (strpos($input, "\n") === false && is_file($input)) { $file = $input; ob_start(); $retval = include($input); $content = ob_get_clean(); $input = is_array($retval) ? $retval : $content; } if (is_array($input)) { return $input; } $yaml = new Doctrine_Parser_YamlSf_Parser(); try { $ret = $yaml->parse($input); } catch (Exception $e) { throw new InvalidArgumentException(sprintf('Unable to parse %s: %s', $file ? sprintf('file "%s"', $file) : 'string', $e->getMessage())); } return $ret; } public static function dump($array, $inline = 4) { $yaml = new Doctrine_Parser_YamlSf_Dumper(); return $yaml->dump($array, $inline); } }class Doctrine_Parser_Json extends Doctrine_Parser { public function dumpData($array, $path = null) { $data = json_encode($array); return $this->doDump($data, $path); } public function loadData($path) { $contents = $this->doLoad($path); $json = json_decode($contents); return $json; } } class Doctrine_DataType { public function __construct() { } public function getName() { } public function getDefaultLength() { } } abstract class Doctrine_Template extends Doctrine_Record_Abstract { protected $_invoker; protected $_plugin; public function setTable(Doctrine_Table $table) { $this->_table = $table; } public function getTable() { return $this->_table; } public function setInvoker(Doctrine_Record $invoker) { $this->_invoker = $invoker; } public function getInvoker() { return $this->_invoker; } public function addChild(Doctrine_Template $template) { $this->_plugin->addChild($template); return $this; } public function getPlugin() { return $this->_plugin; } public function get($name) { throw new Doctrine_Exception("Templates doesn't support accessors."); } public function set($name, $value) { throw new Doctrine_Exception("Templates doesn't support accessors."); } public function setUp() { } public function setTableDefinition() { } }class Doctrine_RawSql_Exception extends Doctrine_Exception { }abstract class Doctrine_Record_Filter { protected $_table; public function setTable(Doctrine_Table $table) { $this->_table = $table; } public function getTable() { return $this->_table; } abstract public function filterSet(Doctrine_Record $record, $name, $value); abstract public function filterGet(Doctrine_Record $record, $name); }class Doctrine_Record_Filter_Compound extends Doctrine_Record_Filter { protected $_aliases = array(); public function __construct(array $aliases) { $this->_aliases = $aliases; } public function init() { foreach ($this->_aliases as $alias) { $this->_table->getRelation($alias); } } public function filterSet(Doctrine_Record $record, $name, $value) { foreach ($this->_aliases as $alias) { if ( ! $record->exists()) { if (isset($record[$alias][$name])) { $record[$alias][$name] = $value; return $record; } } else { if (($ref = $record->reference($alias)) !== null) { if (isset($ref[$name])) { $ref[$name] = $value; } return $record; } } } } public function filterGet(Doctrine_Record $record, $name) { foreach ($this->_aliases as $alias) { if ( ! $record->exists()) { if (isset($record[$alias][$name])) { return $record[$alias][$name]; } } else { if (($ref = $record->reference($alias)) !== null) { if (isset($ref[$name])) { return $ref[$name]; } } } } } }class Doctrine_Record_Filter_Standard extends Doctrine_Record_Filter { public function filterSet(Doctrine_Record $record, $name, $value) { throw new Doctrine_Record_Exception(sprintf('Unknown record property / related component "%s" on "%s"', $name, get_class($record))); } public function filterGet(Doctrine_Record $record, $name) { throw new Doctrine_Record_Exception(sprintf('Unknown record property / related component "%s" on "%s"', $name, get_class($record))); } }class Doctrine_Record_Exception extends Doctrine_Exception { }class Doctrine_Record_State_Exception extends Doctrine_Record_Exception { }class Doctrine_Record_Listener implements Doctrine_Record_Listener_Interface { public function preSerialize(Doctrine_Event $event) { } public function postSerialize(Doctrine_Event $event) { } public function preUnserialize(Doctrine_Event $event) { } public function postUnserialize(Doctrine_Event $event) { } public function preDqlSelect(Doctrine_Event $event) { } public function preSave(Doctrine_Event $event) { } public function postSave(Doctrine_Event $event) { } public function preDqlDelete(Doctrine_Event $event) { } public function preDelete(Doctrine_Event $event) { } public function postDelete(Doctrine_Event $event) { } public function preDqlUpdate(Doctrine_Event $event) { } public function preUpdate(Doctrine_Event $event) { } public function postUpdate(Doctrine_Event $event) { } public function preInsert(Doctrine_Event $event) { } public function postInsert(Doctrine_Event $event) { } public function preHydrate(Doctrine_Event $event) { } public function postHydrate(Doctrine_Event $event) { } public function preValidate(Doctrine_Event $event) { } public function postValidate(Doctrine_Event $event) { } }class Doctrine_Record_Iterator extends ArrayIterator { private $record; private static $null; public function __construct(Doctrine_Record $record) { $this->record = $record; parent::__construct($record->getData()); } public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public function current() { $value = parent::current(); if ($value === self::$null) { return null; } else { return $value; } } }class Doctrine_Record_Listener_Chain extends Doctrine_Access implements Doctrine_Record_Listener_Interface { protected $_listeners = array(); public function add($listener, $name = null) { if ( ! ($listener instanceof Doctrine_Record_Listener_Interface) && ! ($listener instanceof Doctrine_Overloadable)) { throw new Doctrine_EventListener_Exception("Couldn't add eventlistener. Record listeners should implement either Doctrine_Record_Listener_Interface or Doctrine_Overloadable"); } if ($name === null) { $this->_listeners[] = $listener; } else { $this->_listeners[$name] = $listener; } } public function get($key) { if ( ! isset($this->_listeners[$key])) { return null; } return $this->_listeners[$key]; } public function set($key, $listener) { $this->_listeners[$key] = $listener; } public function preSerialize(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preSerialize($event); } } public function postSerialize(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postSerialize($event); } } public function preUnserialize(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preUnserialize($event); } } public function postUnserialize(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postUnserialize($event); } } public function preDqlSelect(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preDqlSelect($event); } } public function preSave(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preSave($event); } } public function postSave(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postSave($event); } } public function preDqlDelete(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preDqlDelete($event); } } public function preDelete(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preDelete($event); } } public function postDelete(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postDelete($event); } } public function preDqlUpdate(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preDqlUpdate($event); } } public function preUpdate(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preUpdate($event); } } public function postUpdate(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postUpdate($event); } } public function preInsert(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preInsert($event); } } public function postInsert(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postInsert($event); } } public function preHydrate(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preHydrate($event); } } public function postHydrate(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postHydrate($event); } } public function preValidate(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->preValidate($event); } } public function postValidate(Doctrine_Event $event) { foreach ($this->_listeners as $listener) { $listener->postValidate($event); } } }class Doctrine_EventListener implements Doctrine_EventListener_Interface { public function preClose(Doctrine_Event $event) { } public function postClose(Doctrine_Event $event) { } public function onCollectionDelete(Doctrine_Collection $collection) { } public function onPreCollectionDelete(Doctrine_Collection $collection) { } public function onOpen(Doctrine_Connection $connection) { } public function preTransactionCommit(Doctrine_Event $event) { } public function postTransactionCommit(Doctrine_Event $event) { } public function preTransactionRollback(Doctrine_Event $event) { } public function postTransactionRollback(Doctrine_Event $event) { } public function preTransactionBegin(Doctrine_Event $event) { } public function postTransactionBegin(Doctrine_Event $event) { } public function preSavepointCommit(Doctrine_Event $event) { } public function postSavepointCommit(Doctrine_Event $event) { } public function preSavepointRollback(Doctrine_Event $event) { } public function postSavepointRollback(Doctrine_Event $event) { } public function preSavepointCreate(Doctrine_Event $event) { } public function postSavepointCreate(Doctrine_Event $event) { } public function postConnect(Doctrine_Event $event) { } public function preConnect(Doctrine_Event $event) { } public function preQuery(Doctrine_Event $event) { } public function postQuery(Doctrine_Event $event) { } public function prePrepare(Doctrine_Event $event) { } public function postPrepare(Doctrine_Event $event) { } public function preExec(Doctrine_Event $event) { } public function postExec(Doctrine_Event $event) { } public function preError(Doctrine_Event $event) { } public function postError(Doctrine_Event $event) { } public function preFetch(Doctrine_Event $event) { } public function postFetch(Doctrine_Event $event) { } public function preFetchAll(Doctrine_Event $event) { } public function postFetchAll(Doctrine_Event $event) { } public function preStmtExecute(Doctrine_Event $event) { } public function postStmtExecute(Doctrine_Event $event) { } } class Doctrine_Search_Parser { public function parse($file) { $contents = file_get_contents($file); return array('url' => $file, 'contents' => $contents); } }class Doctrine_Search extends Doctrine_Record_Generator { const INDEX_FILES = 0; const INDEX_TABLES = 1; protected $_options = array('generateFiles' => false, 'type' => self::INDEX_TABLES, 'className' => '%CLASS%Index', 'generatePath' => false, 'table' => null, 'batchUpdates' => false, 'pluginTable' => false, 'fields' => array(), 'connection' => null, 'children' => array()); public function __construct(array $options) { $this->_options = Doctrine_Lib::arrayDeepMerge($this->_options, $options); if ( ! isset($this->_options['analyzer'])) { $this->_options['analyzer'] = 'Doctrine_Search_Analyzer_Standard'; } $this->_options['analyzer'] = new $this->_options['analyzer']; if ( ! isset($this->_options['connection'])) { $this->_options['connection'] = Doctrine_Manager::connection(); } } public function search($string, $query = null) { $q = new Doctrine_Search_Query($this->_table); if ($query instanceof Doctrine_Query) { $q->query($string, false); $newQuery = $query->copy(); $query->getSql(); $newQuery->addWhere($query->getRootAlias() . '.id IN(' . $q->getSql() . ')', $q->getParams()); return $newQuery; } else { $q->query($string); return $this->_options['connection']->fetchAll($q->getSql(), $q->getParams()); } } public function analyze($text) { return $this->_options['analyzer']->analyze($text); } public function updateIndex(array $data) { $this->initialize($this->_options['table']); $fields = $this->getOption('fields'); $class = $this->getOption('className'); $name = $this->getOption('table')->getComponentName(); $conn = $this->getOption('table')->getConnection(); $identifier = $this->_options['table']->getIdentifier(); $q = Doctrine_Query::create()->delete() ->from($class); foreach ((array) $identifier as $id) { $q->addWhere($id . ' = ?', array($data[$id])); } $q->execute(); if ($this->_options['batchUpdates'] === true) { $index = new $class(); foreach ((array) $this->_options['table']->getIdentifier() as $id) { $index->$id = $data[$id]; } $index->save(); } else { foreach ($fields as $field) { $value = isset($data[$field]) ? $data[$field] : null; $terms = $this->analyze($value); foreach ($terms as $pos => $term) { $index = new $class(); $index->keyword = $term; $index->position = $pos; $index->field = $field; foreach ((array) $this->_options['table']->getIdentifier() as $id) { $index->$id = $data[$id]; } $index->save(); } } } } public function readTableData($limit = null, $offset = null) { $this->initialize($this->_options['table']); $conn = $this->_options['table']->getConnection(); $tableName = $this->_options['table']->getTableName(); $id = $this->_options['table']->getIdentifier(); $query = 'SELECT * FROM ' . $conn->quoteIdentifier($tableName) . ' WHERE ' . $conn->quoteIdentifier($id) . ' IN (SELECT ' . $conn->quoteIdentifier($id) . ' FROM ' . $conn->quoteIdentifier($this->_table->getTableName()) . ' WHERE keyword IS NULL) OR ' . $conn->quoteIdentifier($id) . ' NOT IN (SELECT ' . $conn->quoteIdentifier($id) . ' FROM ' . $conn->quoteIdentifier($this->_table->getTableName()) . ')'; $query = $conn->modifyLimitQuery($query, $limit, $offset); return $conn->fetchAll($query); } public function batchUpdateIndex($limit = null, $offset = null) { $this->initialize($this->_options['table']); $id = $this->_options['table']->getIdentifier(); $class = $this->_options['className']; $fields = $this->_options['fields']; $conn = $this->_options['connection']; try { $conn->beginTransaction(); $rows = $this->readTableData($limit, $offset); $ids = array(); foreach ($rows as $row) { $ids[] = $row[$id]; } $conn->exec('DELETE FROM ' . $conn->quoteIdentifier($this->_table->getTableName()) . ' WHERE ' . $conn->quoteIdentifier($id) . ' IN (' . implode(', ', $ids) . ')'); foreach ($rows as $row) { foreach ($fields as $field) { $data = $row[$field]; $terms = $this->analyze($data); foreach ($terms as $pos => $term) { $index = new $class(); $index->keyword = $term; $index->position = $pos; $index->field = $field; foreach ((array) $id as $identifier) { $index->$identifier = $row[$identifier]; } $index->save(); } } } $conn->commit(); } catch (Doctrine_Exception $e) { $conn->rollback(); } } public function setTableDefinition() { if ( ! isset($this->_options['table'])) { throw new Doctrine_Record_Exception("Unknown option 'table'."); } $componentName = $this->_options['table']->getComponentName(); $className = $this->getOption('className'); if (class_exists($className)) { return false; } $columns = array('keyword' => array('type' => 'string', 'length' => 200, 'primary' => true, ), 'field' => array('type' => 'string', 'length' => 50, 'primary' => true), 'position' => array('type' => 'integer', 'length' => 8, 'primary' => true, )); $this->hasColumns($columns); } } class Doctrine_Search_File extends Doctrine_Search { public function __construct(array $options = array()) { parent::__construct($options); if ( ! isset($this->_options['resource'])) { $table = new Doctrine_Table('File', Doctrine_Manager::connection()); $table->setColumn('url', 'string', 255, array('primary' => true)); } if (empty($this->_options['fields'])) { $this->_options['fields'] = array('url', 'content'); } $this->initialize($table); } public function buildRelation() { } public function indexDirectory($dir) { $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($it as $file) { if (strpos($file, DIRECTORY_SEPARATOR . '.svn') !== false) { continue; } $this->updateIndex(array('url' => $file->getPathName(), 'content' => file_get_contents($file))); } } } class Doctrine_Search_Listener extends Doctrine_Record_Listener { protected $_search; public function __construct(Doctrine_Search $search) { $this->_search = $search; } public function preUpdate(Doctrine_Event $event) { } public function postUpdate(Doctrine_Event $event) { $record = $event->getInvoker(); $this->_search->updateIndex($record->toArray()); } public function postInsert(Doctrine_Event $event) { $record = $event->getInvoker(); $this->_search->updateIndex($record->toArray()); } }class Doctrine_Search_Analyzer implements Doctrine_Search_Analyzer_Interface { public function analyze($text) { } }class Doctrine_Search_Indexer_Dir { public function add($dir) { if ( ! file_exists($dir)) { throw new Doctrine_Search_Indexer_Exception('Unknown directory ' . $dir); } $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($it as $file) { $this->indexFile($file); } } }class Doctrine_Search_Exception extends Doctrine_Exception { }class Doctrine_Search_Indexer_Exception extends Doctrine_Search_Exception { }class Doctrine_Search_Record extends Doctrine_Template { public function setTableDefinition() { $this->hasColumn('keyword', 'string', 250, array('notnull' => true)); $this->hasColumn('field', 'string', 50, array('notnull' => true)); $this->hasColumn('position', 'integer', 8); } public function setUp() { $this->hasOne('[Component]', array('onDelete' => 'CASCADE')); } }class Doctrine_Search_Indexer { public function indexDirectory($dir) { if ( ! file_exists($dir)) { throw new Doctrine_Search_Indexer_Exception('Unknown directory ' . $dir); } $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY); $files = array(); foreach ($it as $file) { $name = $file->getPathName(); if (strpos($name, '.svn') === false) { $files[] = $name; } } $q = new Doctrine_Query(); $q->delete() ->from('Doctrine_File f') ->where('f.url LIKE ?', array($dir . '%')) ->execute(); $q = new Doctrine_Query(); $q->delete() ->from('Doctrine_File_Index i') ->where('i.file_id = ?') ->execute(); $conn = Doctrine_Manager::connection(); $coll = new Doctrine_Collection('Doctrine_File'); foreach ($files as $file) { $coll[]->url = $file; } $coll->save(); } }class Doctrine_Search_Query { protected $_table = array(); protected $_sql = ''; protected $_params = array(); protected $_words = array(); protected $_tokenizer; protected $_condition; public function __construct($table) { if (is_string($table)) { $table = Doctrine::getTable($table); } else { if ( ! $table instanceof Doctrine_Table) { throw new Doctrine_Search_Exception('Invalid argument type. Expected instance of Doctrine_Table.'); } } $this->_tokenizer = new Doctrine_Query_Tokenizer(); $this->_table = $table; $foreignId = current(array_diff($this->_table->getColumnNames(), array('keyword', 'field', 'position'))); $this->_condition = $foreignId . ' %s (SELECT ' . $foreignId . ' FROM ' . $this->_table->getTableName() . ' WHERE '; } public function query($text, $includeRelevance = true) { $text = trim($text); $foreignId = current(array_diff($this->_table->getColumnNames(), array('keyword', 'field', 'position'))); $weighted = false; if (strpos($text, '^') === false) { if ($includeRelevance) { $select = 'SELECT COUNT(keyword) AS relevance, ' . $foreignId; } else { $select = 'SELECT ' . $foreignId; } } else { if ($includeRelevance) { $select = 'SELECT SUM(sub_relevance) AS relevance, ' . $foreignId; } else { $select = 'SELECT ' . $foreignId; } } $from = 'FROM ' . $this->_table->getTableName(); $where = 'WHERE '; $where .= $this->parseClause($text); $groupby = 'GROUP BY ' . $foreignId; if ($includeRelevance) { $orderBy = 'ORDER BY relevance DESC'; } else { $orderBy = null; } $this->_sql = $select . ' ' . $from . ' ' . $where . ' ' . $groupby; if (isset($orderBy) && $orderBy !== null) { $this->_sql .= ' ' . $orderBy; } } public function parseClause($originalClause, $recursive = false) { $clause = $this->_tokenizer->bracketTrim($originalClause); $brackets = false; if ($clause !== $originalClause) { $brackets = true; } $foreignId = current(array_diff($this->_table->getColumnNames(), array('keyword', 'field', 'position'))); $terms = $this->_tokenizer->sqlExplode($clause, ' OR ', '(', ')'); $ret = array(); if (count($terms) > 1) { $leavesOnly = true; foreach ($terms as $k => $term) { if ($this->isExpression($term)) { $ret[$k] = $this->parseClause($term, true); $leavesOnly = false; } else { $ret[$k] = $this->parseTerm($term); } } $return = implode(' OR ', $ret); if ($leavesOnly && $recursive) { $return = sprintf($this->_condition, 'IN') . $return . ')'; $brackets = false; } } else { $terms = $this->_tokenizer->sqlExplode($clause, ' ', '(', ')'); if (count($terms) === 1 && ! $recursive) { $return = $this->parseTerm($clause); } else { foreach ($terms as $k => $term) { $term = trim($term); if ($term === 'AND') { continue; } if (substr($term, 0, 1) === '-') { $operator = 'NOT IN'; $term = substr($term, 1); } else { $operator = 'IN'; } if ($this->isExpression($term)) { $ret[$k] = $this->parseClause($term, true); } else { $ret[$k] = sprintf($this->_condition, $operator) . $this->parseTerm($term) . ')'; } } $return = implode(' AND ', $ret); } } if ($brackets) { return '(' . $return . ')'; } else { return $return; } } public function isExpression($term) { if (strpos($term, '(') !== false) { return true; } else { $terms = $this->_tokenizer->quoteExplode($term); return (count($terms) > 1); } } public function parseTerm($term) { $negation = false; if (strpos($term, "'") === false) { $where = $this->parseWord($term); } else { $term = trim($term, "' "); $terms = $this->_tokenizer->quoteExplode($term); $where = $this->parseWord($terms[0]); foreach ($terms as $k => $word) { if ($k === 0) { continue; } $where .= ' AND (position + ' . $k . ') = (SELECT position FROM ' . $this->_table->getTableName() . ' WHERE ' . $this->parseWord($word) . ')'; } } return $where; } public function parseWord($word) { $this->_words[] = str_replace('*', '', $word); if (strpos($word, '?') !== false || strpos($word, '*') !== false) { $word = str_replace('*', '%', $word); $where = 'keyword LIKE ?'; $params = array($word); } else { $where = 'keyword = ?'; } $this->_params[] = $word; return $where; } public function getWords() { return $this->_words; } public function getParams() { return $this->_params; } public function getSql() { return $this->_sql; } } class Doctrine_Search_Analyzer_Exception extends Doctrine_Search_Exception { }class Doctrine_Search_Analyzer_Standard implements Doctrine_Search_Analyzer_Interface { protected static $_stopwords = array( '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'a', 'about', 'after', 'all', 'almost', 'along', 'also', 'although', 'amp', 'an', 'and', 'another', 'any', 'are', 'area', 'arent', 'around', 'as', 'at', 'available', 'back', 'be', 'because', 'been', 'before', 'being', 'best', 'better', 'big', 'bit', 'both', 'but', 'by', 'c', 'came', 'can', 'capable', 'control', 'could', 'course', 'd', 'dan', 'day', 'decided', 'did', 'didn', 'different', 'div', 'do', 'doesn', 'don', 'down', 'drive', 'e', 'each', 'easily', 'easy', 'edition', 'either', 'end', 'enough', 'even', 'every', 'example', 'few', 'find', 'first', 'for', 'found', 'from', 'get', 'go', 'going', 'good', 'got', 'gt', 'had', 'hard', 'has', 'have', 'he', 'her', 'here', 'how', 'i', 'if', 'in', 'into', 'is', 'isn', 'it', 'just', 'know', 'last', 'left', 'li', 'like', 'little', 'll', 'long', 'look', 'lot', 'lt', 'm', 'made', 'make', 'many', 'mb', 'me', 'menu', 'might', 'mm', 'more', 'most', 'much', 'my', 'name', 'nbsp', 'need', 'new', 'no', 'not', 'now', 'number', 'of', 'off', 'old', 'on', 'one', 'only', 'or', 'original', 'other', 'our', 'out', 'over', 'part', 'place', 'point', 'pretty', 'probably', 'problem', 'put', 'quite', 'quot', 'r', 're', 'really', 'results', 'right', 's', 'same', 'saw', 'see', 'set', 'several', 'she', 'sherree', 'should', 'since', 'size', 'small', 'so', 'some', 'something', 'special', 'still', 'stuff', 'such', 'sure', 'system', 't', 'take', 'than', 'that', 'the', 'their', 'them', 'then', 'there', 'these', 'they', 'thing', 'things', 'think', 'this', 'those', 'though', 'through', 'time', 'to', 'today', 'together', 'too', 'took', 'two', 'up', 'us', 'use', 'used', 'using', 've', 'very', 'want', 'was', 'way', 'we', 'well', 'went', 'were', 'what', 'when', 'where', 'which', 'while', 'white', 'who', 'will', 'with', 'would', 'yet', 'you', 'your', 'yours' ); public function analyze($text) { $text = preg_replace('/[\'`"]/', '', $text); $text = preg_replace('/[^A-Za-z0-9]/', ' ', $text); $text = str_replace('  ', ' ', $text); $terms = explode(' ', $text); $ret = array(); if ( ! empty($terms)) { foreach ($terms as $i => $term) { if (empty($term)) { continue; } $lower = strtolower(trim($term)); if (in_array($lower, self::$_stopwords)) { continue; } $ret[$i] = $lower; } } return $ret; } } class Doctrine_Search_Scorer { protected $_resultSet; protected $_components = array(); public function __construct($resultSet) { $this->_resultSet = $resultSet; } public function addComponent($component) { $this->_components[] = $component; } public function process() { foreach ($this->_resultSet as $mainRow) { if (isset($mainRow[$component])) { if ( ! is_array($mainRow[$component])) { throw new Doctrine_Search_Exception('Wrong data type in result set.'); } foreach ($mainRow[$component] as $indexRow) { } } } } }class Doctrine_Transaction_Pgsql extends Doctrine_Transaction { protected function createSavePoint($savepoint) { $query = 'SAVEPOINT ' . $savepoint; return $this->conn->execute($query); } protected function releaseSavePoint($savepoint) { $query = 'RELEASE SAVEPOINT ' . $savepoint; return $this->conn->execute($query); } protected function rollbackSavePoint($savepoint) { $query = 'ROLLBACK TO SAVEPOINT ' . $savepoint; return $this->conn->execute($query); } public function setIsolation($isolation) { switch ($isolation) { case 'READ UNCOMMITTED': case 'READ COMMITTED': case 'REPEATABLE READ': case 'SERIALIZABLE': break; default: throw new Doctrine_Transaction_Exception('Isolation level '.$isolation.' is not supported.'); } $query = 'SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL ' . $isolation; return $this->conn->execute($query); } }class Doctrine_Transaction_Exception extends Doctrine_Exception { }class Doctrine_Transaction_Mock extends Doctrine_Transaction { }class Doctrine_Cli { protected $_tasks = array(), $_taskInstance = null, $_formatter = null, $_scriptName = null, $_message = null, $_config = array(); public function __construct($config = array()) { $this->_config = $config; $this->_formatter = new Doctrine_Cli_AnsiColorFormatter(); $this->loadTasks(); } public function notify($notification = null, $style = 'HEADER') { echo $this->_formatter->format($this->_taskInstance->getTaskName(), 'INFO') . ' - ' . $this->_formatter->format($notification, $style) . "\n"; } public function notifyException($exception) { echo $this->_formatter->format($exception->getMessage(), 'ERROR') . "\n"; } public function run($args) { try { $this->_run($args); } catch (Exception $exception) { $this->notifyException($exception); } } protected function _getTaskClassFromArgs($args) { $taskName = str_replace('-', '_', $args[1]); $taskClass = 'Doctrine_Task_' . Doctrine_Inflector::classify($taskName); return $taskClass; } protected function _run($args) { $this->_scriptName = $args[0]; $arg1 = isset($args[1]) ? $args[1]:null; if ( ! $arg1 || $arg1 == 'help') { echo $this->printTasks(null, $arg1 == 'help' ? true:false); return; } if (isset($args[1]) && isset($args[2]) && $args[2] === 'help') { echo $this->printTasks($args[1], true); return; } $taskClass = $this->_getTaskClassFromArgs($args); if ( ! class_exists($taskClass)) { throw new Doctrine_Cli_Exception('Cli task could not be found: ' . $taskClass); } unset($args[0]); unset($args[1]); $this->_taskInstance = new $taskClass($this); $args = $this->prepareArgs($args); $this->_taskInstance->setArguments($args); try { if ($this->_taskInstance->validate()) { $this->_taskInstance->execute(); } else { echo $this->_formatter->format('Requires arguments missing!!', 'ERROR') . "\n\n"; echo $this->printTasks($arg1, true); } } catch (Exception $e) { throw new Doctrine_Cli_Exception($e->getMessage()); } } protected function prepareArgs($args) { $taskInstance = $this->_taskInstance; $args = array_values($args); $prepared = array(); $requiredArguments = $taskInstance->getRequiredArguments(); foreach ($requiredArguments as $key => $arg) { $prepared[$arg] = null; } $optionalArguments = $taskInstance->getOptionalArguments(); foreach ($optionalArguments as $key => $arg) { $prepared[$arg] = null; } if (is_array($this->_config) && !empty($this->_config)) { foreach ($this->_config as $key => $value) { if (array_key_exists($key, $prepared)) { $prepared[$key] = $value; } } } $copy = $args; foreach ($prepared as $key => $value) { if ( ! $value && !empty($copy)) { $prepared[$key] = $copy[0]; unset($copy[0]); $copy = array_values($copy); } } return $prepared; } public function printTasks($task = null, $full = false) { $task = Doctrine_Inflector::classify(str_replace('-', '_', $task)); $tasks = $this->getLoadedTasks(); echo $this->_formatter->format("Doctrine Command Line Interface", 'HEADER') . "\n\n"; foreach ($tasks as $taskName) { if ($task != null && strtolower($task) != strtolower($taskName)) { continue; } $className = 'Doctrine_Task_' . $taskName; $taskInstance = new $className(); $taskInstance->taskName = str_replace('_', '-', Doctrine_Inflector::tableize($taskName)); $syntax = $this->_scriptName . ' ' . $taskInstance->getTaskName(); echo $this->_formatter->format($syntax, 'INFO'); if ($full) { echo " - " . $taskInstance->getDescription() . "\n"; $args = null; $requiredArguments = $taskInstance->getRequiredArgumentsDescriptions(); if ( ! empty($requiredArguments)) { foreach ($requiredArguments as $name => $description) { $args .= $this->_formatter->format($name, "ERROR"); if (isset($this->_config[$name])) { $args .= " - " . $this->_formatter->format($this->_config[$name], 'COMMENT'); } else { $args .= " - " . $description; } $args .= "\n"; } } $optionalArguments = $taskInstance->getOptionalArgumentsDescriptions(); if ( ! empty($optionalArguments)) { foreach ($optionalArguments as $name => $description) { $args .= $name . ' - ' . $description."\n"; } } if ($args) { echo "\n" . $this->_formatter->format('Arguments:', 'HEADER') . "\n" . $args; } } echo "\n"; } } public function loadTasks($directory = null) { if ($directory === null) { $directory = Doctrine::getPath() . DIRECTORY_SEPARATOR . 'Doctrine' . DIRECTORY_SEPARATOR . 'Task'; } $parent = new ReflectionClass('Doctrine_Task'); $tasks = array(); if (is_dir($directory)) { foreach ((array) $directory as $dir) { $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($it as $file) { $e = explode('.', $file->getFileName()); if (end($e) === 'php' && strpos($file->getFileName(), '.inc') === false) { $className = 'Doctrine_Task_' . $e[0]; if ( ! class_exists($className)) { require_once($file->getPathName()); $class = new ReflectionClass($className); if ($class->isSubClassOf($parent)) { $tasks[$e[0]] = $e[0]; } } } } } } $classes = get_declared_classes(); foreach ($classes as $className) { $class = new Reflectionclass($className); if ($class->isSubClassOf($parent)) { $task = str_replace('Doctrine_Task_', '', $className); $tasks[$task] = $task; } } $this->_tasks = array_merge($this->_tasks, $tasks); return $this->_tasks; } public function getLoadedTasks() { $parent = new ReflectionClass('Doctrine_Task'); $classes = get_declared_classes(); $tasks = array(); foreach ($classes as $className) { $class = new ReflectionClass($className); if ($class->isSubClassOf($parent)) { $task = str_replace('Doctrine_Task_', '', $className); $tasks[$task] = $task; } } return array_merge($this->_tasks, $tasks); } }class Doctrine_Column extends Doctrine_Access implements IteratorAggregate, Countable { protected $_definition = array( 'type' => null, 'length' => 0, ); public function __construct(array $definition = array()) { $this->_definition = $definition; } public function getDefinition() { return $this->_definition; } public function contains($name) { return isset($this->_definition[$name]); } public function get($name) { if ( ! isset($this->_definition[$name])) { return null; } return $this->_definition[$name]; } public function set($name, $value) { $this->_definition[$name] = $value; } public function getEnumValues() { if (isset($this->_definition['values'])) { return $this->_definition['values']; } else { return array(); } } public function enumValue($index) { if ($index instanceof Doctrine_Null) { return $index; } return isset($this->_definition['values'][$index]) ? $this->_definition['values'][$index] : $index; } public function enumIndex($field, $value) { $values = $this->getEnumValues($field); return array_search($value, $values); } public function count() { return count($this->_definition); } public function getIterator() { return new ArrayIterator($this->_definition); } }class Doctrine_Adapter { const ATTR_AUTOCOMMIT = 0; const ATTR_CASE = 8; const ATTR_CLIENT_VERSION = 5; const ATTR_CONNECTION_STATUS = 7; const ATTR_CURSOR = 10; const ATTR_CURSOR_NAME = 9; const ATTR_DRIVER_NAME = 16; const ATTR_ERRMODE = 3; const ATTR_FETCH_CATALOG_NAMES = 15; const ATTR_FETCH_TABLE_NAMES = 14; const ATTR_MAX_COLUMN_LEN = 18; const ATTR_ORACLE_NULLS = 11; const ATTR_PERSISTENT = 12; const ATTR_PREFETCH = 1; const ATTR_SERVER_INFO = 6; const ATTR_SERVER_VERSION = 4; const ATTR_STATEMENT_CLASS = 13; const ATTR_STRINGIFY_FETCHES = 17; const ATTR_TIMEOUT = 2; const CASE_LOWER = 2; const CASE_NATURAL = 0; const CASE_UPPER = 1; const CURSOR_FWDONLY = 0; const CURSOR_SCROLL = 1; const ERR_ALREADY_EXISTS = NULL; const ERR_CANT_MAP = NULL; const ERR_CONSTRAINT = NULL; const ERR_DISCONNECTED = NULL; const ERR_MISMATCH = NULL; const ERR_NO_PERM = NULL; const ERR_NONE = '00000'; const ERR_NOT_FOUND = NULL; const ERR_NOT_IMPLEMENTED = NULL; const ERR_SYNTAX = NULL; const ERR_TRUNCATED = NULL; const ERRMODE_EXCEPTION = 2; const ERRMODE_SILENT = 0; const ERRMODE_WARNING = 1; const FETCH_ASSOC = 2; const FETCH_BOTH = 4; const FETCH_BOUND = 6; const FETCH_CLASS = 8; const FETCH_CLASSTYPE = 262144; const FETCH_COLUMN = 7; const FETCH_FUNC = 10; const FETCH_GROUP = 65536; const FETCH_INTO = 9; const FETCH_LAZY = 1; const FETCH_NAMED = 11; const FETCH_NUM = 3; const FETCH_OBJ = 5; const FETCH_ORI_ABS = 4; const FETCH_ORI_FIRST = 2; const FETCH_ORI_LAST = 3; const FETCH_ORI_NEXT = 0; const FETCH_ORI_PRIOR = 1; const FETCH_ORI_REL = 5; const FETCH_SERIALIZE = 524288; const FETCH_UNIQUE = 196608; const NULL_EMPTY_STRING = 1; const NULL_NATURAL = 0; const NULL_TO_STRING = NULL; const PARAM_BOOL = 5; const PARAM_INPUT_OUTPUT = -2147483648; const PARAM_INT = 1; const PARAM_LOB = 3; const PARAM_NULL = 0; const PARAM_STMT = 4; const PARAM_STR = 2; }abstract class Doctrine_Configurable extends Doctrine_Locator_Injectable { protected $attributes = array(); protected $parent; protected $_impl = array(); protected $_params = array(); public function getAttributeFromString($stringAttributeName) { if (is_string($stringAttributeName)) { $upper = strtoupper($stringAttributeName); $const = 'Doctrine::ATTR_' . $upper; if (defined($const)) { return constant($const); } else { throw new Doctrine_Exception('Unknown attribute: "' . $stringAttributeName . '"'); } } else { return false; } } public function getAttributeValueFromString($stringAttributeName, $stringAttributeValueName) { $const = 'Doctrine::' . strtoupper($stringAttributeName) . '_' . strtoupper($stringAttributeValueName); if (defined($const)) { return constant($const); } else { throw new Doctrine_Exception('Unknown attribute value: "' . $const . '"'); } } public function setAttribute($attribute, $value) { if (is_string($attribute)) { $stringAttribute = $attribute; $attribute = $this->getAttributeFromString($attribute); $this->_state = $attribute; } if (is_string($value) && isset($stringAttribute)) { $value = $this->getAttributeValueFromString($stringAttribute, $value); } switch ($attribute) { case Doctrine::ATTR_FETCHMODE: throw new Doctrine_Exception('Deprecated attribute. See http://www.phpdoctrine.org/documentation/manual?chapter=configuration'); case Doctrine::ATTR_LISTENER: $this->setEventListener($value); break; case Doctrine::ATTR_COLL_KEY: if ( ! ($this instanceof Doctrine_Table)) { throw new Doctrine_Exception("This attribute can only be set at table level."); } if ($value !== null && ! $this->hasField($value)) { throw new Doctrine_Exception("Couldn't set collection key attribute. No such field '$value'."); } break; case Doctrine::ATTR_CACHE: case Doctrine::ATTR_RESULT_CACHE: case Doctrine::ATTR_QUERY_CACHE: if ($value !== null) { if ( ! ($value instanceof Doctrine_Cache_Interface)) { throw new Doctrine_Exception('Cache driver should implement Doctrine_Cache_Interface'); } } break; case Doctrine::ATTR_VALIDATE: case Doctrine::ATTR_QUERY_LIMIT: case Doctrine::ATTR_QUOTE_IDENTIFIER: case Doctrine::ATTR_PORTABILITY: case Doctrine::ATTR_DEFAULT_TABLE_TYPE: case Doctrine::ATTR_EMULATE_DATABASE: case Doctrine::ATTR_USE_NATIVE_ENUM: case Doctrine::ATTR_DEFAULT_SEQUENCE: case Doctrine::ATTR_EXPORT: case Doctrine::ATTR_DECIMAL_PLACES: case Doctrine::ATTR_LOAD_REFERENCES: case Doctrine::ATTR_RECORD_LISTENER: case Doctrine::ATTR_THROW_EXCEPTIONS: case Doctrine::ATTR_DEFAULT_PARAM_NAMESPACE: case Doctrine::ATTR_AUTOLOAD_TABLE_CLASSES: case Doctrine::ATTR_MODEL_LOADING: case Doctrine::ATTR_RESULT_CACHE_LIFESPAN: case Doctrine::ATTR_QUERY_CACHE_LIFESPAN: case Doctrine::ATTR_RECURSIVE_MERGE_FIXTURES; case Doctrine::ATTR_USE_DQL_CALLBACKS; case Doctrine::ATTR_AUTO_ACCESSOR_OVERRIDE; break; case Doctrine::ATTR_SEQCOL_NAME: if ( ! is_string($value)) { throw new Doctrine_Exception('Sequence column name attribute only accepts string values'); } break; case Doctrine::ATTR_FIELD_CASE: if ($value != 0 && $value != CASE_LOWER && $value != CASE_UPPER) throw new Doctrine_Exception('Field case attribute should be either 0, CASE_LOWER or CASE_UPPER constant.'); break; case Doctrine::ATTR_SEQNAME_FORMAT: case Doctrine::ATTR_IDXNAME_FORMAT: case Doctrine::ATTR_TBLNAME_FORMAT: if ($this instanceof Doctrine_Table) { throw new Doctrine_Exception('Sequence / index name format attributes cannot be set' . 'at table level (only at connection or global level).'); } break; default: throw new Doctrine_Exception("Unknown attribute."); } $this->attributes[$attribute] = $value; } public function getParams($namespace = null) { if ($namespace == null) { $namespace = $this->getAttribute(Doctrine::ATTR_DEFAULT_PARAM_NAMESPACE); } if ( ! isset($this->_params[$namespace])) { return null; } return $this->_params[$namespace]; } public function getParamNamespaces() { return array_keys($this->_params); } public function setParam($name, $value, $namespace = null) { if ($namespace == null) { $namespace = $this->getAttribute(Doctrine::ATTR_DEFAULT_PARAM_NAMESPACE); } $this->_params[$namespace][$name] = $value; return $this; } public function getParam($name, $namespace = null) { if ($namespace == null) { $namespace = $this->getAttribute(Doctrine::ATTR_DEFAULT_PARAM_NAMESPACE); } if ( ! isset($this->_params[$namespace][$name])) { if (isset($this->parent)) { return $this->parent->getParam($name, $namespace); } return null; } return $this->_params[$namespace][$name]; } public function setImpl($template, $class) { $this->_impl[$template] = $class; return $this; } public function getImpl($template) { if ( ! isset($this->_impl[$template])) { if (isset($this->parent)) { return $this->parent->getImpl($template); } return null; } return $this->_impl[$template]; } public function hasImpl($template) { if ( ! isset($this->_impl[$template])) { if (isset($this->parent)) { return $this->parent->hasImpl($template); } return false; } return true; } public function setEventListener($listener) { return $this->setListener($listener); } public function addRecordListener($listener, $name = null) { if ( ! isset($this->attributes[Doctrine::ATTR_RECORD_LISTENER]) || ! ($this->attributes[Doctrine::ATTR_RECORD_LISTENER] instanceof Doctrine_Record_Listener_Chain)) { $this->attributes[Doctrine::ATTR_RECORD_LISTENER] = new Doctrine_Record_Listener_Chain(); } $this->attributes[Doctrine::ATTR_RECORD_LISTENER]->add($listener, $name); return $this; } public function getRecordListener() { if ( ! isset($this->attributes[Doctrine::ATTR_RECORD_LISTENER])) { if (isset($this->parent)) { return $this->parent->getRecordListener(); } return null; } return $this->attributes[Doctrine::ATTR_RECORD_LISTENER]; } public function setRecordListener($listener) { if ( ! ($listener instanceof Doctrine_Record_Listener_Interface) && ! ($listener instanceof Doctrine_Overloadable) ) { throw new Doctrine_Exception("Couldn't set eventlistener. Record listeners should implement either Doctrine_Record_Listener_Interface or Doctrine_Overloadable"); } $this->attributes[Doctrine::ATTR_RECORD_LISTENER] = $listener; return $this; } public function addListener($listener, $name = null) { if ( ! isset($this->attributes[Doctrine::ATTR_LISTENER]) || ! ($this->attributes[Doctrine::ATTR_LISTENER] instanceof Doctrine_EventListener_Chain)) { $this->attributes[Doctrine::ATTR_LISTENER] = new Doctrine_EventListener_Chain(); } $this->attributes[Doctrine::ATTR_LISTENER]->add($listener, $name); return $this; } public function getListener() { if ( ! isset($this->attributes[Doctrine::ATTR_LISTENER])) { if (isset($this->parent)) { return $this->parent->getListener(); } return null; } return $this->attributes[Doctrine::ATTR_LISTENER]; } public function setListener($listener) { if ( ! ($listener instanceof Doctrine_EventListener_Interface) && ! ($listener instanceof Doctrine_Overloadable) ) { throw new Doctrine_EventListener_Exception("Couldn't set eventlistener. EventListeners should implement either Doctrine_EventListener_Interface or Doctrine_Overloadable"); } $this->attributes[Doctrine::ATTR_LISTENER] = $listener; return $this; } public function getAttribute($attribute) { if (is_string($attribute)) { $upper = strtoupper($attribute); $const = 'Doctrine::ATTR_' . $upper; if (defined($const)) { $attribute = constant($const); $this->_state = $attribute; } else { throw new Doctrine_Exception('Unknown attribute: "' . $attribute . '"'); } } $attribute = (int) $attribute; if ($attribute < 0) { throw new Doctrine_Exception('Unknown attribute.'); } if (isset($this->attributes[$attribute])) { return $this->attributes[$attribute]; } if (isset($this->parent)) { return $this->parent->getAttribute($attribute); } return null; } public function getAttributes() { return $this->attributes; } public function setParent(Doctrine_Configurable $component) { $this->parent = $component; } public function getParent() { return $this->parent; } } abstract class Doctrine_Connection extends Doctrine_Configurable implements Countable, IteratorAggregate { protected $dbh; protected $tables = array(); protected $_name; protected $driverName; protected $isConnected = false; protected $supported = array(); protected $pendingAttributes = array(); private $modules = array('transaction' => false, 'expression' => false, 'dataDict' => false, 'export' => false, 'import' => false, 'sequence' => false, 'unitOfWork' => false, 'formatter' => false, 'util' => false, ); protected $properties = array('sql_comments' => array(array('start' => '--', 'end' => "\n", 'escape' => false), array('start' => '/*', 'end' => '*/', 'escape' => false)), 'identifier_quoting' => array('start' => '"', 'end' => '"','escape' => '"'), 'string_quoting' => array('start' => "'", 'end' => "'", 'escape' => false, 'escape_pattern' => false), 'wildcards' => array('%', '_'), 'varchar_max_length' => 255, 'sql_file_delimiter' => ";\n", ); protected $serverInfo = array(); protected $options = array(); private static $availableDrivers = array( 'Mysql', 'Pgsql', 'Oracle', 'Informix', 'Mssql', 'Sqlite', 'Firebird' ); protected $_count = 0; public function __construct(Doctrine_Manager $manager, $adapter, $user = null, $pass = null) { if (is_object($adapter)) { if ( ! ($adapter instanceof PDO) && ! in_array('Doctrine_Adapter_Interface', class_implements($adapter))) { throw new Doctrine_Connection_Exception('First argument should be an instance of PDO or implement Doctrine_Adapter_Interface'); } $this->dbh = $adapter; $this->isConnected = true; } else if (is_array($adapter)) { $this->pendingAttributes[Doctrine::ATTR_DRIVER_NAME] = $adapter['scheme']; $this->options['dsn'] = $adapter['dsn']; $this->options['username'] = $adapter['user']; $this->options['password'] = $adapter['pass']; $this->options['other'] = array(); if (isset($adapter['other'])) { $this->options['other'] = array(Doctrine::ATTR_PERSISTENT => $adapter['persistent']); } } $this->setParent($manager); $this->setAttribute(Doctrine::ATTR_CASE, Doctrine::CASE_NATURAL); $this->setAttribute(Doctrine::ATTR_ERRMODE, Doctrine::ERRMODE_EXCEPTION); $this->getAttribute(Doctrine::ATTR_LISTENER)->onOpen($this); } public function getOptions() { return $this->options; } public function getOption($option) { if (isset($this->options[$option])) { return $this->options[$option]; } } public function setOption($option, $value) { return $this->options[$option] = $value; } public function getAttribute($attribute) { if (is_string($attribute)) { $stringAttribute = $attribute; $attribute = $this->getAttributeFromString($attribute); } if ($attribute >= 100) { if ( ! isset($this->attributes[$attribute])) { return parent::getAttribute($attribute); } return $this->attributes[$attribute]; } if ($this->isConnected) { try { return $this->dbh->getAttribute($attribute); } catch (Exception $e) { throw new Doctrine_Connection_Exception('Attribute ' . $attribute . ' not found.'); } } else { if ( ! isset($this->pendingAttributes[$attribute])) { $this->connect(); $this->getAttribute($attribute); } return $this->pendingAttributes[$attribute]; } } public static function getAvailableDrivers() { return PDO::getAvailableDrivers(); } public function setAttribute($attribute, $value) { if (is_string($attribute)) { $attributeString = $attribute; $attribute = parent::getAttributeFromString($attribute); } if (is_string($value) && isset($attributeString)) { $value = parent::getAttributeValueFromString($attributeString, $value); } if ($attribute >= 100) { parent::setAttribute($attribute, $value); } else { if ($this->isConnected) { $this->dbh->setAttribute($attribute, $value); } else { $this->pendingAttributes[$attribute] = $value; } } return $this; } public function getName() { return $this->_name; } public function setName($name) { $this->_name = $name; } public function getDriverName() { return $this->driverName; } public function __get($name) { if (isset($this->properties[$name])) { return $this->properties[$name]; } if ( ! isset($this->modules[$name])) { throw new Doctrine_Connection_Exception('Unknown module / property ' . $name); } if ($this->modules[$name] === false) { switch ($name) { case 'unitOfWork': $this->modules[$name] = new Doctrine_Connection_UnitOfWork($this); break; case 'formatter': $this->modules[$name] = new Doctrine_Formatter($this); break; default: $class = 'Doctrine_' . ucwords($name) . '_' . $this->getDriverName(); $this->modules[$name] = new $class($this); } } return $this->modules[$name]; } public function getManager() { return $this->getParent(); } public function getDbh() { $this->connect(); return $this->dbh; } public function connect() { if ($this->isConnected) { return false; } $event = new Doctrine_Event($this, Doctrine_Event::CONN_CONNECT); $this->getListener()->preConnect($event); $e = explode(':', $this->options['dsn']); $found = false; if (extension_loaded('pdo')) { if (in_array($e[0], PDO::getAvailableDrivers())) { try { $this->dbh = new PDO($this->options['dsn'], $this->options['username'], (!$this->options['password'] ? '':$this->options['password']), $this->options['other']); $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); } catch (PDOException $e) { throw new Doctrine_Connection_Exception('PDO Connection Error: ' . $e->getMessage()); } $found = true; } } if ( ! $found) { $class = 'Doctrine_Adapter_' . ucwords($e[0]); if (class_exists($class)) { $this->dbh = new $class($this->options['dsn'], $this->options['username'], $this->options['password']); } else { throw new Doctrine_Connection_Exception("Couldn't locate driver named " . $e[0]); } } foreach($this->pendingAttributes as $attr => $value) { if ($attr == Doctrine::ATTR_DRIVER_NAME) { continue; } $this->dbh->setAttribute($attr, $value); } $this->isConnected = true; $this->getListener()->postConnect($event); return true; } public function incrementQueryCount() { $this->_count++; } public function driverName($name) { } public function supports($feature) { return (isset($this->supported[$feature]) && ($this->supported[$feature] === 'emulated' || $this->supported[$feature])); } public function replace(Doctrine_Table $table, array $fields, array $keys) { if (empty($keys)) { throw new Doctrine_Connection_Exception('Not specified which fields are keys'); } $identifier = (array) $table->getIdentifier(); $condition = array(); foreach ($fields as $fieldName => $value) { if (in_array($fieldName, $keys)) { if ($value !== null) { $condition[] = $table->getColumnName($fieldName) . ' = ?'; $conditionValues[] = $value; } } } $affectedRows = 0; if ( ! empty($condition) && ! empty($conditionValues)) { $query = 'DELETE FROM ' . $this->quoteIdentifier($table->getTableName()) . ' WHERE ' . implode(' AND ', $condition); $affectedRows = $this->exec($query, $conditionValues); } $this->insert($table, $fields); $affectedRows++; return $affectedRows; } public function delete(Doctrine_Table $table, array $identifier) { $tmp = array(); foreach (array_keys($identifier) as $id) { $tmp[] = $this->quoteIdentifier($table->getColumnName($id)) . ' = ?'; } $query = 'DELETE FROM ' . $this->quoteIdentifier($table->getTableName()) . ' WHERE ' . implode(' AND ', $tmp); return $this->exec($query, array_values($identifier)); } public function update(Doctrine_Table $table, array $fields, array $identifier) { if (empty($fields)) { return false; } $set = array(); foreach ($fields as $fieldName => $value) { if ($value instanceof Doctrine_Expression) { $set[] = $this->quoteIdentifier($table->getColumnName($fieldName)) . ' = ' . $value->getSql(); unset($fields[$fieldName]); } else { $set[] = $this->quoteIdentifier($table->getColumnName($fieldName)) . ' = ?'; } } $params = array_merge(array_values($fields), array_values($identifier)); $sql = 'UPDATE ' . $this->quoteIdentifier($table->getTableName()) . ' SET ' . implode(', ', $set) . ' WHERE ' . implode(' = ? AND ', $this->quoteMultipleIdentifier($table->getIdentifierColumnNames())) . ' = ?'; return $this->exec($sql, $params); } public function insert(Doctrine_Table $table, array $fields) { $tableName = $table->getTableName(); $cols = array(); $a = array(); foreach ($fields as $fieldName => $value) { $cols[] = $this->quoteIdentifier($table->getColumnName($fieldName)); if ($value instanceof Doctrine_Expression) { $a[] = $value->getSql(); unset($fields[$fieldName]); } else { $a[] = '?'; } } $query = 'INSERT INTO ' . $this->quoteIdentifier($tableName) . ' (' . implode(', ', $cols) . ')' . ' VALUES (' . implode(', ', $a) . ')'; return $this->exec($query, array_values($fields)); } public function setCharset($charset) { } public function quoteIdentifier($str, $checkOption = true) { if (strpos($str, '.')) { $e = explode('.', $str); return $this->formatter->quoteIdentifier($e[0], $checkOption) . '.' . $this->formatter->quoteIdentifier($e[1], $checkOption); } return $this->formatter->quoteIdentifier($str, $checkOption); } public function quoteMultipleIdentifier($arr, $checkOption = true) { foreach ($arr as $k => $v) { $arr[$k] = $this->quoteIdentifier($v, $checkOption); } return $arr; } public function convertBooleans($item) { return $this->formatter->convertBooleans($item); } public function quote($input, $type = null) { return $this->formatter->quote($input, $type); } public function setDateFormat($format = null) { } public function fetchAll($statement, array $params = array()) { return $this->execute($statement, $params)->fetchAll(Doctrine::FETCH_ASSOC); } public function fetchOne($statement, array $params = array(), $colnum = 0) { return $this->execute($statement, $params)->fetchColumn($colnum); } public function fetchRow($statement, array $params = array()) { return $this->execute($statement, $params)->fetch(Doctrine::FETCH_ASSOC); } public function fetchArray($statement, array $params = array()) { return $this->execute($statement, $params)->fetch(Doctrine::FETCH_NUM); } public function fetchColumn($statement, array $params = array(), $colnum = 0) { return $this->execute($statement, $params)->fetchAll(Doctrine::FETCH_COLUMN, $colnum); } public function fetchAssoc($statement, array $params = array()) { return $this->execute($statement, $params)->fetchAll(Doctrine::FETCH_ASSOC); } public function fetchBoth($statement, array $params = array()) { return $this->execute($statement, $params)->fetchAll(Doctrine::FETCH_BOTH); } public function query($query, array $params = array(), $hydrationMode = null) { $parser = new Doctrine_Query($this); $res = $parser->query($query, $params, $hydrationMode); $parser->free(); return $res; } public function prepare($statement) { $this->connect(); try { $event = new Doctrine_Event($this, Doctrine_Event::CONN_PREPARE, $statement); $this->getAttribute(Doctrine::ATTR_LISTENER)->prePrepare($event); $stmt = false; if ( ! $event->skipOperation) { $stmt = $this->dbh->prepare($statement); } $this->getAttribute(Doctrine::ATTR_LISTENER)->postPrepare($event); return new Doctrine_Connection_Statement($this, $stmt); } catch(Doctrine_Adapter_Exception $e) { } catch(PDOException $e) { } $this->rethrowException($e, $this); } public function queryOne($query, array $params = array()) { $parser = new Doctrine_Query($this); $coll = $parser->query($query, $params); if ( ! $coll->contains(0)) { return false; } return $coll[0]; } public function select($query, $limit = 0, $offset = 0) { if ($limit > 0 || $offset > 0) { $query = $this->modifyLimitQuery($query, $limit, $offset); } return $this->execute($query); } public function standaloneQuery($query, $params = array()) { return $this->execute($query, $params); } public function execute($query, array $params = array()) { $this->connect(); try { if ( ! empty($params)) { $stmt = $this->prepare($query); $stmt->execute($params); return $stmt; } else { $event = new Doctrine_Event($this, Doctrine_Event::CONN_QUERY, $query, $params); $this->getAttribute(Doctrine::ATTR_LISTENER)->preQuery($event); if ( ! $event->skipOperation) { $stmt = $this->dbh->query($query); $this->_count++; } $this->getAttribute(Doctrine::ATTR_LISTENER)->postQuery($event); return $stmt; } } catch (Doctrine_Adapter_Exception $e) { } catch (PDOException $e) { } $this->rethrowException($e, $this); } public function exec($query, array $params = array()) { $this->connect(); try { if ( ! empty($params)) { $stmt = $this->prepare($query); $stmt->execute($params); return $stmt->rowCount(); } else { $event = new Doctrine_Event($this, Doctrine_Event::CONN_EXEC, $query, $params); $this->getAttribute(Doctrine::ATTR_LISTENER)->preExec($event); if ( ! $event->skipOperation) { $count = $this->dbh->exec($query); $this->_count++; } $this->getAttribute(Doctrine::ATTR_LISTENER)->postExec($event); return $count; } } catch (Doctrine_Adapter_Exception $e) { } catch (PDOException $e) { } $this->rethrowException($e, $this); } public function rethrowException(Exception $e, $invoker) { $event = new Doctrine_Event($this, Doctrine_Event::CONN_ERROR); $this->getListener()->preError($event); $name = 'Doctrine_Connection_' . $this->driverName . '_Exception'; $exc = new $name($e->getMessage(), (int) $e->getCode()); if ( ! isset($e->errorInfo) || ! is_array($e->errorInfo)) { $e->errorInfo = array(null, null, null, null); } $exc->processErrorInfo($e->errorInfo); if ($this->getAttribute(Doctrine::ATTR_THROW_EXCEPTIONS)) { throw $exc; } $this->getListener()->postError($event); } public function hasTable($name) { return isset($this->tables[$name]); } public function getTable($name) { if (isset($this->tables[$name])) { return $this->tables[$name]; } $class = $name . 'Table'; if (class_exists($class, $this->getAttribute(Doctrine::ATTR_AUTOLOAD_TABLE_CLASSES)) && in_array('Doctrine_Table', class_parents($class))) { $table = new $class($name, $this, true); } else { $table = new Doctrine_Table($name, $this, true); } $this->tables[$name] = $table; return $table; } public function getTables() { return $this->tables; } public function getIterator() { return new ArrayIterator($this->tables); } public function count() { return $this->_count; } public function addTable(Doctrine_Table $table) { $name = $table->getComponentName(); if (isset($this->tables[$name])) { return false; } $this->tables[$name] = $table; return true; } public function create($name) { return $this->getTable($name)->create(); } public function createQuery() { return new Doctrine_Query($this); } public function flush() { try { $this->beginInternalTransaction(); $this->unitOfWork->saveAll(); $this->commit(); } catch (Exception $e) { $this->rollback(); throw $e; } } public function clear() { foreach ($this->tables as $k => $table) { $table->getRepository()->evictAll(); $table->clear(); } } public function evictTables() { $this->tables = array(); $this->exported = array(); } public function close() { $event = new Doctrine_Event($this, Doctrine_Event::CONN_CLOSE); $this->getAttribute(Doctrine::ATTR_LISTENER)->preClose($event); $this->clear(); unset($this->dbh); $this->isConnected = false; $this->getAttribute(Doctrine::ATTR_LISTENER)->postClose($event); } public function getTransactionLevel() { return $this->transaction->getTransactionLevel(); } public function errorCode() { $this->connect(); return $this->dbh->errorCode(); } public function errorInfo() { $this->connect(); return $this->dbh->errorInfo(); } public function getCacheDriver() { return $this->getResultCacheDriver(); } public function getResultCacheDriver() { if ( ! $this->getAttribute(Doctrine::ATTR_RESULT_CACHE)) { throw new Doctrine_Exception('Result Cache driver not initialized.'); } return $this->getAttribute(Doctrine::ATTR_RESULT_CACHE); } public function getQueryCacheDriver() { if ( ! $this->getAttribute(Doctrine::ATTR_QUERY_CACHE)) { throw new Doctrine_Exception('Query Cache driver not initialized.'); } return $this->getAttribute(Doctrine::ATTR_QUERY_CACHE); } public function lastInsertId($table = null, $field = null) { return $this->sequence->lastInsertId($table, $field); } public function beginTransaction($savepoint = null) { return $this->transaction->beginTransaction($savepoint); } public function beginInternalTransaction($savepoint = null) { return $this->transaction->beginInternalTransaction($savepoint); } public function commit($savepoint = null) { return $this->transaction->commit($savepoint); } public function rollback($savepoint = null) { $this->transaction->rollback($savepoint); } public function createDatabase() { if ( ! $dsn = $this->getOption('dsn')) { throw new Doctrine_Connection_Exception('You must create your Doctrine_Connection by using a valid Doctrine style dsn in order to use the create/drop database functionality'); } $info = $this->getManager()->parsePdoDsn($dsn); $tmpConnection = $this->getTmpConnection($info); try { $tmpConnection->export->createDatabase($info['dbname']); } catch (Exception $e) {} $this->getManager()->closeConnection($tmpConnection); if ($info['unix_socket']) { $dsn = array($info['scheme'] . ':unix_socket=' . $info['unix_socket'] . ';dbname=' . $info['dbname'], $this->getOption('username'), $this->getOption('password')); } else { $dsn = $info['scheme'] . '://' . $this->getOption('username') . ':' . $this->getOption('password') . '@' . $info['host'] . '/' . $info['dbname']; } $this->getManager()->openConnection($dsn, $this->getName(), true); if (isset($e)) { return $e; } else { return 'Successfully created database for connection "' . $this->getName() . '" named "' . $info['dbname'] . '"'; } } public function dropDatabase() { if ( ! $dsn = $this->getOption('dsn')) { throw new Doctrine_Connection_Exception('You must create your Doctrine_Connection by using a valid Doctrine style dsn in order to use the create/drop database functionality'); } $info = $this->getManager()->parsePdoDsn($dsn); $tmpConnection = $this->getTmpConnection($info); try { $tmpConnection->export->dropDatabase($info['dbname']); } catch (Exception $e) {} $this->getManager()->closeConnection($tmpConnection); if ($info['unix_socket']) { $dsn = array($info['scheme'] . ':unix_socket=' . $info['unix_socket'] . ';dbname=' . $info['dbname'], $this->getOption('username'), $this->getOption('password')); } else { $dsn = $info['scheme'] . '://' . $this->getOption('username') . ':' . $this->getOption('password') . '@' . $info['host'] . '/' . $info['dbname']; } $this->getManager()->openConnection($dsn, $this->getName(), true); if (isset($e)) { return $e; } else { return 'Successfully dropped database for connection "' . $this->getName() . '" named "' . $info['dbname'] . '"'; } } public function getTmpConnection($info) { if ($info['unix_socket']) { $pdoDsn = $info['scheme'] . ':unix_socket=' . $info['unix_socket']; } else { $pdoDsn = $info['scheme'] . ':host=' . $info['host']; } if (isset($this->export->tmpConnectionDatabase) && $this->export->tmpConnectionDatabase) { $pdoDsn .= ';dbname=' . $this->export->tmpConnectionDatabase; } $username = $this->getOption('username'); $password = $this->getOption('password'); return $this->getManager()->openConnection(new PDO($pdoDsn, $username, $password), 'doctrine_tmp_connection', false); } public function modifyLimitQuery($query, $limit = false, $offset = false, $isManip = false) { return $query; } public function modifyLimitSubquery(Doctrine_Table $rootTable, $query, $limit = false, $offset = false, $isManip = false) { return $this->modifyLimitQuery($query, $limit, $offset, $isManip); } public function __toString() { return Doctrine_Lib::getConnectionAsString($this); } public function serialize() { $vars = get_object_vars($this); $vars['dbh'] = null; $vars['isConnected'] = false; return serialize($vars); } public function unserialize($serialized) { $array = unserialize($serialized); foreach ($array as $name => $values) { $this->$name = $values; } } }class Doctrine_Connection_Exception extends Doctrine_Exception { static protected $errorMessages = array( Doctrine::ERR => 'unknown error', Doctrine::ERR_ALREADY_EXISTS => 'already exists', Doctrine::ERR_CANNOT_CREATE => 'can not create', Doctrine::ERR_CANNOT_ALTER => 'can not alter', Doctrine::ERR_CANNOT_REPLACE => 'can not replace', Doctrine::ERR_CANNOT_DELETE => 'can not delete', Doctrine::ERR_CANNOT_DROP => 'can not drop', Doctrine::ERR_CONSTRAINT => 'constraint violation', Doctrine::ERR_CONSTRAINT_NOT_NULL=> 'null value violates not-null constraint', Doctrine::ERR_DIVZERO => 'division by zero', Doctrine::ERR_INVALID => 'invalid', Doctrine::ERR_INVALID_DATE => 'invalid date or time', Doctrine::ERR_INVALID_NUMBER => 'invalid number', Doctrine::ERR_MISMATCH => 'mismatch', Doctrine::ERR_NODBSELECTED => 'no database selected', Doctrine::ERR_NOSUCHFIELD => 'no such field', Doctrine::ERR_NOSUCHTABLE => 'no such table', Doctrine::ERR_NOT_CAPABLE => 'Doctrine backend not capable', Doctrine::ERR_NOT_FOUND => 'not found', Doctrine::ERR_NOT_LOCKED => 'not locked', Doctrine::ERR_SYNTAX => 'syntax error', Doctrine::ERR_UNSUPPORTED => 'not supported', Doctrine::ERR_VALUE_COUNT_ON_ROW => 'value count on row', Doctrine::ERR_INVALID_DSN => 'invalid DSN', Doctrine::ERR_CONNECT_FAILED => 'connect failed', Doctrine::ERR_NEED_MORE_DATA => 'insufficient data supplied', Doctrine::ERR_EXTENSION_NOT_FOUND=> 'extension not found', Doctrine::ERR_NOSUCHDB => 'no such database', Doctrine::ERR_ACCESS_VIOLATION => 'insufficient permissions', Doctrine::ERR_LOADMODULE => 'error while including on demand module', Doctrine::ERR_TRUNCATED => 'truncated', Doctrine::ERR_DEADLOCK => 'deadlock detected', ); protected $portableCode; public function getPortableCode() { return $this->portableCode; } public function getPortableMessage() { return self::errorMessage($this->portableCode); } public function errorMessage($value = null) { return isset(self::$errorMessages[$value]) ? self::$errorMessages[$value] : self::$errorMessages[Doctrine::ERR]; } public function processErrorInfo(array $errorInfo) { } }class Doctrine_Connection_Pgsql_Exception extends Doctrine_Connection_Exception { protected static $errorRegexps = array( '/parser: parse error at or near/i' => Doctrine::ERR_SYNTAX, '/syntax error at/' => Doctrine::ERR_SYNTAX, '/column reference .* is ambiguous/i' => Doctrine::ERR_SYNTAX, '/column .* (of relation .*)?does not exist/i' => Doctrine::ERR_NOSUCHFIELD, '/attribute .* not found|relation .* does not have attribute/i' => Doctrine::ERR_NOSUCHFIELD, '/column .* specified in USING clause does not exist in (left|right) table/i' => Doctrine::ERR_NOSUCHFIELD, '/(relation|sequence|table).*does not exist|class .* not found/i' => Doctrine::ERR_NOSUCHTABLE, '/index .* does not exist/' => Doctrine::ERR_NOT_FOUND, '/relation .* already exists/i' => Doctrine::ERR_ALREADY_EXISTS, '/(divide|division) by zero$/i' => Doctrine::ERR_DIVZERO, '/pg_atoi: error in .*: can\'t parse /i' => Doctrine::ERR_INVALID_NUMBER, '/invalid input syntax for( type)? (integer|numeric)/i' => Doctrine::ERR_INVALID_NUMBER, '/value .* is out of range for type \w*int/i' => Doctrine::ERR_INVALID_NUMBER, '/integer out of range/i' => Doctrine::ERR_INVALID_NUMBER, '/value too long for type character/i' => Doctrine::ERR_INVALID, '/permission denied/' => Doctrine::ERR_ACCESS_VIOLATION, '/violates [\w ]+ constraint/' => Doctrine::ERR_CONSTRAINT, '/referential integrity violation/' => Doctrine::ERR_CONSTRAINT, '/violates not-null constraint/' => Doctrine::ERR_CONSTRAINT_NOT_NULL, '/more expressions than target columns/i' => Doctrine::ERR_VALUE_COUNT_ON_ROW, ); public function processErrorInfo(array $errorInfo) { foreach (self::$errorRegexps as $regexp => $code) { if (preg_match($regexp, $errorInfo[2])) { $this->portableCode = $code; return true; } } return false; } }class Doctrine_Connection_Common extends Doctrine_Connection { public function modifyLimitQuery($query, $limit = false,$offset = false,$isManip=false) { $limit = (int) $limit; $offset = (int) $offset; if ($limit && $offset) { $query .= ' LIMIT ' . $limit . ' OFFSET ' . $offset; } elseif ($limit && ! $offset) { $query .= ' LIMIT ' . $limit; } elseif ( ! $limit && $offset) { $query .= ' LIMIT 999999999999 OFFSET ' . $offset; } return $query; } }class Doctrine_Connection_Pgsql extends Doctrine_Connection_Common { protected $driverName = 'Pgsql'; public function __construct(Doctrine_Manager $manager, $adapter) { $this->supported = array( 'sequences' => true, 'indexes' => true, 'affected_rows' => true, 'summary_functions' => true, 'order_by_text' => true, 'transactions' => true, 'savepoints' => true, 'current_id' => true, 'limit_queries' => true, 'LOBs' => true, 'replace' => 'emulated', 'sub_selects' => true, 'auto_increment' => 'emulated', 'primary_key' => true, 'result_introspection' => true, 'prepared_statements' => true, 'identifier_quoting' => true, 'pattern_escaping' => true, ); $this->properties['string_quoting'] = array('start' => "'", 'end' => "'", 'escape' => "'", 'escape_pattern' => '\\'); $this->properties['identifier_quoting'] = array('start' => '"', 'end' => '"', 'escape' => '"'); parent::__construct($manager, $adapter); } public function setCharset($charset) { $query = 'SET NAMES '.$this->dbh->quote($charset); $this->exec($query); } public function convertBooleans($item) { if (is_array($item)) { foreach ($item as $key => $value) { if (is_bool($value)) { $item[$key] = ($value) ? 'true' : 'false'; } } } else { if (is_bool($item) || is_numeric($item)) { $item = ($item) ? 'true' : 'false'; } } return $item; } public function modifyLimitQuery($query, $limit = false, $offset = false, $isManip = false) { if ($limit > 0) { $query = rtrim($query); if (substr($query, -1) == ';') { $query = substr($query, 0, -1); } if ($isManip) { $manip = preg_replace('/^(DELETE FROM|UPDATE).*$/', '\\1', $query); $from = $match[2]; $where = $match[3]; $query = $manip . ' ' . $from . ' WHERE ctid=(SELECT ctid FROM ' . $from . ' ' . $where . ' LIMIT ' . $limit . ')'; } else { if ( ! empty($limit)) { $query .= ' LIMIT ' . $limit; } if ( ! empty($offset)) { $query .= ' OFFSET ' . $offset; } } } return $query; } public function getServerVersion($native = false) { $query = 'SHOW SERVER_VERSION'; $serverInfo = $this->fetchOne($query); if ( ! $native) { $tmp = explode('.', $serverInfo, 3); if (empty($tmp[2]) && isset($tmp[1]) && preg_match('/(\d+)(.*)/', $tmp[1], $tmp2) ) { $serverInfo = array( 'major' => $tmp[0], 'minor' => $tmp2[1], 'patch' => null, 'extra' => $tmp2[2], 'native' => $serverInfo, ); } else { $serverInfo = array( 'major' => isset($tmp[0]) ? $tmp[0] : null, 'minor' => isset($tmp[1]) ? $tmp[1] : null, 'patch' => isset($tmp[2]) ? $tmp[2] : null, 'extra' => null, 'native' => $serverInfo, ); } } return $serverInfo; } }class Doctrine_Connection_Profiler_Exception extends Doctrine_Exception { }class Doctrine_Connection_Statement implements Doctrine_Adapter_Statement_Interface { protected $_conn; protected $_stmt; public function __construct(Doctrine_Connection $conn, $stmt) { $this->_conn = $conn; $this->_stmt = $stmt; if ($stmt === false) { throw new Doctrine_Exception('Unknown statement object given.'); } } public function getConnection() { return $this->_conn; } public function getStatement() { return $this->_stmt; } public function getQuery() { return $this->_stmt->queryString; } public function bindColumn($column, $param, $type = null) { if ($type === null) { return $this->_stmt->bindColumn($column, $param); } else { return $this->_stmt->bindColumn($column, $param, $type); } } public function bindValue($param, $value, $type = null) { if ($type === null) { return $this->_stmt->bindValue($param, $value); } else { return $this->_stmt->bindValue($param, $value, $type); } } public function bindParam($column, &$variable, $type = null, $length = null, $driverOptions = array()) { if ($type === null) { return $this->_stmt->bindParam($column, $variable); } else { return $this->_stmt->bindParam($column, $variable, $type, $length, $driverOptions); } } public function closeCursor() { return $this->_stmt->closeCursor(); } public function columnCount() { return $this->_stmt->columnCount(); } public function errorCode() { return $this->_stmt->errorCode(); } public function errorInfo() { return $this->_stmt->errorInfo(); } public function execute($params = null) { try { $event = new Doctrine_Event($this, Doctrine_Event::STMT_EXECUTE, $this->getQuery(), $params); $this->_conn->getListener()->preStmtExecute($event); $result = true; if ( ! $event->skipOperation) { $result = $this->_stmt->execute($params); $this->_conn->incrementQueryCount(); } $this->_conn->getListener()->postStmtExecute($event); return $result; } catch (PDOException $e) { } catch (Doctrine_Adapter_Exception $e) { } $this->_conn->rethrowException($e, $this); return false; } public function fetch($fetchMode = Doctrine::FETCH_BOTH, $cursorOrientation = Doctrine::FETCH_ORI_NEXT, $cursorOffset = null) { $event = new Doctrine_Event($this, Doctrine_Event::STMT_FETCH, $this->getQuery()); $event->fetchMode = $fetchMode; $event->cursorOrientation = $cursorOrientation; $event->cursorOffset = $cursorOffset; $data = $this->_conn->getListener()->preFetch($event); if ( ! $event->skipOperation) { $data = $this->_stmt->fetch($fetchMode, $cursorOrientation, $cursorOffset); } $this->_conn->getListener()->postFetch($event); return $data; } public function fetchAll($fetchMode = Doctrine::FETCH_BOTH, $columnIndex = null) { $event = new Doctrine_Event($this, Doctrine_Event::STMT_FETCHALL, $this->getQuery()); $event->fetchMode = $fetchMode; $event->columnIndex = $columnIndex; $this->_conn->getListener()->preFetchAll($event); if ( ! $event->skipOperation) { if ($columnIndex !== null) { $data = $this->_stmt->fetchAll($fetchMode, $columnIndex); } else { $data = $this->_stmt->fetchAll($fetchMode); } $event->data = $data; } $this->_conn->getListener()->postFetchAll($event); return $data; } public function fetchColumn($columnIndex = 0) { return $this->_stmt->fetchColumn($columnIndex); } public function fetchObject($className = 'stdClass', $args = array()) { return $this->_stmt->fetchObject($className, $args); } public function getAttribute($attribute) { return $this->_stmt->getAttribute($attribute); } public function getColumnMeta($column) { return $this->_stmt->getColumnMeta($column); } public function nextRowset() { return $this->_stmt->nextRowset(); } public function rowCount() { return $this->_stmt->rowCount(); } public function setAttribute($attribute, $value) { return $this->_stmt->setAttribute($attribute, $value); } public function setFetchMode($mode, $arg1 = null, $arg2 = null) { return $this->_stmt->setFetchMode($mode, $arg1, $arg2); } } class Doctrine_Connection_Profiler implements Doctrine_Overloadable, IteratorAggregate, Countable { private $listeners = array('query', 'prepare', 'commit', 'rollback', 'connect', 'begintransaction', 'exec', 'execute'); private $events = array(); public function __construct() { } public function setFilterQueryType() { } public function __call($m, $a) { if ( ! ($a[0] instanceof Doctrine_Event)) { throw new Doctrine_Connection_Profiler_Exception("Couldn't listen event. Event should be an instance of Doctrine_Event."); } if (substr($m, 0, 3) === 'pre') { $a[0]->start(); if ( ! in_array($a[0], $this->events, true)) { $this->events[] = $a[0]; } } else { $a[0]->end(); } } public function get($key) { if (isset($this->events[$key])) { return $this->events[$key]; } return null; } public function getAll() { return $this->events; } public function getIterator() { return new ArrayIterator($this->events); } public function count() { return count($this->events); } public function pop() { return array_pop($this->events); } public function lastEvent() { if (empty($this->events)) { return false; } end($this->events); return current($this->events); } }class Doctrine_Connection_UnitOfWork extends Doctrine_Connection_Module { public function saveGraph(Doctrine_Record $record) { $record->assignInheritanceValues(); $conn = $this->getConnection(); $state = $record->state(); if ($state === Doctrine_Record::STATE_LOCKED || $state === Doctrine_Record::STATE_TLOCKED) { return false; } $record->state($record->exists() ? Doctrine_Record::STATE_LOCKED : Doctrine_Record::STATE_TLOCKED); try { $conn->beginInternalTransaction(); $saveLater = $this->saveRelated($record); $record->state($state); if ($record->isValid()) { $event = new Doctrine_Event($record, Doctrine_Event::RECORD_SAVE); $record->preSave($event); $record->getTable()->getRecordListener()->preSave($event); $state = $record->state(); if ( ! $event->skipOperation) { switch ($state) { case Doctrine_Record::STATE_TDIRTY: case Doctrine_Record::STATE_TCLEAN: $this->insert($record); break; case Doctrine_Record::STATE_DIRTY: case Doctrine_Record::STATE_PROXY: $this->update($record); break; case Doctrine_Record::STATE_CLEAN: break; } } foreach ($record->getPendingDeletes() as $pendingDelete) { $pendingDelete->delete(); } $record->getTable()->getRecordListener()->postSave($event); $record->postSave($event); } else { $conn->transaction->addInvalid($record); } $state = $record->state(); $record->state($record->exists() ? Doctrine_Record::STATE_LOCKED : Doctrine_Record::STATE_TLOCKED); foreach ($saveLater as $fk) { $alias = $fk->getAlias(); if ($record->hasReference($alias)) { $obj = $record->$alias; if ( ! ($obj instanceof Doctrine_Null)) { $obj->save($conn); } } } $this->saveAssociations($record); $record->state($state); $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return true; } public function save(Doctrine_Record $record) { $event = new Doctrine_Event($record, Doctrine_Event::RECORD_SAVE); $record->preSave($event); $record->getTable()->getRecordListener()->preSave($event); if ( ! $event->skipOperation) { switch ($record->state()) { case Doctrine_Record::STATE_TDIRTY: case Doctrine_Record::STATE_TCLEAN: $this->insert($record); break; case Doctrine_Record::STATE_DIRTY: case Doctrine_Record::STATE_PROXY: $this->update($record); break; case Doctrine_Record::STATE_CLEAN: break; } } $record->getTable()->getRecordListener()->postSave($event); $record->postSave($event); } public function delete(Doctrine_Record $record) { $deletions = array(); $this->_collectDeletions($record, $deletions); return $this->_executeDeletions($deletions); } private function _collectDeletions(Doctrine_Record $record, array &$deletions) { if ( ! $record->exists()) { return; } $deletions[$record->getOid()] = $record; $this->_cascadeDelete($record, $deletions); } private function _executeDeletions(array $deletions) { $classNames = array(); foreach ($deletions as $record) { $classNames[] = $record->getTable()->getComponentName(); } $classNames = array_unique($classNames); $executionOrder = $this->buildFlushTree($classNames); try { $this->conn->beginInternalTransaction(); for ($i = count($executionOrder) - 1; $i >= 0; $i--) { $className = $executionOrder[$i]; $table = $this->conn->getTable($className); $identifierMaps = array(); $deletedRecords = array(); foreach ($deletions as $oid => $record) { if ($record->getTable()->getComponentName() == $className) { $veto = $this->_preDelete($record); if ( ! $veto) { $identifierMaps[] = $record->identifier(); $deletedRecords[] = $record; unset($deletions[$oid]); } } } if (count($deletedRecords) < 1) { continue; } $params = array(); $columnNames = array(); foreach ($identifierMaps as $idMap) { while (list($fieldName, $value) = each($idMap)) { $params[] = $value; $columnNames[] = $table->getColumnName($fieldName); } } $columnNames = array_unique($columnNames); $tableName = $table->getTableName(); $sql = "DELETE FROM " . $this->conn->quoteIdentifier($tableName) . " WHERE "; if ($table->isIdentifierComposite()) { $sql .= $this->_buildSqlCompositeKeyCondition($columnNames, count($identifierMaps)); $this->conn->exec($sql, $params); } else { $sql .= $this->_buildSqlSingleKeyCondition($columnNames, count($params)); $this->conn->exec($sql, $params); } foreach ($deletedRecords as $record) { $this->_deleteCTIParents($table, $record); $record->state(Doctrine_Record::STATE_TCLEAN); $record->getTable()->removeRecord($record); $this->_postDelete($record); } } foreach ($deletions as $skippedRecord) { $this->_postDelete($skippedRecord); } $this->conn->commit(); return true; } catch (Exception $e) { $this->conn->rollback(); throw $e; } } private function _buildSqlSingleKeyCondition($columnNames, $numRecords) { $idColumn = $this->conn->quoteIdentifier($columnNames[0]); return implode(' OR ', array_fill(0, $numRecords, "$idColumn = ?")); } private function _buildSqlCompositeKeyCondition($columnNames, $numRecords) { $singleCondition = ""; foreach ($columnNames as $columnName) { $columnName = $this->conn->quoteIdentifier($columnName); if ($singleCondition === "") { $singleCondition .= "($columnName = ?"; } else { $singleCondition .= " AND $columnName = ?"; } } $singleCondition .= ")"; $fullCondition = implode(' OR ', array_fill(0, $numRecords, $singleCondition)); return $fullCondition; } protected function _cascadeDelete(Doctrine_Record $record, array &$deletions) { foreach ($record->getTable()->getRelations() as $relation) { if ($relation->isCascadeDelete()) { $fieldName = $relation->getAlias(); if ( ! ($relation->getType() == Doctrine_Relation::ONE && isset($record->$fieldName))) { $record->refreshRelated($relation->getAlias()); } $relatedObjects = $record->get($relation->getAlias()); if ($relatedObjects instanceof Doctrine_Record && $relatedObjects->exists() && ! isset($deletions[$relatedObjects->getOid()])) { $this->_collectDeletions($relatedObjects, $deletions); } else if ($relatedObjects instanceof Doctrine_Collection && count($relatedObjects) > 0) { foreach ($relatedObjects as $object) { if ( ! isset($deletions[$object->getOid()])) { $this->_collectDeletions($object, $deletions); } } } } } } public function saveRelated(Doctrine_Record $record) { $saveLater = array(); foreach ($record->getReferences() as $k => $v) { $rel = $record->getTable()->getRelation($k); $local = $rel->getLocal(); $foreign = $rel->getForeign(); if ($rel instanceof Doctrine_Relation_ForeignKey) { $saveLater[$k] = $rel; } else if ($rel instanceof Doctrine_Relation_LocalKey) { $obj = $record->get($rel->getAlias()); if ($obj instanceof Doctrine_Record && $obj->isModified()) { $obj->save($this->conn); $id = array_values($obj->identifier()); if ( ! empty($id)) { foreach ((array) $rel->getLocal() as $k => $field) { if (isset($id[$k]) && $id[$k] && $record->getTable()->hasField($field)) { $record->set($field, $id[$k]); } } } } } } return $saveLater; } public function saveAssociations(Doctrine_Record $record) { foreach ($record->getReferences() as $k => $v) { $rel = $record->getTable()->getRelation($k); if ($rel instanceof Doctrine_Relation_Association) { $v->save($this->conn, false); $assocTable = $rel->getAssociationTable(); foreach ($v->getDeleteDiff() as $r) { $query = 'DELETE FROM ' . $assocTable->getTableName() . ' WHERE ' . $rel->getForeign() . ' = ?' . ' AND ' . $rel->getLocal() . ' = ?'; $this->conn->execute($query, array($r->getIncremented(), $record->getIncremented())); } foreach ($v->getInsertDiff() as $r) { $assocRecord = $assocTable->create(); $assocRecord->set($assocTable->getFieldName($rel->getForeign()), $r); $assocRecord->set($assocTable->getFieldName($rel->getLocal()), $record); $this->saveGraph($assocRecord); } $v->takeSnapshot(); } } } private function _preDelete(Doctrine_Record $record) { $event = new Doctrine_Event($record, Doctrine_Event::RECORD_DELETE); $record->preDelete($event); $record->getTable()->getRecordListener()->preDelete($event); return $event->skipOperation; } private function _postDelete(Doctrine_Record $record) { $event = new Doctrine_Event($record, Doctrine_Event::RECORD_DELETE); $record->postDelete($event); $record->getTable()->getRecordListener()->postDelete($event); } public function saveAll() { $tree = $this->buildFlushTree($this->conn->getTables()); foreach ($tree as $name) { $table = $this->conn->getTable($name); foreach ($table->getRepository() as $record) { $this->saveGraph($record); } } } public function update(Doctrine_Record $record) { $event = new Doctrine_Event($record, Doctrine_Event::RECORD_UPDATE); $record->preUpdate($event); $table = $record->getTable(); $table->getRecordListener()->preUpdate($event); if ( ! $event->skipOperation) { $identifier = $record->identifier(); if ($table->getOption('joinedParents')) { $this->_updateCTIRecord($table, $record); } else { $array = $record->getPrepared(); $this->conn->update($table, $array, $identifier); } $record->assignIdentifier(true); } $table->getRecordListener()->postUpdate($event); $record->postUpdate($event); return true; } public function insert(Doctrine_Record $record) { $event = new Doctrine_Event($record, Doctrine_Event::RECORD_INSERT); $record->preInsert($event); $table = $record->getTable(); $table->getRecordListener()->preInsert($event); if ( ! $event->skipOperation) { if ($table->getOption('joinedParents')) { $this->_insertCTIRecord($table, $record); } else { $this->processSingleInsert($record); } } $table->addRecord($record); $table->getRecordListener()->postInsert($event); $record->postInsert($event); return true; } public function processSingleInsert(Doctrine_Record $record) { $fields = $record->getPrepared(); $table = $record->getTable(); if (empty($fields)) { foreach ($table->getFieldNames() as $field) { $fields[$field] = null; } } $identifier = (array) $table->getIdentifier(); $seq = $record->getTable()->sequenceName; if ( ! empty($seq)) { $id = $this->conn->sequence->nextId($seq); $seqName = $table->getIdentifier(); $fields[$seqName] = $id; $record->assignIdentifier($id); } $this->conn->insert($table, $fields); if (empty($seq) && count($identifier) == 1 && $identifier[0] == $table->getIdentifier() && $table->getIdentifierType() != Doctrine::IDENTIFIER_NATURAL) { if (($driver = strtolower($this->conn->getDriverName())) == 'pgsql') { $seq = $table->getTableName() . '_' . $identifier[0]; } elseif ($driver == 'oracle') { $seq = $table->getTableName(); } $id = $this->conn->sequence->lastInsertId($seq); if ( ! $id) { throw new Doctrine_Connection_Exception("Couldn't get last insert identifier."); } $record->assignIdentifier($id); } else { $record->assignIdentifier(true); } } public function buildFlushTree(array $tables) { $classesToOrder = array(); foreach ($tables as $table) { if ( ! ($table instanceof Doctrine_Table)) { $table = $this->conn->getTable($table, false); } $classesToOrder[] = $table->getComponentName(); } $classesToOrder = array_unique($classesToOrder); if (count($classesToOrder) < 2) { return $classesToOrder; } $flushList = array(); foreach ($classesToOrder as $class) { $table = $this->conn->getTable($class, false); $currentClass = $table->getComponentName(); $index = array_search($currentClass, $flushList); if ($index === false) { $flushList[] = $currentClass; $index = max(array_keys($flushList)); } $rels = $table->getRelations(); foreach ($rels as $key => $rel) { if ($rel instanceof Doctrine_Relation_ForeignKey) { unset($rels[$key]); array_unshift($rels, $rel); } } foreach ($rels as $rel) { $relatedClassName = $rel->getTable()->getComponentName(); if ( ! in_array($relatedClassName, $classesToOrder)) { continue; } $relatedCompIndex = array_search($relatedClassName, $flushList); $type = $rel->getType(); if ($relatedClassName === $currentClass) { continue; } if ($rel instanceof Doctrine_Relation_ForeignKey) { if ($relatedCompIndex !== false) { if ($relatedCompIndex >= $index) { continue; } unset($flushList[$index]); array_splice($flushList, $relatedCompIndex, 0, $currentClass); $index = $relatedCompIndex; } else { $flushList[] = $relatedClassName; } } else if ($rel instanceof Doctrine_Relation_LocalKey) { if ($relatedCompIndex !== false) { if ($relatedCompIndex <= $index) { continue; } unset($flushList[$relatedCompIndex]); array_splice($flushList, $index, 0, $relatedClassName); } else { array_unshift($flushList, $relatedClassName); $index++; } } else if ($rel instanceof Doctrine_Relation_Association) { $assocTable = $rel->getAssociationFactory(); $assocClassName = $assocTable->getComponentName(); if ($relatedCompIndex !== false) { unset($flushList[$relatedCompIndex]); } array_splice($flushList, $index, 0, $relatedClassName); $index++; $index3 = array_search($assocClassName, $flushList); if ($index3 !== false) { if ($index3 >= $index) { continue; } unset($flushList[$index]); array_splice($flushList, $index3, 0, $assocClassName); $index = $relatedCompIndex; } else { $flushList[] = $assocClassName; } } } } return array_values($flushList); } private function _deleteCTIParents(Doctrine_Table $table, $record) { if ($table->getOption('joinedParents')) { foreach (array_reverse($table->getOption('joinedParents')) as $parent) { $parentTable = $table->getConnection()->getTable($parent); $this->conn->delete($parentTable, $record->identifier()); } } } private function _insertCTIRecord(Doctrine_Table $table, Doctrine_Record $record) { $dataSet = $this->_formatDataSet($record); $component = $table->getComponentName(); $classes = $table->getOption('joinedParents'); $classes[] = $component; foreach ($classes as $k => $parent) { if ($k === 0) { $rootRecord = new $parent(); $rootRecord->merge($dataSet[$parent]); $this->processSingleInsert($rootRecord); $record->assignIdentifier($rootRecord->identifier()); } else { foreach ((array) $rootRecord->identifier() as $id => $value) { $dataSet[$parent][$id] = $value; } $this->conn->insert($this->conn->getTable($parent), $dataSet[$parent]); } } } private function _updateCTIRecord(Doctrine_Table $table, Doctrine_Record $record) { $identifier = $record->identifier(); $dataSet = $this->_formatDataSet($record); $component = $table->getComponentName(); $classes = $table->getOption('joinedParents'); $classes[] = $component; foreach ($record as $field => $value) { if ($value instanceof Doctrine_Record) { if ( ! $value->exists()) { $value->save(); } $record->set($field, $value->getIncremented()); } } foreach ($classes as $class) { $parentTable = $this->conn->getTable($class); if ( ! array_key_exists($class, $dataSet)) { continue; } $this->conn->update($this->conn->getTable($class), $dataSet[$class], $identifier); } } private function _formatDataSet(Doctrine_Record $record) { $table = $record->getTable(); $dataSet = array(); $component = $table->getComponentName(); $array = $record->getPrepared(); foreach ($table->getColumns() as $columnName => $definition) { if ( ! isset($dataSet[$component])) { $dataSet[$component] = array(); } $fieldName = $table->getFieldName($columnName); if (isset($definition['primary']) && $definition['primary']) { continue; } if ( ! array_key_exists($fieldName, $array)) { continue; } if (isset($definition['owner'])) { $dataSet[$definition['owner']][$fieldName] = $array[$fieldName]; } else { $dataSet[$component][$fieldName] = $array[$fieldName]; } } return $dataSet; } }class Doctrine_Connection_Mock extends Doctrine_Connection_Common { protected $driverName = 'Mock'; public function __construct(Doctrine_Manager $manager, $adapter) { } }class Doctrine_Validator extends Doctrine_Locator_Injectable { private static $validators = array(); public static function getValidator($name) { if ( ! isset(self::$validators[$name])) { $class = 'Doctrine_Validator_' . ucwords(strtolower($name)); if (class_exists($class)) { self::$validators[$name] = new $class; } else if (class_exists($name)) { self::$validators[$name] = new $name; } else { throw new Doctrine_Exception("Validator named '$name' not available."); } } return self::$validators[$name]; } public function validateRecord(Doctrine_Record $record) { $table = $record->getTable(); $fields = $record->exists() ? $record->getModified():$record->getData(); foreach ($fields as $fieldName => $value) { $table->validateField($fieldName, $value, $record); } } public static function validateLength($value, $type, $maximumLength) { if ($type == 'timestamp' || $type == 'integer' || $type == 'enum') { return true; } else if ($type == 'array' || $type == 'object') { $length = strlen(serialize($value)); } else { $length = self::getStringLength($value); } if ($length > $maximumLength) { return false; } return true; } public static function getStringLength($string) { if (function_exists('iconv_strlen')) { return iconv_strlen($string); } else if (function_exists('mb_strlen')) { return mb_strlen($string); } else { return strlen($string); } } public function hasErrors() { return (count($this->stack) > 0); } public static function isValidType($var, $type) { if ($var instanceof Doctrine_Expression) { return true; } else if ($var === null) { return true; } else if (is_object($var)) { return $type == 'object'; } switch ($type) { case 'float': case 'double': case 'decimal': return (string)$var == strval(floatval($var)); case 'integer': return (string)$var == strval(intval($var)); case 'string': return is_string($var) || is_numeric($var); case 'blob': case 'clob': case 'gzip': return is_string($var); case 'array': return is_array($var); case 'object': return is_object($var); case 'boolean': return is_bool($var) || (is_numeric($var) && ($var == 0 || $var == 1)); case 'timestamp': $validator = self::getValidator('timestamp'); return $validator->validate($var); case 'time': $validator = self::getValidator('time'); return $validator->validate($var); case 'date': $validator = self::getValidator('date'); return $validator->validate($var); case 'enum': return is_string($var) || is_int($var); default: return false; } } }class Doctrine_Sequence extends Doctrine_Connection_Module { public function nextId($seqName, $ondemand = true) { throw new Doctrine_Sequence_Exception('method not implemented'); } public function lastInsertId($table = null, $field = null) { throw new Doctrine_Sequence_Exception('method not implemented'); } public function currId($seqName) { $this->warnings[] = 'database does not support getting current
            sequence value, the sequence value was incremented'; return $this->nextId($seqName); } }class Doctrine_Sequence_Pgsql extends Doctrine_Sequence { public function nextId($seqName, $onDemand = true) { $sequenceName = $this->conn->quoteIdentifier($this->conn->formatter->getSequenceName($seqName), true); $query = "SELECT NEXTVAL('" . $sequenceName . "')"; try { $result = (int) $this->conn->fetchOne($query); } catch(Doctrine_Connection_Exception $e) { if ($onDemand && $e->getPortableCode() == Doctrine::ERR_NOSUCHTABLE) { try { $result = $this->conn->export->createSequence($seqName); } catch(Doctrine_Exception $e) { throw new Doctrine_Sequence_Exception('on demand sequence ' . $seqName . ' could not be created'); } return $this->nextId($seqName, false); } } return $result; } public function lastInsertId($table = null, $field = null) { $seqName = $table . (empty($field) ? '' : '_' . $field); $sequenceName = $this->conn->quoteIdentifier($this->conn->formatter->getSequenceName($seqName), true); return (int) $this->conn->fetchOne("SELECT CURRVAL('" . $sequenceName . "')"); } public function currId($seqName) { $sequenceName = $this->conn->quoteIdentifier($this->conn->formatter->getSequenceName($seqName), true); return (int) $this->conn->fetchOne('SELECT last_value FROM ' . $sequenceName); } }class Doctrine_Sequence_Exception extends Doctrine_Exception { }class Doctrine_Query extends Doctrine_Query_Abstract implements Countable, Serializable { protected static $_keywords = array('ALL', 'AND', 'ANY', 'AS', 'ASC', 'AVG', 'BETWEEN', 'BIT_LENGTH', 'BY', 'CHARACTER_LENGTH', 'CHAR_LENGTH', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP', 'DELETE', 'DESC', 'DISTINCT', 'EMPTY', 'EXISTS', 'FALSE', 'FETCH', 'FROM', 'GROUP', 'HAVING', 'IN', 'INDEXBY', 'INNER', 'IS', 'JOIN', 'LEFT', 'LIKE', 'LOWER', 'MEMBER', 'MOD', 'NEW', 'NOT', 'NULL', 'OBJECT', 'OF', 'OR', 'ORDER', 'OUTER', 'POSITION', 'SELECT', 'SOME', 'TRIM', 'TRUE', 'UNKNOWN', 'UPDATE', 'WHERE'); protected $_subqueryAliases = array(); protected $_aggregateAliasMap = array(); protected $_pendingAggregates = array(); protected $_needsSubquery = false; protected $_isSubquery; protected $_neededTables = array(); protected $_pendingSubqueries = array(); protected $_pendingFields = array(); protected $_parsers = array(); protected $_pendingJoinConditions = array(); protected $_expressionMap = array(); protected $_sql; public static function create($conn = null) { return new Doctrine_Query($conn); } public function reset() { $this->_subqueryAliases = array(); $this->_aggregateAliasMap = array(); $this->_pendingAggregates = array(); $this->_pendingJoinConditions = array(); $this->_pendingSubqueries = array(); $this->_pendingFields = array(); $this->_neededTables = array(); $this->_expressionMap = array(); $this->_subqueryAliases = array(); $this->_needsSubquery = false; $this->_isLimitSubqueryUsed = false; } public function createSubquery() { $class = get_class($this); $obj = new $class(); $obj->copySubqueryInfo($this); $obj->isSubquery(true); return $obj; } protected function _addPendingJoinCondition($componentAlias, $joinCondition) { $this->_pendingJoins[$componentAlias] = $joinCondition; } public function fetchArray($params = array()) { return $this->execute($params, Doctrine::HYDRATE_ARRAY); } public function fetchOne($params = array(), $hydrationMode = null) { $collection = $this->execute($params, $hydrationMode); if (count($collection) === 0) { return false; } if ($collection instanceof Doctrine_Collection) { return $collection->getFirst(); } else if (is_array($collection)) { return array_shift($collection); } return false; } public function isSubquery($bool = null) { if ($bool === null) { return $this->_isSubquery; } $this->_isSubquery = (bool) $bool; return $this; } public function getAggregateAlias($dqlAlias) { return $this->getSqlAggregateAlias($dqlAlias); } public function getSqlAggregateAlias($dqlAlias) { if (isset($this->_aggregateAliasMap[$dqlAlias])) { $this->_expressionMap[$dqlAlias][1] = true; return $this->_aggregateAliasMap[$dqlAlias]; } else if ( ! empty($this->_pendingAggregates)) { $this->processPendingAggregates(); return $this->getSqlAggregateAlias($dqlAlias); } else { throw new Doctrine_Query_Exception('Unknown aggregate alias: ' . $dqlAlias); } } public function getDqlPart($queryPart) { if ( ! isset($this->_dqlParts[$queryPart])) { throw new Doctrine_Query_Exception('Unknown query part ' . $queryPart); } return $this->_dqlParts[$queryPart]; } public function contains($dql) { return stripos($this->getDql(), $dql) === false ? false : true; } public function processPendingFields($componentAlias) { $tableAlias = $this->getTableAlias($componentAlias); $table = $this->_queryComponents[$componentAlias]['table']; if ( ! isset($this->_pendingFields[$componentAlias])) { if ($this->_hydrator->getHydrationMode() != Doctrine::HYDRATE_NONE) { if ( ! $this->_isSubquery && $componentAlias == $this->getRootAlias()) { throw new Doctrine_Query_Exception("The root class of the query (alias $componentAlias) " . " must have at least one field selected."); } } return; } if ( ! $this->isSubquery() && isset($this->_queryComponents[$componentAlias]['parent'])) { $parentAlias = $this->_queryComponents[$componentAlias]['parent']; if (is_string($parentAlias) && ! isset($this->_pendingFields[$parentAlias]) && $this->_hydrator->getHydrationMode() != Doctrine::HYDRATE_NONE) { throw new Doctrine_Query_Exception("The left side of the join between " . "the aliases '$parentAlias' and '$componentAlias' must have at least" . " the primary key field(s) selected."); } } $fields = $this->_pendingFields[$componentAlias]; if (in_array('*', $fields)) { $fields = $table->getFieldNames(); } else { if ( ! $this->_isSubquery && $this->_hydrator->getHydrationMode() != Doctrine::HYDRATE_NONE) { $fields = array_unique(array_merge((array) $table->getIdentifier(), $fields)); } } $sql = array(); foreach ($fields as $fieldName) { $columnName = $table->getColumnName($fieldName); if (($owner = $table->getColumnOwner($columnName)) !== null && $owner !== $table->getComponentName()) { $parent = $this->_conn->getTable($owner); $columnName = $parent->getColumnName($fieldName); $parentAlias = $this->getTableAlias($componentAlias . '.' . $parent->getComponentName()); $sql[] = $this->_conn->quoteIdentifier($parentAlias . '.' . $columnName) . ' AS ' . $this->_conn->quoteIdentifier($tableAlias . '__' . $columnName); } else { $columnName = $table->getColumnName($fieldName); $sql[] = $this->_conn->quoteIdentifier($tableAlias . '.' . $columnName) . ' AS ' . $this->_conn->quoteIdentifier($tableAlias . '__' . $columnName); } } $this->_neededTables[] = $tableAlias; return implode(', ', $sql); } public function parseSelectField($field) { $terms = explode('.', $field); if (isset($terms[1])) { $componentAlias = $terms[0]; $field = $terms[1]; } else { reset($this->_queryComponents); $componentAlias = key($this->_queryComponents); $fields = $terms[0]; } $tableAlias = $this->getTableAlias($componentAlias); $table = $this->_queryComponents[$componentAlias]['table']; if ($field === '*') { $sql = array(); foreach ($table->getColumnNames() as $field) { $sql[] = $this->parseSelectField($componentAlias . '.' . $field); } return implode(', ', $sql); } else { $name = $table->getColumnName($field); $this->_neededTables[] = $tableAlias; return $this->_conn->quoteIdentifier($tableAlias . '.' . $name) . ' AS ' . $this->_conn->quoteIdentifier($tableAlias . '__' . $name); } } public function getExpressionOwner($expr) { if (strtoupper(substr(trim($expr, '( '), 0, 6)) !== 'SELECT') { preg_match_all("/[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*[\.[a-z0-9]+]*/i", $expr, $matches); $match = current($matches); if (isset($match[0])) { $terms = explode('.', $match[0]); return $terms[0]; } } return $this->getRootAlias(); } public function parseSelect($dql) { $refs = $this->_tokenizer->sqlExplode($dql, ','); $pos = strpos(trim($refs[0]), ' '); $first = substr($refs[0], 0, $pos); if ($first === 'DISTINCT') { $this->_sqlParts['distinct'] = true; $refs[0] = substr($refs[0], ++$pos); } $parsedComponents = array(); foreach ($refs as $reference) { $reference = trim($reference); if (empty($reference)) { continue; } $terms = $this->_tokenizer->sqlExplode($reference, ' '); $pos = strpos($terms[0], '('); if (count($terms) > 1 || $pos !== false) { $expression = array_shift($terms); $alias = array_pop($terms); if ( ! $alias) { $alias = substr($expression, 0, $pos); } $componentAlias = $this->getExpressionOwner($expression); $expression = $this->parseClause($expression); $tableAlias = $this->getTableAlias($componentAlias); $index = count($this->_aggregateAliasMap); $sqlAlias = $this->_conn->quoteIdentifier($tableAlias . '__' . $index); $this->_sqlParts['select'][] = $expression . ' AS ' . $sqlAlias; $this->_aggregateAliasMap[$alias] = $sqlAlias; $this->_expressionMap[$alias][0] = $expression; $this->_queryComponents[$componentAlias]['agg'][$index] = $alias; $this->_neededTables[] = $tableAlias; } else { $e = explode('.', $terms[0]); if (isset($e[1])) { $componentAlias = $e[0]; $field = $e[1]; } else { reset($this->_queryComponents); $componentAlias = key($this->_queryComponents); $field = $e[0]; } $this->_pendingFields[$componentAlias][] = $field; } } } public function parseClause($clause) { $clause = trim($clause); if (is_numeric($clause)) { return $clause; } $terms = $this->_tokenizer->clauseExplode($clause, array(' ', '+', '-', '*', '/', '<', '>', '=', '>=', '<=')); $str = ''; foreach ($terms as $term) { $pos = strpos($term[0], '('); if ($pos !== false) { $name = substr($term[0], 0, $pos); $term[0] = $this->parseFunctionExpression($term[0]); } else { if (substr($term[0], 0, 1) !== "'" && substr($term[0], -1) !== "'") { if (strpos($term[0], '.') !== false) { if ( ! is_numeric($term[0])) { $e = explode('.', $term[0]); $field = array_pop($e); if ($this->getType() === Doctrine_Query::SELECT) { $componentAlias = implode('.', $e); if (empty($componentAlias)) { $componentAlias = $this->getRootAlias(); } $this->load($componentAlias); if ( ! isset($this->_queryComponents[$componentAlias])) { throw new Doctrine_Query_Exception('Unknown component alias ' . $componentAlias); } $table = $this->_queryComponents[$componentAlias]['table']; $def = $table->getDefinitionOf($field); $field = $table->getColumnName($field); if ( ! $def) { throw new Doctrine_Query_Exception('Unknown column ' . $field); } if (isset($def['owner'])) { $componentAlias = $componentAlias . '.' . $def['owner']; } $tableAlias = $this->getTableAlias($componentAlias); $term[0] = $this->_conn->quoteIdentifier($tableAlias) . '.' . $this->_conn->quoteIdentifier($field); } else { $field = $this->getRoot()->getColumnName($field); $term[0] = $this->_conn->quoteIdentifier($field); } } } else { if ( ! empty($term[0]) && ! in_array(strtoupper($term[0]), self::$_keywords) && ! is_numeric($term[0]) && $term[0] !== '?' && substr($term[0], 0, 1) !== ':') { $componentAlias = $this->getRootAlias(); $found = false; if ($componentAlias !== false && $componentAlias !== null) { $table = $this->_queryComponents[$componentAlias]['table']; if ($table->hasField($term[0])) { $found = true; $def = $table->getDefinitionOf($term[0]); $term[0] = $table->getColumnName($term[0]); if (isset($def['owner'])) { $componentAlias = $componentAlias . '.' . $def['owner']; } $tableAlias = $this->getTableAlias($componentAlias); if ($this->getType() === Doctrine_Query::SELECT) { $term[0] = $this->_conn->quoteIdentifier($tableAlias) . '.' . $this->_conn->quoteIdentifier($term[0]); } else { $term[0] = $this->_conn->quoteIdentifier($term[0]); } } else { $found = false; } } if ( ! $found) { $term[0] = $this->getSqlAggregateAlias($term[0]); } } } } } $str .= $term[0] . $term[1]; } return $str; } public function parseIdentifierReference($expr) { } public function parseFunctionExpression($expr) { $pos = strpos($expr, '('); $name = substr($expr, 0, $pos); if ($name === '') { return $this->parseSubquery($expr); } $argStr = substr($expr, ($pos + 1), -1); $args = array(); foreach ($this->_tokenizer->sqlExplode($argStr, ',') as $arg) { $args[] = $this->parseClause($arg); } try { $expr = call_user_func_array(array($this->_conn->expression, $name), $args); } catch (Doctrine_Expression_Exception $e) { throw new Doctrine_Query_Exception('Unknown function ' . $name . '.'); } return $expr; } public function parseSubquery($subquery) { $trimmed = trim($this->_tokenizer->bracketTrim($subquery)); if (substr($trimmed, 0, 4) == 'FROM' || substr($trimmed, 0, 6) == 'SELECT') { $q = $this->createSubquery()->parseDqlQuery($trimmed); $trimmed = $q->getSql(); } else { $trimmed = $this->parseClause($trimmed); } return '(' . $trimmed . ')'; } public function processPendingSubqueries() { foreach ($this->_pendingSubqueries as $value) { list($dql, $alias) = $value; $subquery = $this->createSubquery(); $sql = $subquery->parseDqlQuery($dql, false)->getQuery(); reset($this->_queryComponents); $componentAlias = key($this->_queryComponents); $tableAlias = $this->getTableAlias($componentAlias); $sqlAlias = $tableAlias . '__' . count($this->_aggregateAliasMap); $this->_sqlParts['select'][] = '(' . $sql . ') AS ' . $this->_conn->quoteIdentifier($sqlAlias); $this->_aggregateAliasMap[$alias] = $sqlAlias; $this->_queryComponents[$componentAlias]['agg'][] = $alias; } $this->_pendingSubqueries = array(); } public function processPendingAggregates() { foreach ($this->_pendingAggregates as $aggregate) { list ($expression, $components, $alias) = $aggregate; $tableAliases = array(); if ( ! empty ($components)) { foreach ($components as $component) { if (is_numeric($component)) { continue; } $e = explode('.', $component); $field = array_pop($e); $componentAlias = implode('.', $e); if ( ! isset($this->_queryComponents[$componentAlias])) { throw new Doctrine_Query_Exception('Unknown component alias ' . $componentAlias); } $table = $this->_queryComponents[$componentAlias]['table']; $field = $table->getColumnName($field); if ( ! $table->hasColumn($field)) { throw new Doctrine_Query_Exception('Unknown column ' . $field); } $sqlTableAlias = $this->getSqlTableAlias($componentAlias); $tableAliases[$sqlTableAlias] = true; $identifier = $this->_conn->quoteIdentifier($sqlTableAlias . '.' . $field); $expression = str_replace($component, $identifier, $expression); } } if (count($tableAliases) !== 1) { $componentAlias = reset($this->_tableAliasMap); $tableAlias = key($this->_tableAliasMap); } $index = count($this->_aggregateAliasMap); $sqlAlias = $this->_conn->quoteIdentifier($tableAlias . '__' . $index); $this->_sqlParts['select'][] = $expression . ' AS ' . $sqlAlias; $this->_aggregateAliasMap[$alias] = $sqlAlias; $this->_expressionMap[$alias][0] = $expression; $this->_queryComponents[$componentAlias]['agg'][$index] = $alias; $this->_neededTables[] = $tableAlias; } $this->_pendingAggregates = array(); } protected function _buildSqlQueryBase() { switch ($this->_type) { case self::DELETE: $q = 'DELETE FROM '; break; case self::UPDATE: $q = 'UPDATE '; break; case self::SELECT: $distinct = ($this->_sqlParts['distinct']) ? 'DISTINCT ' : ''; $q = 'SELECT ' . $distinct . implode(', ', $this->_sqlParts['select']) . ' FROM '; break; } return $q; } protected function _buildSqlFromPart() { $q = ''; foreach ($this->_sqlParts['from'] as $k => $part) { if ($k === 0) { $q .= $part; continue; } if (!preg_match('/\bJOIN\b/i', $part) && !isset($this->_pendingJoinConditions[$k])) { $q .= ', ' . $part; } else { $e = explode(' ', $part); if (substr($part, 0, 9) === 'LEFT JOIN') { $aliases = array_merge($this->_subqueryAliases, array_keys($this->_neededTables)); if ( ! in_array($e[3], $aliases) && ! in_array($e[2], $aliases) && ! empty($this->_pendingFields)) { continue; } } if (isset($this->_pendingJoinConditions[$k])) { $parser = new Doctrine_Query_JoinCondition($this, $this->_tokenizer); if (strpos($part, ' ON ') !== false) { $part .= ' AND '; } else { $part .= ' ON '; } $part .= $parser->parse($this->_pendingJoinConditions[$k]); unset($this->_pendingJoinConditions[$k]); } $componentAlias = $this->getComponentAlias($e[3]); $string = $this->getInheritanceCondition($componentAlias); if ($string) { $q .= ' ' . $part . ' AND ' . $string; } else { $q .= ' ' . $part; } } $this->_sqlParts['from'][$k] = $part; } return $q; } public function getSqlQuery($params = array()) { if ($this->_state !== self::STATE_DIRTY) { return $this->_sql; } if ( ! $this->isSubquery()) { $this->_queryComponents = array(); $this->_pendingAggregates = array(); $this->_aggregateAliasMap = array(); } $this->reset(); $this->_preQuery(); foreach ($this->_dqlParts as $queryPartName => $queryParts) { if ($queryPartName != 'forUpdate') { $this->_processDqlQueryPart($queryPartName, $queryParts); } } $this->_state = self::STATE_CLEAN; if (empty($this->_sqlParts['from'])) { return false; } $needsSubQuery = false; $subquery = ''; $map = reset($this->_queryComponents); $table = $map['table']; $rootAlias = key($this->_queryComponents); if ( ! empty($this->_sqlParts['limit']) && $this->_needsSubquery && $table->getAttribute(Doctrine::ATTR_QUERY_LIMIT) == Doctrine::LIMIT_RECORDS) { if (count($this->_pendingFields) > 1 || ! isset($this->_pendingFields[$this->getRootAlias()]) || ! $this->_sqlParts['distinct']) { $this->_isLimitSubqueryUsed = true; $needsSubQuery = true; } } $sql = array(); if ( ! empty($this->_pendingFields)) { foreach ($this->_queryComponents as $alias => $map) { $fieldSql = $this->processPendingFields($alias); if ( ! empty($fieldSql)) { $sql[] = $fieldSql; } } } if ( ! empty($sql)) { array_unshift($this->_sqlParts['select'], implode(', ', $sql)); } $this->_pendingFields = array(); $q = $this->_buildSqlQueryBase(); $q .= $this->_buildSqlFromPart(); if ( ! empty($this->_sqlParts['set'])) { $q .= ' SET ' . implode(', ', $this->_sqlParts['set']); } $string = $this->getInheritanceCondition($this->getRootAlias()); if ( ! empty($string)) { if (count($this->_sqlParts['where']) > 0) { $this->_sqlParts['where'][] = 'AND'; } if (substr($string, 0, 1) === '(' && substr($string, -1) === ')') { $this->_sqlParts['where'][] = $string; } else { $this->_sqlParts['where'][] = '(' . $string . ')'; } } $modifyLimit = true; if ( ( ! empty($this->_sqlParts['limit']) || ! empty($this->_sqlParts['offset'])) && $needsSubQuery) { $subquery = $this->getLimitSubquery(); $idColumnName = $table->getColumnName($table->getIdentifier()); switch (strtolower($this->_conn->getDriverName())) { case 'mysql': $list = $this->_conn->execute($subquery, $params)->fetchAll(Doctrine::FETCH_COLUMN); $subquery = implode(', ', array_map(array($this->_conn, 'quote'), $list)); break; case 'pgsql': $subquery = 'SELECT ' . $this->_conn->quoteIdentifier('doctrine_subquery_alias.' . $idColumnName) . ' FROM (' . $subquery . ') AS doctrine_subquery_alias'; break; } $field = $this->getSqlTableAlias($rootAlias) . '.' . $idColumnName; if ($subquery !== '') { if (count($this->_sqlParts['where']) > 0) { array_unshift($this->_sqlParts['where'], 'AND'); } array_unshift($this->_sqlParts['where'], $this->_conn->quoteIdentifier($field) . ' IN (' . $subquery . ')'); } $modifyLimit = false; } $q .= ( ! empty($this->_sqlParts['where']))? ' WHERE ' . implode(' ', $this->_sqlParts['where']) : ''; $q .= ( ! empty($this->_sqlParts['groupby']))? ' GROUP BY ' . implode(', ', $this->_sqlParts['groupby']) : ''; $q .= ( ! empty($this->_sqlParts['having']))? ' HAVING ' . implode(' AND ', $this->_sqlParts['having']): ''; $q .= ( ! empty($this->_sqlParts['orderby']))? ' ORDER BY ' . implode(', ', $this->_sqlParts['orderby']) : ''; if ($modifyLimit) { $q = $this->_conn->modifyLimitQuery($q, $this->_sqlParts['limit'], $this->_sqlParts['offset']); } $q .= $this->_sqlParts['forUpdate'] === true ? ' FOR UPDATE ' : ''; if ( ! empty($string)) { if (count($this->_sqlParts['where']) > 2) { array_pop($this->_sqlParts['where']); } array_pop($this->_sqlParts['where']); } if ($needsSubQuery) { if (count($this->_sqlParts['where']) > 2) { array_shift($this->_sqlParts['where']); } array_shift($this->_sqlParts['where']); } $this->_sql = $q; return $q; } public function getLimitSubquery() { $map = reset($this->_queryComponents); $table = $map['table']; $componentAlias = key($this->_queryComponents); $alias = $this->getTableAlias($componentAlias); $primaryKey = $alias . '.' . $table->getColumnName($table->getIdentifier()); $driverName = $this->_conn->getAttribute(Doctrine::ATTR_DRIVER_NAME); if (($driverName == 'oracle' || $driverName == 'oci') && $this->_isOrderedByJoinedColumn()) { $subquery = 'SELECT '; } else { $subquery = 'SELECT DISTINCT '; } $subquery .= $this->_conn->quoteIdentifier($primaryKey); if ($driverName == 'pgsql' || $driverName == 'oracle' || $driverName == 'oci') { foreach ($this->_sqlParts['orderby'] as $part) { $part = trim($part); $e = $this->_tokenizer->bracketExplode($part, ' '); $part = trim($e[0]); if (strpos($part, '.') === false) { continue; } if (strpos($part, '(') !== false) { continue; } if ($part !== $primaryKey) { $subquery .= ', ' . $part; } } } if ($driverName == 'mysql' || $driverName == 'pgsql') { foreach ($this->_expressionMap as $dqlAlias => $expr) { if (isset($expr[1])) { $subquery .= ', ' . $expr[0] . ' AS ' . $this->_aggregateAliasMap[$dqlAlias]; } } } $subquery .= ' FROM'; foreach ($this->_sqlParts['from'] as $part) { if (substr($part, 0, 9) === 'LEFT JOIN') { $e = explode(' ', $part); if (empty($this->_sqlParts['orderby']) && empty($this->_sqlParts['where'])) { continue; } } $subquery .= ' ' . $part; } $subquery .= ( ! empty($this->_sqlParts['where']))? ' WHERE ' . implode(' ', $this->_sqlParts['where']) : ''; $subquery .= ( ! empty($this->_sqlParts['groupby']))? ' GROUP BY ' . implode(', ', $this->_sqlParts['groupby']) : ''; $subquery .= ( ! empty($this->_sqlParts['having']))? ' HAVING ' . implode(' AND ', $this->_sqlParts['having']) : ''; $subquery .= ( ! empty($this->_sqlParts['orderby']))? ' ORDER BY ' . implode(', ', $this->_sqlParts['orderby']) : ''; if (($driverName == 'oracle' || $driverName == 'oci') && $this->_isOrderedByJoinedColumn()) { $subquery = 'SELECT doctrine_subquery_alias.' . $table->getColumnName($table->getIdentifier()) . ' FROM (' . $subquery . ') doctrine_subquery_alias' . ' GROUP BY doctrine_subquery_alias.' . $table->getColumnName($table->getIdentifier()) . ' ORDER BY MIN(ROWNUM)'; } $subquery = $this->_conn->modifyLimitSubquery($table, $subquery, $this->_sqlParts['limit'], $this->_sqlParts['offset']); $parts = $this->_tokenizer->quoteExplode($subquery, ' ', "'", "'"); foreach ($parts as $k => $part) { if (strpos($part, ' ') !== false) { continue; } $part = str_replace(array('"', "'", '`'), "", $part); if ($this->hasSqlTableAlias($part)) { $parts[$k] = $this->_conn->quoteIdentifier($this->generateNewSqlTableAlias($part)); continue; } if (strpos($part, '.') === false) { continue; } preg_match_all("/[a-zA-Z0-9_]+\.[a-z0-9_]+/i", $part, $m); foreach ($m[0] as $match) { $e = explode('.', $match); $e2 = array(); foreach ($e as $k2 => $v2) { $e2[$k2] = $this->_conn->quoteIdentifier($v2); } $match = implode('.', $e2); $e[0] = $this->generateNewSqlTableAlias($e[0]); foreach ($e as $k2 => $v2) { $e[$k2] = $this->_conn->quoteIdentifier($v2); } $replace = implode('.' , $e); $parts[$k] = str_replace($match, $replace, $parts[$k]); } } if ($driverName == 'mysql' || $driverName == 'pgsql') { foreach ($parts as $k => $part) { if (strpos($part, "'") !== false) { continue; } if (strpos($part, '__') == false) { continue; } preg_match_all("/[a-zA-Z0-9_]+\_\_[a-z0-9_]+/i", $part, $m); foreach ($m[0] as $match) { $e = explode('__', $match); $e[0] = $this->generateNewTableAlias($e[0]); $parts[$k] = str_replace($match, implode('__', $e), $parts[$k]); } } } $subquery = implode(' ', $parts); return $subquery; } private function _isOrderedByJoinedColumn() { if ( ! $this->_queryComponents) { throw new Doctrine_Query_Exception("The query is in an invalid state for this " . "operation. It must have been fully parsed first."); } $componentAlias = key($this->_queryComponents); $mainTableAlias = $this->getTableAlias($componentAlias); foreach ($this->_sqlParts['orderby'] as $part) { $part = trim($part); $e = $this->_tokenizer->bracketExplode($part, ' '); $part = trim($e[0]); if (strpos($part, '.') === false) { continue; } list($tableAlias, $columnName) = explode('.', $part); if ($tableAlias != $mainTableAlias) { return true; } } return false; } public function parseDqlQuery($query, $clear = true) { if ($clear) { $this->clear(); } $query = trim($query); $query = str_replace("\r", "\n", str_replace("\r\n", "\n", $query)); $query = str_replace("\n", ' ', $query); $parts = $this->_tokenizer->tokenizeQuery($query); foreach ($parts as $partName => $subParts) { $subParts = trim($subParts); $partName = strtolower($partName); switch ($partName) { case 'create': $this->_type = self::CREATE; break; case 'insert': $this->_type = self::INSERT; break; case 'delete': $this->_type = self::DELETE; break; case 'select': $this->_type = self::SELECT; $this->_addDqlQueryPart($partName, $subParts); break; case 'update': $this->_type = self::UPDATE; $partName = 'from'; case 'from': $this->_addDqlQueryPart($partName, $subParts); break; case 'set': $this->_addDqlQueryPart($partName, $subParts, true); break; case 'group': case 'order': $partName .= 'by'; case 'where': case 'having': case 'limit': case 'offset': $this->_addDqlQueryPart($partName, $subParts); break; } } return $this; } public function load($path, $loadFields = true) { if (isset($this->_queryComponents[$path])) { return $this->_queryComponents[$path]; } $e = $this->_tokenizer->quoteExplode($path, ' INDEXBY '); $mapWith = null; if (count($e) > 1) { $mapWith = trim($e[1]); $path = $e[0]; } $e = explode(' ON ', str_ireplace(' on ', ' ON ', $path)); $joinCondition = ''; if (count($e) > 1) { $joinCondition = substr($path, strlen($e[0]) + 4, strlen($e[1])); $path = substr($path, 0, strlen($e[0])); $overrideJoin = true; } else { $e = explode(' WITH ', str_ireplace(' with ', ' WITH ', $path)); if (count($e) > 1) { $joinCondition = substr($path, strlen($e[0]) + 6, strlen($e[1])); $path = substr($path, 0, strlen($e[0])); } $overrideJoin = false; } $tmp = explode(' ', $path); $componentAlias = $originalAlias = (count($tmp) > 1) ? end($tmp) : null; $e = preg_split("/[.:]/", $tmp[0], -1); $fullPath = $tmp[0]; $prevPath = ''; $fullLength = strlen($fullPath); if (isset($this->_queryComponents[$e[0]])) { $table = $this->_queryComponents[$e[0]]['table']; $componentAlias = $e[0]; $prevPath = $parent = array_shift($e); } foreach ($e as $key => $name) { $length = strlen($prevPath); $prevPath = ($prevPath) ? $prevPath . '.' . $name : $name; $delimeter = substr($fullPath, $length, 1); if (strlen($prevPath) === $fullLength && isset($originalAlias)) { $componentAlias = $originalAlias; } else { $componentAlias = $prevPath; } if (isset($this->_queryComponents[$componentAlias])) { throw new Doctrine_Query_Exception("Duplicate alias '$componentAlias' in query."); } if ( ! isset($table)) { $table = $this->loadRoot($name, $componentAlias); } else { $join = ($delimeter == ':') ? 'INNER JOIN ' : 'LEFT JOIN '; $relation = $table->getRelation($name); $localTable = $table; $table = $relation->getTable(); $this->_queryComponents[$componentAlias] = array('table' => $table, 'parent' => $parent, 'relation' => $relation, 'map' => null); if ( ! $relation->isOneToOne()) { $this->_needsSubquery = true; } $localAlias = $this->getTableAlias($parent, $localTable->getTableName()); $foreignAlias = $this->getTableAlias($componentAlias, $relation->getTable()->getTableName()); $foreignSql = $this->_conn->quoteIdentifier($relation->getTable()->getTableName()) . ' ' . $this->_conn->quoteIdentifier($foreignAlias); $map = $relation->getTable()->inheritanceMap; if ( ! $loadFields || ! empty($map) || $joinCondition) { $this->_subqueryAliases[] = $foreignAlias; } if ($relation instanceof Doctrine_Relation_Association) { $asf = $relation->getAssociationTable(); $assocTableName = $asf->getTableName(); if ( ! $loadFields || ! empty($map) || $joinCondition) { $this->_subqueryAliases[] = $assocTableName; } $assocPath = $prevPath . '.' . $asf->getComponentName(); $this->_queryComponents[$assocPath] = array( 'parent' => $prevPath, 'relation' => $relation, 'table' => $asf); $assocAlias = $this->getTableAlias($assocPath, $asf->getTableName()); $queryPart = $join . $this->_conn->quoteIdentifier($assocTableName) . ' ' . $this->_conn->quoteIdentifier($assocAlias); $queryPart .= ' ON ' . $this->_conn->quoteIdentifier($localAlias . '.' . $localTable->getColumnName($localTable->getIdentifier())) . ' = ' . $this->_conn->quoteIdentifier($assocAlias . '.' . $relation->getLocalRefColumnName()); if ($relation->isEqual()) { $queryPart .= ' OR ' . $this->_conn->quoteIdentifier($localAlias . '.' . $table->getColumnName($table->getIdentifier())) . ' = ' . $this->_conn->quoteIdentifier($assocAlias . '.' . $relation->getForeignRefColumnName()); } $this->_sqlParts['from'][] = $queryPart; $queryPart = $join . $foreignSql; if ( ! $overrideJoin) { $queryPart .= $this->buildAssociativeRelationSql($relation, $assocAlias, $foreignAlias, $localAlias); } } else { $queryPart = $this->buildSimpleRelationSql($relation, $foreignAlias, $localAlias, $overrideJoin, $join); } $queryPart .= $this->buildInheritanceJoinSql($table->getComponentName(), $componentAlias); $this->_sqlParts['from'][$componentAlias] = $queryPart; if ( ! empty($joinCondition)) { $this->_pendingJoinConditions[$componentAlias] = $joinCondition; } } if ($loadFields) { $restoreState = false; if ($loadFields && empty($this->_dqlParts['select'])) { $this->_pendingFields[$componentAlias] = array('*'); } } $parent = $prevPath; } $table = $this->_queryComponents[$componentAlias]['table']; return $this->buildIndexBy($componentAlias, $mapWith); } protected function buildSimpleRelationSql(Doctrine_Relation $relation, $foreignAlias, $localAlias, $overrideJoin, $join) { $queryPart = $join . $this->_conn->quoteIdentifier($relation->getTable()->getTableName()) . ' ' . $this->_conn->quoteIdentifier($foreignAlias); if ( ! $overrideJoin) { $queryPart .= ' ON ' . $this->_conn->quoteIdentifier($localAlias . '.' . $relation->getLocalColumnName()) . ' = ' . $this->_conn->quoteIdentifier($foreignAlias . '.' . $relation->getForeignColumnName()); } return $queryPart; } protected function buildIndexBy($componentAlias, $mapWith = null) { $table = $this->_queryComponents[$componentAlias]['table']; $indexBy = null; if (isset($mapWith)) { $terms = explode('.', $mapWith); if (isset($terms[1])) { $indexBy = $terms[1]; } } elseif ($table->getBoundQueryPart('indexBy') !== null) { $indexBy = $table->getBoundQueryPart('indexBy'); } if ($indexBy !== null) { if ( ! $table->hasColumn($table->getColumnName($indexBy))) { throw new Doctrine_Query_Exception("Couldn't use key mapping. Column " . $indexBy . " does not exist."); } $this->_queryComponents[$componentAlias]['map'] = $indexBy; } return $this->_queryComponents[$componentAlias]; } protected function buildAssociativeRelationSql(Doctrine_Relation $relation, $assocAlias, $foreignAlias, $localAlias) { $table = $relation->getTable(); $queryPart = ' ON '; if ($relation->isEqual()) { $queryPart .= '('; } $localIdentifier = $table->getColumnName($table->getIdentifier()); $queryPart .= $this->_conn->quoteIdentifier($foreignAlias . '.' . $localIdentifier) . ' = ' . $this->_conn->quoteIdentifier($assocAlias . '.' . $relation->getForeignRefColumnName()); if ($relation->isEqual()) { $queryPart .= ' OR ' . $this->_conn->quoteIdentifier($foreignAlias . '.' . $localIdentifier) . ' = ' . $this->_conn->quoteIdentifier($assocAlias . '.' . $relation->getLocalRefColumnName()) . ') AND ' . $this->_conn->quoteIdentifier($foreignAlias . '.' . $localIdentifier) . ' != ' . $this->_conn->quoteIdentifier($localAlias . '.' . $localIdentifier); } return $queryPart; } public function loadRoot($name, $componentAlias) { $manager = Doctrine_Manager::getInstance(); if ($manager->hasConnectionForComponent($name)) { $this->_conn = $manager->getConnectionForComponent($name); } $table = $this->_conn->getTable($name); $tableName = $table->getTableName(); $tableAlias = $this->getTableAlias($componentAlias, $tableName); $queryPart = $this->_conn->quoteIdentifier($tableName); if ($this->_type === self::SELECT) { $queryPart .= ' ' . $this->_conn->quoteIdentifier($tableAlias); } $this->_tableAliasMap[$tableAlias] = $componentAlias; $queryPart .= $this->buildInheritanceJoinSql($name, $componentAlias); $this->_sqlParts['from'][] = $queryPart; $this->_queryComponents[$componentAlias] = array('table' => $table, 'map' => null); return $table; } public function buildInheritanceJoinSql($name, $componentAlias) { $manager = Doctrine_Manager::getInstance(); if ($manager->hasConnectionForComponent($name)) { $this->_conn = $manager->getConnectionForComponent($name); } $table = $this->_conn->getTable($name); $tableName = $table->getTableName(); $tableAlias = $this->getTableAlias($componentAlias, $tableName); $queryPart = ''; foreach ($table->getOption('joinedParents') as $parent) { $parentTable = $this->_conn->getTable($parent); $parentAlias = $componentAlias . '.' . $parent; $parentTableAlias = $this->getTableAlias($parentAlias, $parentTable->getTableName()); $queryPart .= ' LEFT JOIN ' . $this->_conn->quoteIdentifier($parentTable->getTableName()) . ' ' . $this->_conn->quoteIdentifier($parentTableAlias) . ' ON '; foreach ((array) $table->getIdentifier() as $identifier) { $column = $table->getColumnName($identifier); $queryPart .= $this->_conn->quoteIdentifier($tableAlias) . '.' . $this->_conn->quoteIdentifier($column) . ' = ' . $this->_conn->quoteIdentifier($parentTableAlias) . '.' . $this->_conn->quoteIdentifier($column); } } return $queryPart; } public function getCountQuery() { $this->getQuery(); $where = $this->_sqlParts['where']; $having = $this->_sqlParts['having']; $groupby = $this->_sqlParts['groupby']; $map = reset($this->_queryComponents); $componentAlias = key($this->_queryComponents); $tableAlias = $this->getTableAlias($componentAlias); $table = $map['table']; $idColumnNames = $table->getIdentifierColumnNames(); $q = 'SELECT COUNT(DISTINCT ' . $this->_conn->quoteIdentifier($tableAlias) . '.' . implode( ' || ' . $this->_conn->quoteIdentifier($tableAlias) . '.', $this->_conn->quoteMultipleIdentifier($idColumnNames) ) . ') AS num_results'; foreach ($this->_sqlParts['select'] as $field) { if (strpos($field, '(') !== false) { $q .= ', ' . $field; } } $q .= ' FROM ' . $this->_buildSqlFromPart(); $string = $this->getInheritanceCondition($this->getRootAlias()); if ( ! empty($string)) { if (count($where) > 0) { $where[] = 'AND'; } $where[] = $string; } $q .= ( ! empty($where)) ? ' WHERE ' . implode(' ', $where) : ''; if ( ! empty($groupby)) { $q .= ' GROUP BY ' . implode(', ', $groupby); } else { $q .= ' GROUP BY ' . $this->_conn->quoteIdentifier($tableAlias) . '.' . implode( ', ' . $this->_conn->quoteIdentifier($tableAlias) . '.', $this->_conn->quoteMultipleIdentifier($idColumnNames) ); } $q .= ( ! empty($having)) ? ' HAVING ' . implode(' AND ', $having): ''; return $q; } public function count($params = array()) { $q = $this->getCountQuery(); if ( ! is_array($params)) { $params = array($params); } $params = array_merge($this->_params['join'], $this->_params['where'], $this->_params['having'], $params); $results = $this->getConnection()->fetchAll($q, $params); if (count($results) > 1) { $count = count($results); } else { if (isset($results[0])) { $results[0] = array_change_key_case($results[0], CASE_LOWER); $count = $results[0]['num_results']; } else { $count = 0; } } return (int) $count; } public function query($query, $params = array(), $hydrationMode = null) { $this->parseDqlQuery($query); return $this->execute($params, $hydrationMode); } public function copy(Doctrine_Query $query = null) { if ( ! $query) { $query = $this; } $new = clone $query; return $new; } public function __clone() { $this->_parsers = array(); if ($this->isSubquery()) { $this->_killReference('_params'); $this->_killReference('_tableAliasMap'); $this->_killReference('_queryComponents'); } } protected function _killReference($key) { $tmp = $this->$key; unset($this->$key); $this->$key = $tmp; } public function free() { $this->reset(); $this->_parsers = array(); $this->_dqlParts = array(); } public function serialize() { $vars = get_object_vars($this); } public function unserialize($serialized) { } }class Doctrine_Locator implements Countable, IteratorAggregate { protected $_resources = array(); protected $_classPrefix = 'Doctrine_'; protected static $_instances = array(); public function __construct(array $defaults = null) { if (null !== $defaults) { foreach ($defaults as $name => $resource) { if ($resource instanceof Doctrine_Locator_Injectable) { $resource->setLocator($this); } $this->_resources[$name] = $resource; } } self::$_instances[] = $this; } public static function instance() { if (empty(self::$_instances)) { $obj = new Doctrine_Locator(); } return current(self::$_instances); } public function setClassPrefix($prefix) { $this->_classPrefix = $prefix; } public function getClassPrefix() { return $this->_classPrefix; } public function contains($name) { return isset($this->_resources[$name]); } public function bind($name, $value) { $this->_resources[$name] = $value; return $this; } public function locate($name) { if (isset($this->_resources[$name])) { return $this->_resources[$name]; } else { $className = $name; if ( ! class_exists($className)) { $name = explode('.', $name); $name = array_map('strtolower', $name); $name = array_map('ucfirst', $name); $name = implode('_', $name); $className = $this->_classPrefix . $name; if ( ! class_exists($className)) { throw new Doctrine_Locator_Exception("Couldn't locate resource " . $className); } } $this->_resources[$name] = new $className(); if ($this->_resources[$name] instanceof Doctrine_Locator_Injectable) { $this->_resources[$name]->setLocator($this); } return $this->_resources[$name]; } throw new Doctrine_Locator_Exception("Couldn't locate resource " . $name); } public function count() { return count($this->_resources); } public function getIterator() { return new ArrayIterator($this->_resources); } } class Doctrine_Hydrator_RecordDriver extends Doctrine_Locator_Injectable { protected $_collections = array(); protected $_tables = array(); private $_initializedRelations = array(); public function getElementCollection($component) { $coll = new Doctrine_Collection($component); $this->_collections[] = $coll; return $coll; } public function getLastKey($coll) { $coll->end(); return $coll->key(); } public function initRelated(Doctrine_Record $record, $name) { if ( ! isset($this->_initializedRelations[$record->getOid()][$name])) { $relation = $record->getTable()->getRelation($name); $coll = new Doctrine_Collection($relation->getTable()->getComponentName()); $coll->setReference($record, $relation); $record[$name] = $coll; $this->_initializedRelations[$record->getOid()][$name] = true; } return true; } public function registerCollection(Doctrine_Collection $coll) { $this->_collections[] = $coll; } public function getNullPointer() { return self::$_null; } public function getElement(array $data, $component) { $component = $this->_getClassNameToReturn($data, $component); if ( ! isset($this->_tables[$component])) { $this->_tables[$component] = Doctrine::getTable($component); $this->_tables[$component]->setAttribute(Doctrine::ATTR_LOAD_REFERENCES, false); } $this->_tables[$component]->setData($data); $record = $this->_tables[$component]->getRecord(); return $record; } public function flush() { foreach ($this->_collections as $key => $coll) { $coll->takeSnapshot(); } foreach ($this->_tables as $table) { $table->setAttribute(Doctrine::ATTR_LOAD_REFERENCES, true); } $this->_initializedRelations = null; $this->_collections = null; $this->_tables = null; } public function setLastElement(&$prev, &$coll, $index, $dqlAlias, $oneToOne) { if ($coll === self::$_null) { unset($prev[$dqlAlias]); return; } if ($index !== false) { $prev[$dqlAlias] = $coll[$index]; return; } if (count($coll) > 0) { $prev[$dqlAlias] = $coll->getLast(); } } protected function _getClassnameToReturn(array &$data, $component) { if ( ! isset($this->_tables[$component])) { $this->_tables[$component] = Doctrine::getTable($component); $this->_tables[$component]->setAttribute(Doctrine::ATTR_LOAD_REFERENCES, false); } if ( ! ($subclasses = $this->_tables[$component]->getOption('subclasses'))) { return $component; } foreach ($subclasses as $subclass) { $table = Doctrine::getTable($subclass); $inheritanceMap = $table->getOption('inheritanceMap'); list($key, $value) = each($inheritanceMap); if ( ! isset($data[$key]) || $data[$key] != $value) { continue; } else { return $table->getComponentName(); } } return $component; } } class Doctrine_Hydrator_Exception extends Doctrine_Exception { }class Doctrine_Hydrator_ArrayDriver { public function getElementCollection($component) { return array(); } public function getElement(array $data, $component) { return $data; } public function registerCollection($coll) { } public function initRelated(array &$data, $name) { if ( ! isset($data[$name])) { $data[$name] = array(); } return true; } public function getNullPointer() { return null; } public function getLastKey(&$data) { end($data); return key($data); } public function setLastElement(&$prev, &$coll, $index, $dqlAlias, $oneToOne) { if ($coll === null) { unset($prev[$dqlAlias]); return; } if ($index !== false) { $prev[$dqlAlias] =& $coll[$index]; return; } if ($coll) { if ($oneToOne) { $prev[$dqlAlias] =& $coll; } else { end($coll); $prev[$dqlAlias] =& $coll[key($coll)]; } } } public function flush() { } } class Doctrine_FileFinder { protected $type = 'file'; protected $names = array(); protected $prunes = array(); protected $discards = array(); protected $execs = array(); protected $minDepth = 0; protected $sizes = array(); protected $maxDepth = 1000000; protected $relative = false; protected $followLink = false; public function maxDepth($level) { $this->maxDepth = $level; return $this; } public function minDepth($level) { $this->minDepth = $level; return $this; } public function getType() { return $this->type; } public static function type($name) { $finder = new Doctrine_FileFinder(); return $finder->setType($name); } public function setType($name) { if (strtolower(substr($name, 0, 3)) == 'dir') { $this->type = 'directory'; } else if (strtolower($name) == 'any') { $this->type = 'any'; } else { $this->type = 'file'; } return $this; } protected function toRegex($str) { if ($str{0} == '/' && $str{strlen($str) - 1} == '/') { return $str; } else { return Doctrine_FileFinder_GlobToRegex::globToRegex($str); } } protected function argsToArray($argList, $not = false) { $list = array(); for ($i = 0; $i < count($argList); $i++) { if (is_array($argList[$i])) { foreach ($argList[$i] as $arg) { $list[] = array($not, $this->toRegex($arg)); } } else { $list[] = array($not, $this->toRegex($argList[$i])); } } return $list; } public function name() { $args = func_get_args(); $this->names = array_merge($this->names, $this->argsToArray($args)); return $this; } public function notName() { $args = func_get_args(); $this->names = array_merge($this->names, $this->argsToArray($args, true)); return $this; } public function size() { $args = func_get_args(); for ($i = 0; $i < count($args); $i++) { $this->sizes[] = new Doctrine_FileFinder_NumberCompare($args[$i]); } return $this; } public function prune() { $args = func_get_args(); $this->prunes = array_merge($this->prunes, $this->argsToArray($args)); return $this; } public function discard() { $args = func_get_args(); $this->discards = array_merge($this->discards, $this->argsToArray($args)); return $this; } public function ignoreVersionControl() { $ignores = array('.svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr'); return $this->discard($ignores)->prune($ignores); } public function exec() { $args = func_get_args(); for ($i = 0; $i < count($args); $i++) { if (is_array($args[$i]) && !method_exists($args[$i][0], $args[$i][1])) { throw new Doctrine_Exception(sprintf('method "%s" does not exist for object "%s".', $args[$i][1], $args[$i][0])); } else if ( ! is_array($args[$i]) && !function_exists($args[$i])) { throw new Doctrine_Exception(sprintf('function "%s" does not exist.', $args[$i])); } $this->execs[] = $args[$i]; } return $this; } public function relative() { $this->relative = true; return $this; } public function followLink() { $this->followLink = true; return $this; } public function in() { $files = array(); $here_dir = getcwd(); $numargs = func_num_args(); $argList = func_get_args(); if ($numargs == 1 && is_array($argList[0])) { $argList = $argList[0]; $numargs = count($argList); } for ($i = 0; $i < $numargs; $i++) { $realDir = realpath($argList[$i]); if ( ! self::isPathAbsolute($realDir)) { $dir = $here_dir . DIRECTORY_SEPARATOR . $realDir; } else { $dir = $realDir; } if ( ! is_dir($realDir)) { continue; } if ($this->relative) { $files = array_merge($files, str_replace($dir . DIRECTORY_SEPARATOR, '', $this->_searchIn($dir))); } else { $files = array_merge($files, $this->_searchIn($dir)); } } return array_unique($files); } protected function _searchIn($dir, $depth = 0) { if ($depth > $this->maxDepth) { return array(); } if (is_link($dir) && !$this->followLink) { return array(); } $files = array(); if (is_dir($dir)) { $currentDir = opendir($dir); while (false !== $entryName = readdir($currentDir)) { if ($entryName == '.' || $entryName == '..') { continue; } $currentEntry = $dir . DIRECTORY_SEPARATOR . $entryName; if (is_link($currentEntry) && !$this->followLink) { continue; } if (is_dir($currentEntry)) { if (($this->type == 'directory' || $this->type == 'any') && ($depth >= $this->minDepth) && !$this->_isDiscarded($dir, $entryName) && $this->_matchNames($dir, $entryName) && $this->_execOk($dir, $entryName)) { $files[] = realpath($currentEntry); } if ( ! $this->_isPruned($dir, $entryName)) { $files = array_merge($files, $this->_searchIn($currentEntry, $depth + 1)); } } else { if (($this->type != 'directory' || $this->type == 'any') && ($depth >= $this->minDepth) && !$this->_isDiscarded($dir, $entryName) && $this->_matchNames($dir, $entryName) && $this->_sizeOk($dir, $entryName) && $this->_execOk($dir, $entryName)) { $files[] = realpath($currentEntry); } } } closedir($currentDir); } return $files; } protected function _matchNames($dir, $entry) { if ( ! count($this->names)) { return true; } $oneNotNameRule = false; foreach ($this->names as $args) { list($not, $regex) = $args; if ($not) { $oneNotNameRule = true; if (preg_match($regex, $entry)) { return false; } } } $oneNameRule = false; foreach ($this->names as $args) { list($not, $regex) = $args; if ( ! $not) { $oneNameRule = true; if (preg_match($regex, $entry)) { return true; } } } if ($oneNotNameRule && $oneNameRule) { return false; } else if ($oneNotNameRule) { return true; } else if ($oneNameRule) { return false; } else { return true; } } protected function _sizeOk($dir, $entry) { if ( ! count($this->sizes)) { return true; } if ( ! is_file($dir . DIRECTORY_SEPARATOR . $entry)) { return true; } $filesize = filesize($dir . DIRECTORY_SEPARATOR . $entry); foreach ($this->sizes as $number_compare) { if ( ! $number_compare->test($filesize)) { return false; } } return true; } protected function _isPruned($dir, $entry) { if ( ! count($this->prunes)) { return false; } foreach ($this->prunes as $args) { $regex = $args[1]; if (preg_match($regex, $entry)) { return true; } } return false; } protected function _isDiscarded($dir, $entry) { if ( ! count($this->discards)) { return false; } foreach ($this->discards as $args) { $regex = $args[1]; if (preg_match($regex, $entry)) { return true; } } return false; } protected function _execOk($dir, $entry) { if ( ! count($this->execs)) { return true; } foreach ($this->execs as $exec) { if ( ! call_user_func_array($exec, array($dir, $entry))) { return false; } } return true; } public static function isPathAbsolute($path) { if ($path{0} == '/' || $path{0} == '\\' || (strlen($path) > 3 && ctype_alpha($path{0}) && $path{1} == ':' && ($path{2} == '\\' || $path{2} == '/') ) ) { return true; } return false; } }class Doctrine_Table extends Doctrine_Configurable implements Countable { protected $_data = array(); protected $_identifier = array(); protected $_identifierType; protected $_conn; protected $_identityMap = array(); protected $_repository; protected $_columns = array(); protected $_fieldNames = array(); protected $_columnNames = array(); protected $columnCount; protected $hasDefaultValues; protected $_options = array('name' => null, 'tableName' => null, 'sequenceName' => null, 'inheritanceMap' => array(), 'enumMap' => array(), 'type' => null, 'charset' => null, 'collation' => null, 'treeImpl' => null, 'treeOptions' => array(), 'indexes' => array(), 'parents' => array(), 'joinedParents' => array(), 'queryParts' => array(), 'versioning' => null, 'subclasses' => array(), ); protected $_tree; protected $_parser; protected $_templates = array(); protected $_filters = array(); protected $_generators = array(); protected $_invokedMethods = array(); protected $record; public function __construct($name, Doctrine_Connection $conn, $initDefinition = false) { $this->_conn = $conn; $this->setParent($this->_conn); $this->_options['name'] = $name; $this->_parser = new Doctrine_Relation_Parser($this); if ($initDefinition) { $this->record = $this->initDefinition(); $this->initIdentifier(); $this->record->setUp(); if ($this->isTree()) { $this->getTree()->setUp(); } } else { if ( ! isset($this->_options['tableName'])) { $this->setTableName(Doctrine_Inflector::tableize($this->_options['name'])); } } $this->_filters[] = new Doctrine_Record_Filter_Standard(); $this->_repository = new Doctrine_Table_Repository($this); $this->construct(); } public function construct() { } public function initDefinition() { $name = $this->_options['name']; if ( ! class_exists($name) || empty($name)) { throw new Doctrine_Exception("Couldn't find class " . $name); } $record = new $name($this); $names = array(); $class = $name; do { if ($class === 'Doctrine_Record') { break; } $name = $class; $names[] = $name; } while ($class = get_parent_class($class)); if ($class === false) { throw new Doctrine_Table_Exception('Class "' . $name . '" must be a child class of Doctrine_Record'); } $names = array_reverse($names); array_pop($names); $this->_options['parents'] = $names; if (method_exists($record, 'setTableDefinition')) { $record->setTableDefinition(); $method = new ReflectionMethod($this->_options['name'], 'setTableDefinition'); $class = $method->getDeclaringClass(); } else { $class = new ReflectionClass($class); } $this->_options['joinedParents'] = array(); foreach (array_reverse($this->_options['parents']) as $parent) { if ($parent === $class->getName()) { continue; } $ref = new ReflectionClass($parent); if ($ref->isAbstract() || ! $class->isSubClassOf($parent)) { continue; } $parentTable = $this->_conn->getTable($parent); $found = false; $parentColumns = $parentTable->getColumns(); foreach ($parentColumns as $columnName => $definition) { if ( ! isset($definition['primary']) || $definition['primary'] === false) { if (isset($this->_columns[$columnName])) { $found = true; break; } else { if ( ! isset($parentColumns[$columnName]['owner'])) { $parentColumns[$columnName]['owner'] = $parentTable->getComponentName(); } $this->_options['joinedParents'][] = $parentColumns[$columnName]['owner']; } } else { unset($parentColumns[$columnName]); } } if ($found) { continue; } foreach ($parentColumns as $columnName => $definition) { $fullName = $columnName . ' as ' . $parentTable->getFieldName($columnName); $this->setColumn($fullName, $definition['type'], $definition['length'], $definition, true); } break; } $this->_options['joinedParents'] = array_values(array_unique($this->_options['joinedParents'])); $this->_options['declaringClass'] = $class; if ($this->isTree()) { $this->getTree()->setTableDefinition(); } $this->columnCount = count($this->_columns); if ( ! isset($this->_options['tableName'])) { $this->setTableName(Doctrine_Inflector::tableize($class->getName())); } return $record; } public function initIdentifier() { switch (count($this->_identifier)) { case 0: if ( ! empty($this->_options['joinedParents'])) { $root = current($this->_options['joinedParents']); $table = $this->_conn->getTable($root); $this->_identifier = $table->getIdentifier(); $this->_identifierType = ($table->getIdentifierType() !== Doctrine::IDENTIFIER_AUTOINC) ? $table->getIdentifierType() : Doctrine::IDENTIFIER_NATURAL; foreach ((array) $this->_identifier as $id) { $definition = $table->getDefinitionOf($id); unset($definition['autoincrement']); unset($definition['sequence']); $fullName = $id . ' as ' . $table->getFieldName($id); $this->setColumn($fullName, $definition['type'], $definition['length'], $definition, true); } } else { $definition = array('type' => 'integer', 'length' => 20, 'autoincrement' => true, 'primary' => true); $this->setColumn('id', $definition['type'], $definition['length'], $definition, true); $this->_identifier = 'id'; $this->_identifierType = Doctrine::IDENTIFIER_AUTOINC; } $this->columnCount++; break; case 1: foreach ($this->_identifier as $pk) { $e = $this->getDefinitionOf($pk); $found = false; foreach ($e as $option => $value) { if ($found) { break; } $e2 = explode(':', $option); switch (strtolower($e2[0])) { case 'autoincrement': case 'autoinc': if ($value !== false) { $this->_identifierType = Doctrine::IDENTIFIER_AUTOINC; $found = true; } break; case 'seq': case 'sequence': $this->_identifierType = Doctrine::IDENTIFIER_SEQUENCE; $found = true; if (is_string($value)) { $this->_options['sequenceName'] = $value; } else { if (($sequence = $this->getAttribute(Doctrine::ATTR_DEFAULT_SEQUENCE)) !== null) { $this->_options['sequenceName'] = $sequence; } else { $this->_options['sequenceName'] = $this->_conn->formatter->getSequenceName($this->_options['tableName']); } } break; } } if ( ! isset($this->_identifierType)) { $this->_identifierType = Doctrine::IDENTIFIER_NATURAL; } } $this->_identifier = $pk; break; default: $this->_identifierType = Doctrine::IDENTIFIER_COMPOSITE; } } public function getColumnOwner($columnName) { if (isset($this->_columns[$columnName]['owner'])) { return $this->_columns[$columnName]['owner']; } else { return $this->getComponentName(); } } public function getRecordInstance() { if ( ! $this->record) { $this->record = new $this->_options['name']; } return $this->record; } public function isInheritedColumn($columnName) { return (isset($this->_columns[$columnName]['owner'])); } public function isIdentifier($fieldName) { return ($fieldName === $this->getIdentifier() || in_array($fieldName, (array) $this->getIdentifier())); } public function isIdentifierAutoincrement() { return $this->getIdentifierType() === Doctrine::IDENTIFIER_AUTOINC; } public function isIdentifierComposite() { return $this->getIdentifierType() === Doctrine::IDENTIFIER_COMPOSITE; } public function getMethodOwner($method) { return (isset($this->_invokedMethods[$method])) ? $this->_invokedMethods[$method] : false; } public function setMethodOwner($method, $class) { $this->_invokedMethods[$method] = $class; } public function getTemplates() { return $this->_templates; } public function export() { $this->_conn->export->exportTable($this); } public function getExportableFormat($parseForeignKeys = true) { $columns = array(); $primary = array(); foreach ($this->getColumns() as $name => $definition) { if (isset($definition['owner'])) { continue; } switch ($definition['type']) { case 'boolean': if (isset($definition['default'])) { $definition['default'] = $this->getConnection()->convertBooleans($definition['default']); } break; } $columns[$name] = $definition; if (isset($definition['primary']) && $definition['primary']) { $primary[] = $name; } } $options['foreignKeys'] = isset($this->_options['foreignKeys']) ? $this->_options['foreignKeys'] : array(); if ($parseForeignKeys && $this->getAttribute(Doctrine::ATTR_EXPORT) & Doctrine::EXPORT_CONSTRAINTS) { $constraints = array(); $emptyIntegrity = array('onUpdate' => null, 'onDelete' => null); foreach ($this->getRelations() as $name => $relation) { $fk = $relation->toArray(); $fk['foreignTable'] = $relation->getTable()->getTableName(); if ($relation->getTable() === $this && in_array($relation->getLocal(), $primary)) { if ($relation->hasConstraint()) { throw new Doctrine_Table_Exception("Badly constructed integrity constraints. Cannot define constraint of different fields in the same table."); } continue; } $integrity = array('onUpdate' => $fk['onUpdate'], 'onDelete' => $fk['onDelete']); if ($relation instanceof Doctrine_Relation_LocalKey) { $def = array('local' => $relation->getLocalColumnName(), 'foreign' => $relation->getForeignColumnName(), 'foreignTable' => $relation->getTable()->getTableName()); if (($key = array_search($def, $options['foreignKeys'])) === false) { $options['foreignKeys'][] = $def; $constraints[] = $integrity; } else { if ($integrity !== $emptyIntegrity) { $constraints[$key] = $integrity; } } } } foreach ($constraints as $k => $def) { $options['foreignKeys'][$k] = array_merge($options['foreignKeys'][$k], $def); } } $options['primary'] = $primary; return array('tableName' => $this->getOption('tableName'), 'columns' => $columns, 'options' => array_merge($this->getOptions(), $options)); } public function getRelationParser() { return $this->_parser; } public function __get($option) { if (isset($this->_options[$option])) { return $this->_options[$option]; } return null; } public function __isset($option) { return isset($this->_options[$option]); } public function getOptions() { return $this->_options; } public function setOptions($options) { foreach ($options as $key => $value) { $this->setOption($key, $value); } } public function addForeignKey(array $definition) { $this->_options['foreignKeys'][] = $definition; } public function addCheckConstraint($definition, $name) { if (is_string($name)) { $this->_options['checks'][$name] = $definition; } else { $this->_options['checks'][] = $definition; } return $this; } public function addIndex($index, array $definition) { $this->_options['indexes'][$index] = $definition; } public function getIndex($index) { if (isset($this->_options['indexes'][$index])) { return $this->_options['indexes'][$index]; } return false; } public function bind($args, $type) { $options = ( ! isset($args[1])) ? array() : $args[1]; $options['type'] = $type; $this->_parser->bind($args[0], $options); } public function hasRelation($alias) { return $this->_parser->hasRelation($alias); } public function getRelation($alias, $recursive = true) { return $this->_parser->getRelation($alias, $recursive); } public function getRelations() { return $this->_parser->getRelations(); } public function createQuery($alias = '') { if ( ! empty($alias)) { $alias = ' ' . trim($alias); } return Doctrine_Query::create($this->_conn)->from($this->getComponentName() . $alias); } public function getRepository() { return $this->_repository; } public function setOption($name, $value) { switch ($name) { case 'name': case 'tableName': break; case 'enumMap': case 'inheritanceMap': case 'index': case 'treeOptions': if ( ! is_array($value)) { throw new Doctrine_Table_Exception($name . ' should be an array.'); } break; } $this->_options[$name] = $value; } public function getOption($name) { if (isset($this->_options[$name])) { return $this->_options[$name]; } return null; } public function getColumnName($fieldName) { $fieldName = is_array($fieldName) ? $fieldName[0]:$fieldName; if (isset($this->_columnNames[$fieldName])) { return $this->_columnNames[$fieldName]; } return strtolower($fieldName); } public function getColumnDefinition($columnName) { if ( ! isset($this->_columns[$columnName])) { return false; } return $this->_columns[$columnName]; } public function getFieldName($columnName) { if (isset($this->_fieldNames[$columnName])) { return $this->_fieldNames[$columnName]; } return $columnName; } public function setColumns(array $definitions) { foreach ($definitions as $name => $options) { $this->setColumn($name, $options['type'], $options['length'], $options); } } public function setColumn($name, $type, $length = null, $options = array(), $prepend = false) { if (is_string($options)) { $options = explode('|', $options); } foreach ($options as $k => $option) { if (is_numeric($k)) { if ( ! empty($option)) { $options[$option] = true; } unset($options[$k]); } } if (stripos($name, ' as ')) { if (strpos($name, ' as')) { $parts = explode(' as ', $name); } else { $parts = explode(' AS ', $name); } if (count($parts) > 1) { $fieldName = $parts[1]; } else { $fieldName = $parts[0]; } $name = strtolower($parts[0]); } else { $fieldName = $name; $name = strtolower($name); } $name = trim($name); $fieldName = trim($fieldName); if ($prepend) { $this->_columnNames = array_merge(array($fieldName => $name), $this->_columnNames); $this->_fieldNames = array_merge(array($name => $fieldName), $this->_fieldNames); } else { $this->_columnNames[$fieldName] = $name; $this->_fieldNames[$name] = $fieldName; } if ($length == null) { switch ($type) { case 'string': case 'clob': case 'float': case 'integer': case 'array': case 'object': case 'blob': case 'gzip': $length = 2147483647; break; case 'boolean': $length = 1; case 'date': $length = 10; case 'time': $length = 14; case 'timestamp': $length = 25; break; } } $options['type'] = $type; $options['length'] = $length; if ($prepend) { $this->_columns = array_merge(array($name => $options), $this->_columns); } else { $this->_columns[$name] = $options; } if (isset($options['primary']) && $options['primary']) { if (isset($this->_identifier)) { $this->_identifier = (array) $this->_identifier; } if ( ! in_array($fieldName, $this->_identifier)) { $this->_identifier[] = $fieldName; } } if (isset($options['default'])) { $this->hasDefaultValues = true; } } public function hasDefaultValues() { return $this->hasDefaultValues; } public function getDefaultValueOf($fieldName) { $columnName = $this->getColumnName($fieldName); if ( ! isset($this->_columns[$columnName])) { throw new Doctrine_Table_Exception("Couldn't get default value. Column ".$columnName." doesn't exist."); } if (isset($this->_columns[$columnName]['default'])) { return $this->_columns[$columnName]['default']; } else { return null; } } public function getIdentifier() { return $this->_identifier; } public function getIdentifierType() { return $this->_identifierType; } public function hasColumn($columnName) { return isset($this->_columns[strtolower($columnName)]); } public function hasField($fieldName) { return isset($this->_columnNames[$fieldName]); } public function setConnection(Doctrine_Connection $conn) { $this->_conn = $conn; $this->setParent($this->_conn); return $this; } public function getConnection() { return $this->_conn; } public function create(array $array = array()) { $record = new $this->_options['name']($this, true); $record->fromArray($array); return $record; } public function addNamedQuery($queryKey, $query) { $registry = Doctrine_Manager::getInstance()->getQueryRegistry(); $registry->add($this->getComponentName() . '/' . $queryKey, $query); } public function createNamedQuery($queryKey) { $queryRegistry = Doctrine_Manager::getInstance()->getQueryRegistry(); if (strpos($queryKey, '/') !== false) { $e = explode('/', $queryKey); return $queryRegistry->get($e[1], $e[0]); } return $queryRegistry->get($queryKey, $this->getComponentName()); } public function find() { $num_args = func_num_args(); $name = func_get_arg(0); if (is_null($name)) { return false; } $ns = $this->getComponentName(); $m = $name; if ( ! is_array($name) && strpos($name, '/') !== false) { list($ns, $m) = explode('/', $name); } if ( ! is_array($name) && Doctrine_Manager::getInstance()->getQueryRegistry()->has($m, $ns) ) { $q = $this->createNamedQuery($name); $params = ($num_args >= 2) ? func_get_arg(1) : array(); $hydrationMode = ($num_args == 3) ? func_get_arg(2) : null; $res = $q->execute($params, $hydrationMode); } else { $q = $this->createQuery('dctrn_find') ->where('dctrn_find.' . implode(' = ? AND dctrn_find.', (array) $this->getIdentifier()) . ' = ?') ->limit(1); $params = is_array($name) ? array_values($name) : array($name); $hydrationMode = ($num_args == 2) ? func_get_arg(1) : null; $res = $q->fetchOne($params, $hydrationMode); } $q->free(); return $res; } public function findAll($hydrationMode = null) { return $this->createQuery('dctrn_find') ->execute(array(), $hydrationMode); } public function findBySql($dql, $params = array(), $hydrationMode = null) { return $this->createQuery('dctrn_find') ->where($dql)->execute($params, $hydrationMode); } public function findByDql($dql, $params = array(), $hydrationMode = null) { $parser = new Doctrine_Query($this->_conn); $component = $this->getComponentName(); $query = 'FROM ' . $component . ' dctrn_find WHERE ' . $dql; return $parser->query($query, $params, $hydrationMode); } protected function findBy($fieldName, $value, $hydrationMode = null) { return $this->createQuery('dctrn_find') ->where('dctrn_find.' . $fieldName . ' = ?', array($value)) ->execute(array(), $hydrationMode); } protected function findOneBy($fieldName, $value, $hydrationMode = null) { return $this->createQuery('dctrn_find') ->where('dctrn_find.' . $fieldName . ' = ?', array($value)) ->limit(1) ->fetchOne(array(), $hydrationMode); } public function execute($queryKey, $params = array(), $hydrationMode = Doctrine::HYDRATE_RECORD) { return $this->createNamedQuery($queryKey)->execute($params, $hydrationMode); } public function executeOne($queryKey, $params = array(), $hydrationMode = Doctrine::HYDRATE_RECORD) { return $this->createNamedQuery($queryKey)->fetchOne($params, $hydrationMode); } public function clear() { $this->_identityMap = array(); } public function addRecord(Doctrine_Record $record) { $id = implode(' ', $record->identifier()); if (isset($this->_identityMap[$id])) { return false; } $this->_identityMap[$id] = $record; return true; } public function removeRecord(Doctrine_Record $record) { $id = implode(' ', $record->identifier()); if (isset($this->_identityMap[$id])) { unset($this->_identityMap[$id]); return true; } return false; } public function getRecord() { if ( ! empty($this->_data)) { $identifierFieldNames = $this->getIdentifier(); if ( ! is_array($identifierFieldNames)) { $identifierFieldNames = array($identifierFieldNames); } $found = false; foreach ($identifierFieldNames as $fieldName) { if ( ! isset($this->_data[$fieldName])) { $found = true; break; } $id[] = $this->_data[$fieldName]; } if ($found) { $recordName = $this->getComponentName(); $record = new $recordName($this, true); $this->_data = array(); return $record; } $id = implode(' ', $id); if (isset($this->_identityMap[$id])) { $record = $this->_identityMap[$id]; $record->hydrate($this->_data); if ($record->state() == Doctrine_Record::STATE_PROXY) { if (count($this->_data) >= $this->getColumnCount()) { $record->state(Doctrine_Record::STATE_CLEAN); } } } else { $recordName = $this->getComponentName(); $record = new $recordName($this); $this->_identityMap[$id] = $record; } $this->_data = array(); } else { $recordName = $this->getComponentName(); $record = new $recordName($this, true); } return $record; } public function getClassnameToReturn() { if ( ! isset($this->_options['subclasses'])) { return $this->_options['name']; } foreach ($this->_options['subclasses'] as $subclass) { $table = $this->_conn->getTable($subclass); $inheritanceMap = $table->getOption('inheritanceMap'); $nomatch = false; foreach ($inheritanceMap as $key => $value) { if ( ! isset($this->_data[$key]) || $this->_data[$key] != $value) { $nomatch = true; break; } } if ( ! $nomatch) { return $table->getComponentName(); } } return $this->_options['name']; } final public function getProxy($id = null) { if ($id !== null) { $identifierColumnNames = $this->getIdentifierColumnNames(); $query = 'SELECT ' . implode(', ', (array) $identifierColumnNames) . ' FROM ' . $this->getTableName() . ' WHERE ' . implode(' = ? && ', (array) $identifierColumnNames) . ' = ?'; $query = $this->applyInheritance($query); $params = array_merge(array($id), array_values($this->_options['inheritanceMap'])); $this->_data = $this->_conn->execute($query, $params)->fetch(PDO::FETCH_ASSOC); if ($this->_data === false) return false; } return $this->getRecord(); } final public function applyInheritance($where) { if ( ! empty($this->_options['inheritanceMap'])) { $a = array(); foreach ($this->_options['inheritanceMap'] as $field => $value) { $a[] = $this->getColumnName($field) . ' = ?'; } $i = implode(' AND ', $a); $where .= ' AND ' . $i; } return $where; } public function count() { return $this->createQuery()->count(); } public function getQueryObject() { $graph = new Doctrine_Query($this->getConnection()); $graph->load($this->getComponentName()); return $graph; } public function getEnumValues($fieldName) { $columnName = $this->getColumnName($fieldName); if (isset($this->_columns[$columnName]['values'])) { return $this->_columns[$columnName]['values']; } else { return array(); } } public function enumValue($fieldName, $index) { if ($index instanceof Doctrine_Null) { return $index; } $columnName = $this->getColumnName($fieldName); if ( ! $this->_conn->getAttribute(Doctrine::ATTR_USE_NATIVE_ENUM) && isset($this->_columns[$columnName]['values'][$index]) ) { return $this->_columns[$columnName]['values'][$index]; } return $index; } public function enumIndex($fieldName, $value) { $values = $this->getEnumValues($fieldName); $index = array_search($value, $values); if ($index === false || !$this->_conn->getAttribute(Doctrine::ATTR_USE_NATIVE_ENUM)) { return $index; } return $value; } public function validateField($fieldName, $value, Doctrine_Record $record = null) { if ($record instanceof Doctrine_Record) { $errorStack = $record->getErrorStack(); } else { $record = $this->create(); $errorStack = new Doctrine_Validator_ErrorStack($this->getOption('name')); } if ($value === self::$_null) { $value = null; } else if ($value instanceof Doctrine_Record) { $value = $value->getIncremented(); } $dataType = $this->getTypeOf($fieldName); if ($this->getAttribute(Doctrine::ATTR_VALIDATE) & Doctrine::VALIDATE_TYPES) { if ( ! Doctrine_Validator::isValidType($value, $dataType)) { $errorStack->add($fieldName, 'type'); } if ($dataType == 'enum') { $enumIndex = $this->enumIndex($fieldName, $value); if ($enumIndex === false) { $errorStack->add($fieldName, 'enum'); } } } if ($this->getAttribute(Doctrine::ATTR_VALIDATE) & Doctrine::VALIDATE_LENGTHS) { if ( ! Doctrine_Validator::validateLength($value, $dataType, $this->getFieldLength($fieldName))) { $errorStack->add($fieldName, 'length'); } } foreach ($this->getFieldValidators($fieldName) as $validatorName => $args) { if ( ! is_string($validatorName)) { $validatorName = $args; $args = array(); } $validator = Doctrine_Validator::getValidator($validatorName); $validator->invoker = $record; $validator->field = $fieldName; $validator->args = $args; if ( ! $validator->validate($value)) { $errorStack->add($fieldName, $validator); } } return $errorStack; } public function getColumnCount() { return $this->columnCount; } public function getColumns() { return $this->_columns; } public function removeColumn($fieldName) { if ( ! $this->hasField($fieldName)) { return false; } $columnName = $this->getColumnName($fieldName); unset($this->_columnNames[$fieldName], $this->_fieldNames[$columnName], $this->_columns[$columnName]); $this->columnCount = count($this->_columns); return true; } public function getColumnNames(array $fieldNames = null) { if ($fieldNames === null) { return array_keys($this->_columns); } else { $columnNames = array(); foreach ($fieldNames as $fieldName) { $columnNames[] = $this->getColumnName($fieldName); } return $columnNames; } } public function getIdentifierColumnNames() { return $this->getColumnNames((array) $this->getIdentifier()); } public function getFieldNames() { return array_values($this->_fieldNames); } public function getDefinitionOf($fieldName) { $columnName = $this->getColumnName($fieldName); return $this->getColumnDefinition($columnName); } public function getTypeOf($fieldName) { return $this->getTypeOfColumn($this->getColumnName($fieldName)); } public function getTypeOfColumn($columnName) { return isset($this->_columns[$columnName]) ? $this->_columns[$columnName]['type'] : false; } public function setData(array $data) { $this->_data = $data; } public function getData() { return $this->_data; } public function prepareValue($fieldName, $value, $typeHint = null) { if ($value === self::$_null) { return self::$_null; } else if ($value === null) { return null; } else { $type = is_null($typeHint) ? $this->getTypeOf($fieldName) : $typeHint; switch ($type) { case 'integer': case 'string'; break; case 'enum': return $this->enumValue($fieldName, $value); break; case 'boolean': return (boolean) $value; break; case 'array': case 'object': if (is_string($value)) { $value = empty($value) ? null:unserialize($value); if ($value === false) { throw new Doctrine_Table_Exception('Unserialization of ' . $fieldName . ' failed.'); } return $value; } break; case 'gzip': $value = gzuncompress($value); if ($value === false) { throw new Doctrine_Table_Exception('Uncompressing of ' . $fieldName . ' failed.'); } return $value; break; } } return $value; } public function getTree() { if (isset($this->_options['treeImpl'])) { if ( ! $this->_tree) { $options = isset($this->_options['treeOptions']) ? $this->_options['treeOptions'] : array(); $this->_tree = Doctrine_Tree::factory($this, $this->_options['treeImpl'], $options ); } return $this->_tree; } return false; } public function getComponentName() { return $this->_options['name']; } public function getTableName() { return $this->_options['tableName']; } public function setTableName($tableName) { $this->setOption('tableName', $this->_conn->formatter->getTableName($tableName)); } public function isTree() { return ( ! is_null($this->_options['treeImpl'])) ? true : false; } public function getTemplate($template) { if ( ! isset($this->_templates[$template])) { throw new Doctrine_Table_Exception('Template ' . $template . ' not loaded'); } return $this->_templates[$template]; } public function hasTemplate($template) { return isset($this->_templates[$template]); } public function addTemplate($template, Doctrine_Template $impl) { $this->_templates[$template] = $impl; return $this; } public function getGenerators() { return $this->_generators; } public function getGenerator($generator) { if ( ! isset($this->_generators[$generator])) { throw new Doctrine_Table_Exception('Generator ' . $generator . ' not loaded'); } return $this->_generators[$generator]; } public function hasGenerator($generator) { return isset($this->_generators[$generator]); } public function addGenerator(Doctrine_Record_Generator $generator, $name = null) { if ($name === null) { $this->_generators[] = $generator; } else { $this->_generators[$name] = $generator; } return $this; } public function bindQueryParts(array $queryParts) { $this->_options['queryParts'] = $queryParts; return $this; } public function bindQueryPart($queryPart, $value) { $this->_options['queryParts'][$queryPart] = $value; return $this; } public function getFieldValidators($fieldName) { $validators = array(); $columnName = $this->getColumnName($fieldName); foreach ($this->_columns[$columnName] as $name => $args) { if (empty($name) || $name == 'primary' || $name == 'protected' || $name == 'autoincrement' || $name == 'default' || $name == 'values' || $name == 'sequence' || $name == 'zerofill' || $name == 'owner' || $name == 'scale' || $name == 'type' || $name == 'length' || $name == 'fixed') { continue; } if ($name == 'notnull' && isset($this->_columns[$columnName]['autoincrement']) && $this->_columns[$columnName]['autoincrement'] === true) { continue; } if ($args === false) { continue; } $validators[$name] = $args; } return $validators; } public function getFieldLength($fieldName) { return $this->_columns[$this->getColumnName($fieldName)]['length']; } public function getBoundQueryPart($queryPart) { if ( ! isset($this->_options['queryParts'][$queryPart])) { return null; } return $this->_options['queryParts'][$queryPart]; } public function unshiftFilter(Doctrine_Record_Filter $filter) { $filter->setTable($this); $filter->init(); array_unshift($this->_filters, $filter); return $this; } public function getFilters() { return $this->_filters; } public function __toString() { return Doctrine_Lib::getTableAsString($this); } protected function _resolveFindByFieldName($name) { $fieldName = Doctrine_Inflector::tableize($name); if ($this->hasColumn($name) || $this->hasField($name)) { return $this->getFieldName($this->getColumnName($name)); } else if ($this->hasColumn($fieldName) || $this->hasField($fieldName)) { return $this->getFieldName($this->getColumnName($fieldName)); } else { return false; } } public function __call($method, $arguments) { $lcMethod = strtolower($method); if (substr($lcMethod, 0, 6) == 'findby') { $by = substr($method, 6, strlen($method)); $method = 'findBy'; } else if (substr($lcMethod, 0, 9) == 'findoneby') { $by = substr($method, 9, strlen($method)); $method = 'findOneBy'; } if (isset($by)) { if ( ! isset($arguments[0])) { throw new Doctrine_Table_Exception('You must specify the value to findBy'); } $fieldName = $this->_resolveFindByFieldName($by); $hydrationMode = isset($arguments[1]) ? $arguments[1]:null; if ($this->hasField($fieldName)) { return $this->$method($fieldName, $arguments[0], $hydrationMode); } else if ($this->hasRelation($by)) { $relation = $this->getRelation($by); if ($relation['type'] === Doctrine_Relation::MANY) { throw new Doctrine_Table_Exception('Cannot findBy many relationship.'); } return $this->$method($relation['local'], $arguments[0], $hydrationMode); } else { throw new Doctrine_Table_Exception('Cannot find by: ' . $by . '. Invalid column or relationship alias.'); } } try { return call_user_func_array(array($this->getRecordInstance(), $method . 'TableProxy'), $arguments); } catch (Exception $e) {} throw new Doctrine_Table_Exception(sprintf('Unknown method %s::%s', get_class($this), $method)); } } class Doctrine_Lib { public static function getRecordStateAsString($state) { switch ($state) { case Doctrine_Record::STATE_PROXY: return "proxy"; break; case Doctrine_Record::STATE_CLEAN: return "persistent clean"; break; case Doctrine_Record::STATE_DIRTY: return "persistent dirty"; break; case Doctrine_Record::STATE_TDIRTY: return "transient dirty"; break; case Doctrine_Record::STATE_TCLEAN: return "transient clean"; break; } } public static function getRecordAsString(Doctrine_Record $record) { $r[] = '<pre>'; $r[] = 'Component  : ' . $record->getTable()->getComponentName(); $r[] = 'ID         : ' . Doctrine::dump($record->identifier()); $r[] = 'References : ' . count($record->getReferences()); $r[] = 'State      : ' . Doctrine_Lib::getRecordStateAsString($record->state()); $r[] = 'OID        : ' . $record->getOID(); $r[] = 'data       : ' . Doctrine::dump($record->getData(), false); $r[] = '</pre>'; return implode("\n",$r)."<br />"; } public static function getConnectionStateAsString($state) { switch ($state) { case Doctrine_Transaction::STATE_SLEEP: return "open"; break; case Doctrine_Transaction::STATE_BUSY: return "busy"; break; case Doctrine_Transaction::STATE_ACTIVE: return "active"; break; } } public static function getConnectionAsString(Doctrine_Connection $connection) { $r[] = '<pre>'; $r[] = 'Doctrine_Connection object'; $r[] = 'State               : ' . Doctrine_Lib::getConnectionStateAsString($connection->transaction->getState()); $r[] = 'Open Transactions   : ' . $connection->transaction->getTransactionLevel(); $r[] = 'Table in memory     : ' . $connection->count(); $r[] = 'Driver name         : ' . $connection->getAttribute(Doctrine::ATTR_DRIVER_NAME); $r[] = "</pre>"; return implode("\n",$r)."<br>"; } public static function getTableAsString(Doctrine_Table $table) { $r[] = "<pre>"; $r[] = "Component   : ".$table->getComponentName(); $r[] = "Table       : ".$table->getTableName(); $r[] = "</pre>"; return implode("\n",$r)."<br>"; } public static function formatSql($sql) { $e = explode("\n",$sql); $color = "367FAC"; $l = $sql; $l = str_replace("SELECT ", "<font color='$color'><b>SELECT </b></font><br \>  ",$l); $l = str_replace("FROM ", "<font color='$color'><b>FROM </b></font><br \>",$l); $l = str_replace(" LEFT JOIN ", "<br \><font color='$color'><b> LEFT JOIN </b></font>",$l); $l = str_replace(" INNER JOIN ", "<br \><font color='$color'><b> INNER JOIN </b></font>",$l); $l = str_replace(" WHERE ", "<br \><font color='$color'><b> WHERE </b></font>",$l); $l = str_replace(" GROUP BY ", "<br \><font color='$color'><b> GROUP BY </b></font>",$l); $l = str_replace(" HAVING ", "<br \><font color='$color'><b> HAVING </b></font>",$l); $l = str_replace(" AS ", "<font color='$color'><b> AS </b></font><br \>  ",$l); $l = str_replace(" ON ", "<font color='$color'><b> ON </b></font>",$l); $l = str_replace(" ORDER BY ", "<font color='$color'><b> ORDER BY </b></font><br \>",$l); $l = str_replace(" LIMIT ", "<font color='$color'><b> LIMIT </b></font><br \>",$l); $l = str_replace(" OFFSET ", "<font color='$color'><b> OFFSET </b></font><br \>",$l); $l = str_replace("  ", "<dd>",$l); return $l; } public static function getCollectionAsString(Doctrine_Collection $collection) { $r[] = "<pre>"; $r[] = get_class($collection); $r[] = 'data : ' . Doctrine::dump($collection->getData(), false); $r[] = "</pre>"; return implode("\n",$r); } public static function arrayDeepMerge() { switch (func_num_args()) { case 0: return false; case 1: return func_get_arg(0); case 2: $args = func_get_args(); $args[2] = array(); if (is_array($args[0]) && is_array($args[1])) { foreach (array_unique(array_merge(array_keys($args[0]),array_keys($args[1]))) as $key) { $isKey0 = array_key_exists($key, $args[0]); $isKey1 = array_key_exists($key, $args[1]); if ($isKey0 && $isKey1 && is_array($args[0][$key]) && is_array($args[1][$key])) { $args[2][$key] = self::arrayDeepMerge($args[0][$key], $args[1][$key]); } else if ($isKey0 && $isKey1) { $args[2][$key] = $args[1][$key]; } else if ( ! $isKey1) { $args[2][$key] = $args[0][$key]; } else if ( ! $isKey0) { $args[2][$key] = $args[1][$key]; } } return $args[2]; } else { return $args[1]; } default: $args = func_get_args(); $args[1] = self::arrayDeepMerge($args[0], $args[1]); array_shift($args); return call_user_func_array(array('Doctrine_Lib', 'arrayDeepMerge'), $args); break; } } public static function getValidators() { $validators = array(); $dir = Doctrine::getPath() . DIRECTORY_SEPARATOR . 'Doctrine' . DIRECTORY_SEPARATOR . 'Validator'; $files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($files as $file) { $e = explode('.', $file->getFileName()); if (end($e) == 'php') { $name = strtolower($e[0]); $validators[$name] = $name; } } return $validators; } public static function makeDirectories($path, $mode = 0777) { if ( ! $path) { return false; } if (is_dir($path) || is_file($path)) { return true; } return mkdir(trim($path), $mode, true); } public static function removeDirectories($folderPath) { if (is_dir($folderPath)) { foreach (scandir($folderPath) as $value) { if ($value != '.' && $value != '..') { $value = $folderPath . "/" . $value; if (is_dir($value)) { self::removeDirectories($value); } else if (is_file($value)) { unlink($value); } } } return rmdir($folderPath); } else { return false; } } public static function copyDirectory($source, $dest) { if (is_file($source)) { return copy($source, $dest); } if ( ! is_dir($dest)) { mkdir($dest); } $dir = dir($source); while (false !== $entry = $dir->read()) { if ($entry == '.' || $entry == '..') { continue; } if ($dest !== "$source/$entry") { self::copyDirectory("$source/$entry", "$dest/$entry"); } } $dir->close(); return true; } public static function isValidClassName($className) { if (preg_match('~(^[a-z])|(_[a-z])|([\W])|(_{2})~', $className)) { return false; } return true; } }final class Doctrine_Null { public function exists() { return false; } public function __toString() { return ''; } }class Doctrine_View { const DROP = 'DROP VIEW %s'; const CREATE = 'CREATE VIEW %s AS %s'; const SELECT = 'SELECT * FROM %s'; protected $_name; protected $_query; protected $_conn; protected $_dql; protected $_sql; public function __construct(Doctrine_Query $query, $viewName) { $this->_name = $viewName; $this->_query = $query; $this->_query->setView($this); $this->_conn = $query->getConnection(); $this->_dql = $query->getDql(); $this->_sql = $query->getSql(); } public function getQuery() { return $this->_query; } public function getName() { return $this->_name; } public function getConnection() { return $this->_conn; } public function create() { $sql = sprintf(self::CREATE, $this->_name, $this->_query->getQuery()); try { $this->_conn->execute($sql); } catch(Doctrine_Exception $e) { throw new Doctrine_View_Exception($e->__toString()); } } public function drop() { try { $this->_conn->execute(sprintf(self::DROP, $this->_name)); } catch(Doctrine_Exception $e) { throw new Doctrine_View_Exception($e->__toString()); } } public function execute() { return $this->_query->execute(); } public function getSelectSql() { return sprintf(self::SELECT, $this->_name); } public function getViewSql() { return $this->_sql; } public function getViewDql() { return $this->_dql; } }class Doctrine_Manager_Exception extends Doctrine_Exception { }class Doctrine_Log { const EMERG = 0; const ALERT = 1; const CRIT = 2; const ERR = 3; const WARN = 4; const NOTICE = 5; const INFO = 6; const DEBUG = 7; protected $_priorities = array(); protected $_writers = array(); protected $_filters = array(); protected $_extras = array(); public function __construct($writer = null) { $r = new ReflectionClass($this); $this->_priorities = array_flip($r->getConstants()); if ($writer !== null) { $this->addWriter($writer); } } public function __destruct() { foreach($this->_writers as $writer) { $writer->shutdown(); } } public function __call($method, $params) { $priority = strtoupper($method); if (($priority = array_search($priority, $this->_priorities)) !== false) { $this->log(array_shift($params), $priority); } else { throw new Doctrine_Log_Exception('Bad log priority'); } } public function log($message, $priority) { if (empty($this->_writers)) { throw new Doctrine_Log_Exception('No writers were added'); } if (! isset($this->_priorities[$priority])) { throw new Doctrine_Log_Exception('Bad log priority'); } $event = array_merge(array('timestamp' => date('c'), 'message' => $message, 'priority' => $priority, 'priorityName' => $this->_priorities[$priority]), $this->_extras); foreach ($this->_filters as $filter) { if (! $filter->accept($event)) { return; } } foreach ($this->_writers as $writer) { $writer->write($event); } } public function addPriority($name, $priority) { $name = strtoupper($name); if (isset($this->_priorities[$priority]) || array_search($name, $this->_priorities)) { throw new Doctrine_Log_Exception('Existing priorities cannot be overwritten'); } $this->_priorities[$priority] = $name; } public function addFilter($filter) { if (is_integer($filter)) { $filter = new Doctrine_Log_Filter_Priority($filter); } $this->_filters[] = $filter; } public function addWriter($writer) { $this->_writers[] = $writer; } public function setEventItem($name, $value) { $this->_extras = array_merge($this->_extras, array($name => $value)); } } class Doctrine_Locator_Exception extends Doctrine_Exception { } class Doctrine_Locking_Exception extends Doctrine_Exception {}class Doctrine_Locking_Manager_Pessimistic { private $conn; private $_lockTable = 'doctrine_lock_tracking'; public function __construct(Doctrine_Connection $conn) { $this->conn = $conn; if ($this->conn->getAttribute(Doctrine::ATTR_EXPORT) & Doctrine::EXPORT_TABLES) { $columns = array(); $columns['object_type'] = array('type' => 'string', 'length' => 50, 'notnull' => true, 'primary' => true); $columns['object_key'] = array('type' => 'string', 'length' => 250, 'notnull' => true, 'primary' => true); $columns['user_ident'] = array('type' => 'string', 'length' => 50, 'notnull' => true); $columns['timestamp_obtained'] = array('type' => 'integer', 'length' => 10, 'notnull' => true); $options = array('primary' => array('object_type', 'object_key')); try { $this->conn->export->createTable($this->_lockTable, $columns, $options); } catch(Exception $e) { } } } public function getLock(Doctrine_Record $record, $userIdent) { $objectType = $record->getTable()->getComponentName(); $key = $record->getTable()->getIdentifier(); $gotLock = false; $time = time(); if (is_array($key)) { $key = implode('|', $key); } try { $dbh = $this->conn->getDbh(); $this->conn->beginTransaction(); $stmt = $dbh->prepare('INSERT INTO ' . $this->_lockTable . ' (object_type, object_key, user_ident, timestamp_obtained)' . ' VALUES (:object_type, :object_key, :user_ident, :ts_obtained)'); $stmt->bindParam(':object_type', $objectType); $stmt->bindParam(':object_key', $key); $stmt->bindParam(':user_ident', $userIdent); $stmt->bindParam(':ts_obtained', $time); try { $stmt->execute(); $gotLock = true; } catch(Exception $pkviolation) { } if ( ! $gotLock) { $lockingUserIdent = $this->_getLockingUserIdent($objectType, $key); if ($lockingUserIdent !== null && $lockingUserIdent == $userIdent) { $gotLock = true; $stmt = $dbh->prepare('UPDATE ' . $this->_lockTable . ' SET timestamp_obtained = :ts' . ' WHERE object_type = :object_type AND' . ' object_key  = :object_key  AND' . ' user_ident  = :user_ident'); $stmt->bindParam(':ts', $time); $stmt->bindParam(':object_type', $objectType); $stmt->bindParam(':object_key', $key); $stmt->bindParam(':user_ident', $lockingUserIdent); $stmt->execute(); } } $this->conn->commit(); } catch (Exception $pdoe) { $this->conn->rollback(); throw new Doctrine_Locking_Exception($pdoe->getMessage()); } return $gotLock; } public function releaseLock(Doctrine_Record $record, $userIdent) { $objectType = $record->getTable()->getComponentName(); $key = $record->getTable()->getIdentifier(); if (is_array($key)) { $key = implode('|', $key); } try { $dbh = $this->conn->getDbh(); $stmt = $dbh->prepare("DELETE FROM $this->_lockTable WHERE
                                        object_type = :object_type AND
                                        object_key  = :object_key  AND
                                        user_ident  = :user_ident"); $stmt->bindParam(':object_type', $objectType); $stmt->bindParam(':object_key', $key); $stmt->bindParam(':user_ident', $userIdent); $stmt->execute(); $count = $stmt->rowCount(); return ($count > 0); } catch (PDOException $pdoe) { throw new Doctrine_Locking_Exception($pdoe->getMessage()); } } private function _getLockingUserIdent($objectType, $key) { if (is_array($key)) { $key = implode('|', $key); } try { $dbh = $this->conn->getDbh(); $stmt = $dbh->prepare('SELECT user_ident FROM ' . $this->_lockTable . ' WHERE object_type = :object_type AND object_key = :object_key'); $stmt->bindParam(':object_type', $objectType); $stmt->bindParam(':object_key', $key); $success = $stmt->execute(); if ( ! $success) { throw new Doctrine_Locking_Exception("Failed to determine locking user"); } $userIdent = $stmt->fetchColumn(); } catch (PDOException $pdoe) { throw new Doctrine_Locking_Exception($pdoe->getMessage()); } return $userIdent; } public function getLockOwner($lockedRecord) { $objectType = $lockedRecord->getTable()->getComponentName(); $key = $lockedRecord->getTable()->getIdentifier(); return $this->_getLockingUserIdent($objectType, $key); } public function releaseAgedLocks($age = 900, $objectType = null, $userIdent = null) { $age = time() - $age; try { $dbh = $this->conn->getDbh(); $stmt = $dbh->prepare('DELETE FROM ' . $this->_lockTable . ' WHERE timestamp_obtained < :age'); $stmt->bindParam(':age', $age); $query = 'DELETE FROM ' . $this->_lockTable . ' WHERE timestamp_obtained < :age'; if ($objectType) { $query .= ' AND object_type = :object_type'; } if ($userIdent) { $query .= ' AND user_ident = :user_ident'; } $stmt = $dbh->prepare($query); $stmt->bindParam(':age', $age); if ($objectType) { $stmt->bindParam(':object_type', $objectType); } if ($userIdent) { $stmt->bindParam(':user_ident', $userIdent); } $stmt->execute(); $count = $stmt->rowCount(); return $count; } catch (PDOException $pdoe) { throw new Doctrine_Locking_Exception($pdoe->getMessage()); } } }class Doctrine_Util extends Doctrine_Connection_Module { }class Doctrine_AuditLog extends Doctrine_Record_Generator { protected $_options = array( 'className' => '%CLASS%Version', 'versionColumn' => 'version', 'tableName' => false, 'generateFiles' => false, 'table' => false, 'pluginTable' => false, 'children' => array(), 'auditLog' => true, ); public function __construct(array $options = array()) { $this->_options = Doctrine_Lib::arrayDeepMerge($this->_options, $options); } public function setTableDefinition() { $name = $this->_options['table']->getComponentName(); $columns = $this->_options['table']->getColumns(); foreach ($columns as $column => $definition) { unset($definition['autoincrement']); unset($definition['sequence']); unset($definition['unique']); $fieldName = $this->_options['table']->getFieldName($column); if ($fieldName != $column) { $name = $column . ' as ' . $fieldName; } else { $name = $fieldName; } $this->hasColumn($name, $definition['type'], $definition['length'], $definition); } $this->hasColumn($this->_options['versionColumn'], 'integer', 8, array('primary' => true)); } public function getVersion(Doctrine_Record $record, $version) { $className = $this->_options['className']; $q = new Doctrine_Query(); $values = array(); foreach ((array) $this->_options['table']->getIdentifier() as $id) { $conditions[] = $className . '.' . $id . ' = ?'; $values[] = $record->get($id); } $where = implode(' AND ', $conditions) . ' AND ' . $className . '.' . $this->_options['versionColumn'] . ' = ?'; $values[] = $version; $q->from($className) ->where($where); return $q->execute($values, Doctrine::HYDRATE_ARRAY); } public function getMaxVersion(Doctrine_Record $record) { $className = $this->_options['className']; $select = 'MAX(' . $className . '.' . $this->_options['versionColumn'] . ') max_version'; foreach ((array) $this->_options['table']->getIdentifier() as $id) { $conditions[] = $className . '.' . $id . ' = ?'; $values[] = $record->get($id); } $q = Doctrine_Query::create() ->select($select) ->from($className) ->where(implode(' AND ',$conditions)); $result = $q->execute($values, Doctrine::HYDRATE_ARRAY); return isset($result[0]['max_version']) ? $result[0]['max_version']:0; } }class Doctrine_AuditLog_Listener extends Doctrine_Record_Listener { protected $_auditLog; public function __construct(Doctrine_AuditLog $auditLog) { $this->_auditLog = $auditLog; } public function preInsert(Doctrine_Event $event) { $versionColumn = $this->_auditLog->getOption('versionColumn'); $event->getInvoker()->set($versionColumn, 1); } public function postInsert(Doctrine_Event $event) { if ($this->_auditLog->getOption('auditLog')) { $class = $this->_auditLog->getOption('className'); $record = $event->getInvoker(); $version = new $class(); $version->merge($record->toArray()); $version->save(); } } public function preDelete(Doctrine_Event $event) { if ($this->_auditLog->getOption('auditLog')) { $className = $this->_auditLog->getOption('className'); $versionColumn = $this->_auditLog->getOption('versionColumn'); $event->getInvoker()->set($versionColumn, null); $q = Doctrine_Query::create(); foreach ((array) $this->_auditLog->getOption('table')->getIdentifier() as $id) { $conditions[] = 'obj.' . $id . ' = ?'; $values[] = $event->getInvoker()->get($id); } $rows = $q->delete($className) ->from($className.' obj') ->where(implode(' AND ',$conditions)) ->execute($values); } } public function preUpdate(Doctrine_Event $event) { if ($this->_auditLog->getOption('auditLog')) { $class = $this->_auditLog->getOption('className'); $record = $event->getInvoker(); $versionColumn = $this->_auditLog->getOption('versionColumn'); $record->set($versionColumn, $this->_getNextVersion($record)); $version = new $class(); $version->merge($record->toArray()); $version->save(); } } protected function _getNextVersion(Doctrine_Record $record) { if ($this->_auditLog->getOption('auditLog')) { return ($this->_auditLog->getMaxVersion($record) + 1); } } }class Doctrine_Relation_Parser { protected $_table; protected $_relations = array(); protected $_pending = array(); public function __construct(Doctrine_Table $table) { $this->_table = $table; } public function getTable() { return $this->_table; } public function getPendingRelation($name) { if ( ! isset($this->_pending[$name])) { throw new Doctrine_Relation_Exception('Unknown pending relation ' . $name); } return $this->_pending[$name]; } public function getPendingRelations() { return $this->_pending; } public function unsetPendingRelations($name) { unset($this->_pending[$name]); } public function hasRelation($name) { if ( ! isset($this->_pending[$name]) && ! isset($this->_relations[$name])) { return false; } return true; } public function bind($name, $options = array()) { $e = explode(' as ', $name); $name = $e[0]; $alias = isset($e[1]) ? $e[1] : $name; if ( ! isset($options['type'])) { throw new Doctrine_Relation_Exception('Relation type not set.'); } if ($this->hasRelation($alias)) { unset($this->relations[$alias]); unset($this->_pending[$alias]); } $this->_pending[$alias] = array_merge($options, array('class' => $name, 'alias' => $alias)); return $this->_pending[$alias]; } public function getRelation($alias, $recursive = true) { if (isset($this->_relations[$alias])) { return $this->_relations[$alias]; } if (isset($this->_pending[$alias])) { $def = $this->_pending[$alias]; $identifierColumnNames = $this->_table->getIdentifierColumnNames(); $idColumnName = array_pop($identifierColumnNames); if (isset($def['refClass'])) { $def = $this->completeAssocDefinition($def); $localClasses = array_merge($this->_table->getOption('parents'), array($this->_table->getComponentName())); $backRefRelationName = isset($def['refClassRelationAlias']) ? $def['refClassRelationAlias'] : $def['refClass']; if ( ! isset($this->_pending[$backRefRelationName]) && ! isset($this->_relations[$backRefRelationName])) { $parser = $def['refTable']->getRelationParser(); if ( ! $parser->hasRelation($this->_table->getComponentName())) { $parser->bind($this->_table->getComponentName(), array('type' => Doctrine_Relation::ONE, 'local' => $def['local'], 'foreign' => $idColumnName, 'localKey' => true, )); } if ( ! $this->hasRelation($backRefRelationName)) { if (in_array($def['class'], $localClasses)) { $this->bind($def['refClass'] . " as " . $backRefRelationName, array( 'type' => Doctrine_Relation::MANY, 'foreign' => $def['foreign'], 'local' => $idColumnName)); } else { $this->bind($def['refClass'] . " as " . $backRefRelationName, array( 'type' => Doctrine_Relation::MANY, 'foreign' => $def['local'], 'local' => $idColumnName)); } } } if (in_array($def['class'], $localClasses)) { $rel = new Doctrine_Relation_Nest($def); } else { $rel = new Doctrine_Relation_Association($def); } } else { $def = $this->completeDefinition($def); if (isset($def['localKey'])) { $rel = new Doctrine_Relation_LocalKey($def); $foreign = (array) $def['foreign']; foreach ($foreign as $fk) { if ( ! $rel->getTable()->isIdentifier($fk)) { $rel->getTable()->addIndex($fk, array('fields' => array($fk))); } } } else { $rel = new Doctrine_Relation_ForeignKey($def); } } if (isset($rel)) { unset($this->_pending[$alias]); $this->_relations[$alias] = $rel; return $rel; } } if ($recursive) { $this->getRelations(); return $this->getRelation($alias, false); } else { throw new Doctrine_Table_Exception('Unknown relation alias ' . $alias); } } public function getRelations() { foreach ($this->_pending as $k => $v) { $this->getRelation($k); } return $this->_relations; } public function getImpl($template) { $conn = $this->_table->getConnection(); if (in_array('Doctrine_Template', class_parents($template))) { $impl = $this->_table->getImpl($template); if ($impl === null) { throw new Doctrine_Relation_Parser_Exception("Couldn't find concrete implementation for template " . $template); } } else { $impl = $template; } return $conn->getTable($impl); } public function completeAssocDefinition($def) { $conn = $this->_table->getConnection(); $def['table'] = $this->getImpl($def['class']); $def['localTable'] = $this->_table; $def['class'] = $def['table']->getComponentName(); $def['refTable'] = $this->getImpl($def['refClass']); $id = $def['refTable']->getIdentifierColumnNames(); if (count($id) > 1) { if ( ! isset($def['foreign'])) { $def['foreign'] = ($def['local'] === $id[0]) ? $id[1] : $id[0]; } if ( ! isset($def['local'])) { $def['local'] = ($def['foreign'] === $id[0]) ? $id[1] : $id[0]; } } else { if ( ! isset($def['foreign'])) { $columns = $this->getIdentifiers($def['table']); $def['foreign'] = $columns; } if ( ! isset($def['local'])) { $columns = $this->getIdentifiers($this->_table); $def['local'] = $columns; } } return $def; } public function getIdentifiers(Doctrine_Table $table) { $componentNameToLower = strtolower($table->getComponentName()); if (is_array($table->getIdentifier())) { $columns = array(); foreach ((array) $table->getIdentifierColumnNames() as $identColName) { $columns[] = $componentNameToLower . '_' . $identColName; } } else { $columns = $componentNameToLower . '_' . $table->getColumnName( $table->getIdentifier()); } return $columns; } public function guessColumns(array $classes, Doctrine_Table $foreignTable) { $conn = $this->_table->getConnection(); foreach ($classes as $class) { try { $table = $conn->getTable($class); } catch (Doctrine_Table_Exception $e) { continue; } $columns = $this->getIdentifiers($table); $found = true; foreach ((array) $columns as $column) { if ( ! $foreignTable->hasColumn($column)) { $found = false; break; } } if ($found) { break; } } if ( ! $found) { throw new Doctrine_Relation_Exception("Couldn't find columns."); } return $columns; } public function completeDefinition($def) { $conn = $this->_table->getConnection(); $def['table'] = $this->getImpl($def['class']); $def['localTable'] = $this->_table; $def['class'] = $def['table']->getComponentName(); $foreignClasses = array_merge($def['table']->getOption('parents'), array($def['class'])); $localClasses = array_merge($this->_table->getOption('parents'), array($this->_table->getComponentName())); $localIdentifierColumnNames = $this->_table->getIdentifierColumnNames(); $localIdentifierCount = count($localIdentifierColumnNames); $localIdColumnName = array_pop($localIdentifierColumnNames); $foreignIdentifierColumnNames = $def['table']->getIdentifierColumnNames(); $foreignIdColumnName = array_pop($foreignIdentifierColumnNames); if (isset($def['local'])) { if ( ! isset($def['foreign'])) { if ($def['local'] === $localIdColumnName) { $def['foreign'] = $this->guessColumns($localClasses, $def['table']); } else { $def['foreign'] = $foreignIdColumnName; $def['localKey'] = true; } } else { if ($localIdentifierCount == 1) { if ($def['local'] == $localIdColumnName && isset($def['owningSide']) && $def['owningSide'] === true) { $def['localKey'] = true; } else if (($def['local'] !== $localIdColumnName && $def['type'] == Doctrine_Relation::ONE)) { $def['localKey'] = true; } } else if ($localIdentifierCount > 1) { $def['localKey'] = true; } } } else { if (isset($def['foreign'])) { if ($def['foreign'] === $foreignIdColumnName) { $def['localKey'] = true; try { $def['local'] = $this->guessColumns($foreignClasses, $this->_table); } catch (Doctrine_Relation_Exception $e) { $def['local'] = $localIdColumnName; } } else { $def['local'] = $localIdColumnName; } } else { $conn = $this->_table->getConnection(); foreach ($localClasses as $class) { $table = $conn->getTable($class); $identifierColumnNames = $table->getIdentifierColumnNames(); $idColumnName = array_pop($identifierColumnNames); $column = strtolower($table->getComponentName()) . '_' . $idColumnName; foreach ($foreignClasses as $class2) { $table2 = $conn->getTable($class2); if ($table2->hasColumn($column)) { $def['foreign'] = $column; $def['local'] = $idColumnName; return $def; } } } foreach ($foreignClasses as $class) { $table = $conn->getTable($class); $identifierColumnNames = $table->getIdentifierColumnNames(); $idColumnName = array_pop($identifierColumnNames); $column = strtolower($table->getComponentName()) . '_' . $idColumnName; foreach ($localClasses as $class2) { $table2 = $conn->getTable($class2); if ($table2->hasColumn($column)) { $def['foreign'] = $idColumnName; $def['local'] = $column; $def['localKey'] = true; return $def; } } } $columns = array(); foreach ((array) $this->_table->getIdentifierColumnNames() as $id) { $column = strtolower($table->getComponentName()) . '_' . $id; $col = $this->_table->getColumnDefinition($id); $type = $col['type']; $length = $col['length']; unset($col['type']); unset($col['length']); unset($col['autoincrement']); unset($col['sequence']); unset($col['primary']); $def['table']->setColumn($column, $type, $length, $col); $columns[] = $column; } if (count($columns) > 1) { $def['foreign'] = $columns; } else { $def['foreign'] = $columns[0]; } $def['local'] = $localIdColumnName; } } return $def; } }class Doctrine_Relation_Exception extends Doctrine_Exception { }class Doctrine_Relation_Parser_Exception extends Doctrine_Relation_Exception { }class Doctrine_Relation_ForeignKey extends Doctrine_Relation { public function fetchRelatedFor(Doctrine_Record $record) { $id = array(); $localTable = $record->getTable(); foreach ((array) $this->definition['local'] as $local) { $value = $record->get($localTable->getFieldName($local)); if (isset($value)) { $id[] = $value; } } if ($this->isOneToOne()) { if ( ! $record->exists() || empty($id) || ! $this->definition['table']->getAttribute(Doctrine::ATTR_LOAD_REFERENCES)) { $related = $this->getTable()->create(); } else { $dql = 'FROM ' . $this->getTable()->getComponentName() . ' WHERE ' . $this->getCondition(); $coll = $this->getTable()->getConnection()->query($dql, $id); $related = $coll[0]; } $related->set($related->getTable()->getFieldName($this->definition['foreign']), $record, false); } else { if ( ! $record->exists() || empty($id) || ! $this->definition['table']->getAttribute(Doctrine::ATTR_LOAD_REFERENCES)) { $related = new Doctrine_Collection($this->getTable()); } else { $query = $this->getRelationDql(1); $related = $this->getTable()->getConnection()->query($query, $id); } $related->setReference($record, $this); } return $related; } public function getCondition($alias = null) { if ( ! $alias) { $alias = $this->getTable()->getComponentName(); } $conditions = array(); foreach ((array) $this->definition['foreign'] as $foreign) { $conditions[] = $alias . '.' . $foreign . ' = ?'; } return implode(' AND ', $conditions); } }class Doctrine_Relation_Association extends Doctrine_Relation { public function getAssociationFactory() { return $this->definition['refTable']; } public function getAssociationTable() { return $this->definition['refTable']; } public function getRelationDql($count, $context = 'record') { $table = $this->definition['refTable']; $component = $this->definition['refTable']->getComponentName(); switch ($context) { case "record": $sub = substr(str_repeat("?, ", $count),0,-2); $dql = 'FROM ' . $this->getTable()->getComponentName(); $dql .= '.' . $component; $dql .= ' WHERE ' . $this->getTable()->getComponentName() . '.' . $component . '.' . $this->getLocalRefColumnName() . ' IN (' . $sub . ')'; break; case "collection": $sub = substr(str_repeat("?, ", $count),0,-2); $dql = 'FROM ' . $component . '.' . $this->getTable()->getComponentName(); $dql .= ' WHERE ' . $component . '.' . $this->getLocalRefColumnName() . ' IN (' . $sub . ')'; break; } return $dql; } final public function getLocalRefColumnName() { return $this->definition['refTable']->getColumnName($this->definition['local']); } final public function getLocalRefFieldName() { return $this->definition['refTable']->getFieldName($this->definition['local']); } final public function getForeignRefColumnName() { return $this->definition['refTable']->getColumnName($this->definition['foreign']); } final public function getForeignRefFieldName() { return $this->definition['refTable']->getFieldName($this->definition['foreign']); } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->getIncremented(); if (empty($id) || ! $this->definition['table']->getAttribute(Doctrine::ATTR_LOAD_REFERENCES)) { $coll = new Doctrine_Collection($this->getTable()); } else { $coll = $this->getTable()->getConnection()->query($this->getRelationDql(1), array($id)); } $coll->setReference($record, $this); return $coll; } }class Doctrine_Relation_Nest extends Doctrine_Relation_Association { public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->getIncremented(); if (empty($id) || ! $this->definition['table']->getAttribute(Doctrine::ATTR_LOAD_REFERENCES)) { return new Doctrine_Collection($this->getTable()); } else { $q = new Doctrine_RawSql($this->getTable()->getConnection()); $assocTable = $this->getAssociationFactory()->getTableName(); $tableName = $record->getTable()->getTableName(); $identifierColumnNames = $record->getTable()->getIdentifierColumnNames(); $identifier = array_pop($identifierColumnNames); $sub = 'SELECT ' . $this->getForeignRefColumnName() . ' FROM ' . $assocTable . ' WHERE ' . $this->getLocalRefColumnName() . ' = ?'; $condition[] = $tableName . '.' . $identifier . ' IN (' . $sub . ')'; $joinCondition[] = $tableName . '.' . $identifier . ' = ' . $assocTable . '.' . $this->getForeignRefColumnName(); if ($this->definition['equal']) { $sub2 = 'SELECT ' . $this->getLocalRefColumnName() . ' FROM ' . $assocTable . ' WHERE ' . $this->getForeignRefColumnName() . ' = ?'; $condition[] = $tableName . '.' . $identifier . ' IN (' . $sub2 . ')'; $joinCondition[] = $tableName . '.' . $identifier . ' = ' . $assocTable . '.' . $this->getLocalRefColumnName(); } $q->select('{'.$tableName.'.*}, {'.$assocTable.'.*}') ->from($tableName . ' INNER JOIN ' . $assocTable . ' ON ' . implode(' OR ', $joinCondition)) ->where(implode(' OR ', $condition)); $q->addComponent($tableName, $record->getTable()->getComponentName()); $path = $record->getTable()->getComponentName(). '.' . $this->getAssociationFactory()->getComponentName(); if ($this->definition['refClassRelationAlias']) { $path = $record->getTable()->getComponentName(). '.' . $this->definition['refClassRelationAlias']; } $q->addComponent($assocTable, $path); $params = ($this->definition['equal']) ? array($id, $id) : array($id); $res = $q->execute($params); return $res; } } }class Doctrine_Relation_Association_Self extends Doctrine_Relation_Association { public function getRelationDql($count, $context = 'record') { switch ($context) { case 'record': $identifierColumnNames = $this->definition['table']->getIdentifierColumnNames(); $identifier = array_pop($identifierColumnNames); $sub = 'SELECT '.$this->definition['foreign'] . ' FROM '.$this->definition['refTable']->getTableName() . ' WHERE '.$this->definition['local'] . ' = ?'; $sub2 = 'SELECT '.$this->definition['local'] . ' FROM '.$this->definition['refTable']->getTableName() . ' WHERE '.$this->definition['foreign'] . ' = ?'; $dql = 'FROM ' . $this->definition['table']->getComponentName() . '.' . $this->definition['refTable']->getComponentName() . ' WHERE ' . $this->definition['table']->getComponentName() . '.' . $identifier . ' IN (' . $sub . ')' . ' || ' . $this->definition['table']->getComponentName() . '.' . $identifier . ' IN (' . $sub2 . ')'; break; case 'collection': $sub = substr(str_repeat('?, ', $count),0,-2); $dql = 'FROM '.$this->definition['refTable']->getComponentName() . '.' . $this->definition['table']->getComponentName() . ' WHERE '.$this->definition['refTable']->getComponentName() . '.' . $this->definition['local'] . ' IN (' . $sub . ')'; }; return $dql; } public function fetchRelatedFor(Doctrine_Record $record) { $id = $record->getIncremented(); $q = new Doctrine_RawSql(); $assocTable = $this->getAssociationFactory()->getTableName(); $tableName = $record->getTable()->getTableName(); $identifierColumnNames = $record->getTable()->getIdentifierColumnNames(); $identifier = array_pop($identifierColumnNames); $sub = 'SELECT '.$this->getForeign(). ' FROM '.$assocTable. ' WHERE '.$this->getLocal(). ' = ?'; $sub2 = 'SELECT '.$this->getLocal(). ' FROM '.$assocTable. ' WHERE '.$this->getForeign(). ' = ?'; $q->select('{'.$tableName.'.*}, {'.$assocTable.'.*}') ->from($tableName . ' INNER JOIN '.$assocTable.' ON '. $tableName . '.' . $identifier . ' = ' . $assocTable . '.' . $this->getLocal() . ' OR ' . $tableName . '.' . $identifier . ' = ' . $assocTable . '.' . $this->getForeign() ) ->where($tableName.'.'.$identifier.' IN ('.$sub.') OR '. $tableName.'.'.$identifier.' IN ('.$sub2.')' ); $q->addComponent($tableName, $record->getTable()->getComponentName()); $q->addComponent($assocTable, $record->getTable()->getComponentName(). '.' . $this->getAssociationFactory()->getComponentName()); return $q->execute(array($id, $id)); } }class Doctrine_Relation_LocalKey extends Doctrine_Relation { public function fetchRelatedFor(Doctrine_Record $record) { $localFieldName = $record->getTable()->getFieldName($this->definition['local']); $id = $record->get($localFieldName); if (is_null($id) || ! $this->definition['table']->getAttribute(Doctrine::ATTR_LOAD_REFERENCES)) { $related = $this->getTable()->create(); } else { $dql = 'FROM ' . $this->getTable()->getComponentName() . ' WHERE ' . $this->getCondition(); $related = $this->getTable() ->getConnection() ->query($dql, array($id)) ->getFirst(); if ( ! $related || empty($related)) { $related = $this->getTable()->create(); } } $record->set($localFieldName, $related, false); return $related; } public function getCondition($alias = null) { if ( ! $alias) { $alias = $this->getTable()->getComponentName(); } return $alias . '.' . $this->definition['foreign'] . ' = ?'; } }class Doctrine_DataDict_Pgsql extends Doctrine_DataDict { protected static $reservedKeyWords = array( 'abort', 'absolute', 'access', 'action', 'add', 'after', 'aggregate', 'all', 'alter', 'analyse', 'analyze', 'and', 'any', 'as', 'asc', 'assertion', 'assignment', 'at', 'authorization', 'backward', 'before', 'begin', 'between', 'bigint', 'binary', 'bit', 'boolean', 'both', 'by', 'cache', 'called', 'cascade', 'case', 'cast', 'chain', 'char', 'character', 'characteristics', 'check', 'checkpoint', 'class', 'close', 'cluster', 'coalesce', 'collate', 'column', 'comment', 'commit', 'committed', 'constraint', 'constraints', 'conversion', 'convert', 'copy', 'create', 'createdb', 'createuser', 'cross', 'current_date', 'current_time', 'current_timestamp', 'current_user', 'cursor', 'cycle', 'database', 'day', 'deallocate', 'dec', 'decimal', 'declare', 'default', 'deferrable', 'deferred', 'definer', 'delete', 'delimiter', 'delimiters', 'desc', 'distinct', 'do', 'domain', 'double', 'drop', 'each', 'else', 'encoding', 'encrypted', 'end', 'escape', 'except', 'exclusive', 'execute', 'exists', 'explain', 'external', 'extract', 'false', 'fetch', 'float', 'for', 'force', 'foreign', 'forward', 'freeze', 'from', 'full', 'function', 'get', 'global', 'grant', 'group', 'handler', 'having', 'hour', 'ilike', 'immediate', 'immutable', 'implicit', 'in', 'increment', 'index', 'inherits', 'initially', 'inner', 'inout', 'input', 'insensitive', 'insert', 'instead', 'int', 'integer', 'intersect', 'interval', 'into', 'invoker', 'is', 'isnull', 'isolation', 'join', 'key', 'lancompiler', 'language', 'leading', 'left', 'level', 'like', 'limit', 'listen', 'load', 'local', 'localtime', 'localtimestamp', 'location', 'lock', 'match', 'maxvalue', 'minute', 'minvalue', 'mode', 'month', 'move', 'names', 'national', 'natural', 'nchar', 'new', 'next', 'no', 'nocreatedb', 'nocreateuser', 'none', 'not', 'nothing', 'notify', 'notnull', 'null', 'nullif', 'numeric', 'of', 'off', 'offset', 'oids', 'old', 'on', 'only', 'operator', 'option', 'or', 'order', 'out', 'outer', 'overlaps', 'overlay', 'owner', 'partial', 'password', 'path', 'pendant', 'placing', 'position', 'precision', 'prepare', 'primary', 'prior', 'privileges', 'procedural', 'procedure', 'read', 'real', 'recheck', 'references', 'reindex', 'relative', 'rename', 'replace', 'reset', 'restrict', 'returns', 'revoke', 'right', 'rollback', 'row', 'rule', 'schema', 'scroll', 'second', 'security', 'select', 'sequence', 'serializable', 'session', 'session_user', 'set', 'setof', 'share', 'show', 'similar', 'simple', 'smallint', 'some', 'stable', 'start', 'statement', 'statistics', 'stdin', 'stdout', 'storage', 'strict', 'substring', 'sysid', 'table', 'temp', 'template', 'temporary', 'then', 'time', 'timestamp', 'to', 'toast', 'trailing', 'transaction', 'treat', 'trigger', 'trim', 'true', 'truncate', 'trusted', 'type', 'unencrypted', 'union', 'unique', 'unknown', 'unlisten', 'until', 'update', 'usage', 'user', 'using', 'vacuum', 'valid', 'validator', 'values', 'varchar', 'varying', 'verbose', 'version', 'view', 'volatile', 'when', 'where', 'with', 'without', 'work', 'write', 'year', 'zone' ); public function getNativeDeclaration(array $field) { if ( ! isset($field['type'])) { throw new Doctrine_DataDict_Exception('Missing column type.'); } switch ($field['type']) { case 'enum': $field['length'] = isset($field['length']) && $field['length'] ? $field['length']:255; case 'char': case 'string': case 'array': case 'object': case 'varchar': case 'gzip': $length = (isset($field['length']) && $field['length'] && $field['length'] < 10000) ? $field['length'] : null; $fixed = ((isset($field['fixed']) && $field['fixed']) || $field['type'] == 'char') ? true : false; return $fixed ? ($length ? 'CHAR(' . $length . ')' : 'CHAR('.$this->conn->options['default_text_field_length'].')') : ($length ? 'VARCHAR(' .$length . ')' : 'TEXT'); case 'clob': return 'TEXT'; case 'blob': return 'BYTEA'; case 'integer': case 'int': if ( ! empty($field['autoincrement'])) { if ( ! empty($field['length'])) { $length = $field['length']; if ($length > 4) { return 'BIGSERIAL'; } } return 'SERIAL'; } if ( ! empty($field['length'])) { $length = $field['length']; if ($length <= 2) { return 'SMALLINT'; } elseif ($length == 3 || $length == 4) { return 'INT'; } elseif ($length > 4) { return 'BIGINT'; } } return 'INT'; case 'inet': return 'INET'; case 'bit': case 'varbit': return 'VARBIT'; case 'boolean': return 'BOOLEAN'; case 'date': return 'DATE'; case 'time': return 'TIME without time zone'; case 'timestamp': return 'TIMESTAMP without time zone'; case 'float': case 'double': return 'FLOAT'; case 'decimal': $length = !empty($field['length']) ? $field['length'] : 18; $scale = !empty($field['scale']) ? $field['scale'] : $this->conn->getAttribute(Doctrine::ATTR_DECIMAL_PLACES); return 'NUMERIC('.$length.','.$scale.')'; } throw new Doctrine_DataDict_Exception('Unknown field type \'' . $field['type'] . '\'.'); } public function getPortableDeclaration(array $field) { $length = (isset($field['length'])) ? $field['length'] : null; if ($length == '-1' && isset($field['atttypmod'])) { $length = $field['atttypmod'] - 4; } if ((int)$length <= 0) { $length = null; } $type = array(); $unsigned = $fixed = null; if ( ! isset($field['name'])) { $field['name'] = ''; } $dbType = strtolower($field['type']); switch ($dbType) { case 'inet': $type[] = 'inet'; break; case 'bit': case 'varbit': $type[] = 'bit'; break; case 'smallint': case 'int2': $type[] = 'integer'; $unsigned = false; $length = 2; if ($length == '2') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } break; case 'int': case 'int4': case 'integer': case 'serial': case 'serial4': $type[] = 'integer'; $unsigned = false; $length = 4; break; case 'bigint': case 'int8': case 'bigserial': case 'serial8': $type[] = 'integer'; $unsigned = false; $length = 8; break; case 'bool': case 'boolean': $type[] = 'boolean'; $length = 1; break; case 'text': case 'varchar': case 'interval': case '_varchar': $fixed = false; case 'unknown': case 'char': case 'bpchar': $type[] = 'string'; if ($length == '1') { $type[] = 'boolean'; if (preg_match('/^(is|has)/', $field['name'])) { $type = array_reverse($type); } } elseif (strstr($dbType, 'text')) { $type[] = 'clob'; } if ($fixed !== false) { $fixed = true; } break; case 'date': $type[] = 'date'; $length = null; break; case 'datetime': case 'timestamp': case 'timestamptz': $type[] = 'timestamp'; $length = null; break; case 'time': $type[] = 'time'; $length = null; break; case 'float': case 'float4': case 'float8': case 'double': case 'double precision': case 'real': $type[] = 'float'; break; case 'decimal': case 'money': case 'numeric': $type[] = 'decimal'; break; case 'tinyblob': case 'mediumblob': case 'longblob': case 'blob': case 'bytea': $type[] = 'blob'; $length = null; break; case 'oid': $type[] = 'blob'; $type[] = 'clob'; $length = null; break; case 'year': $type[] = 'integer'; $type[] = 'date'; $length = null; break; default: throw new Doctrine_DataDict_Exception('unknown database attribute type: '.$dbType); } return array('type' => $type, 'length' => $length, 'unsigned' => $unsigned, 'fixed' => $fixed); } public function getIntegerDeclaration($name, $field) { if ( ! empty($field['autoincrement'])) { $name = $this->conn->quoteIdentifier($name, true); return $name . ' ' . $this->getNativeDeclaration($field); } $default = ''; if (array_key_exists('default', $field)) { if ($field['default'] === '') { $field['default'] = empty($field['notnull']) ? null : 0; } $default = ' DEFAULT ' . (is_null($field['default']) ? 'NULL' : $this->conn->quote($field['default'], $field['type'])); } $notnull = empty($field['notnull']) ? '' : ' NOT NULL'; $name = $this->conn->quoteIdentifier($name, true); return $name . ' ' . $this->getNativeDeclaration($field) . $default . $notnull; } public function parseBoolean($value) { return $value; } } class Doctrine_DataDict_Exception extends Doctrine_Exception { }class Doctrine_IntegrityMapper { public function processDeleteIntegrity(Doctrine_Record $record) { $coll = $this->buildIntegrityRelationQuery($record); $this->invokeIntegrityActions($record); } public function invokeIntegrityActions(Doctrine_Record $record) { $deleteActions = Doctrine_Manager::getInstance() ->getDeleteActions($record->getTable()->getComponentName()); foreach ($record->getTable()->getRelations() as $relation) { $componentName = $relation->getTable()->getComponentName(); foreach($record->get($relation->getAlias()) as $coll) { if ( ! ($coll instanceof Doctrine_Collection)) { $coll = array($coll); } foreach ($coll as $record) { $this->invokeIntegrityActions($record); if (isset($deleteActions[$componentName])) { if ($deleteActions[$componentName] === 'SET NULL') { $record->set($relation->getForeign(), null); } elseif ($deleteActions[$componentName] === 'CASCADE') { $this->conn->transaction->addDelete($record); } } } } } } public function buildIntegrityRelationQuery(Doctrine_Record $record) { $q = new Doctrine_Query(); $aliases = array(); $indexes = array(); $root = $record->getTable()->getComponentName(); $rootAlias = strtolower(substr($root, 0, 1)); $aliases[$rootAlias] = $root; foreach ((array) $record->getTable()->getIdentifier() as $id) { $field = $rootAlias . '.' . $id; $cond[] = $field . ' = ?'; $fields[] = $field; $params = $record->get($id); } $fields = implode(', ', $fields); $components[] = $root; $this->buildIntegrityRelations($record->getTable(), $aliases, $fields, $indexes, $components); $q->select($fields)->from($root. ' ' . $rootAlias); foreach ($aliases as $alias => $name) { $q->leftJoin($rootAlias . '.' . $name . ' ' . $alias); } $q->where(implode(' AND ', $cond)); return $q->execute(array($params)); } public function buildIntegrityRelations(Doctrine_Table $table, &$aliases, &$fields, &$indexes, &$components) { $deleteActions = Doctrine_Manager::getInstance() ->getDeleteActions($table->getComponentName()); foreach ($table->getRelations() as $relation) { $componentName = $relation->getTable()->getComponentName(); if (in_array($componentName, $components)) { continue; } $components[] = $componentName; $alias = strtolower(substr($relation->getAlias(), 0, 1)); if ( ! isset($indexes[$alias])) { $indexes[$alias] = 1; } if (isset($deleteActions[$componentName])) { if (isset($aliases[$alias])) { $alias = $alias . ++$indexes[$alias]; } $aliases[$alias] = $relation->getAlias(); if ($deleteActions[$componentName] === 'SET NULL') { if ($relation instanceof Doctrine_Relation_ForeignKey) { foreach ((array) $relation->getForeign() as $foreign) { $fields .= ', ' . $alias . '.' . $foreign; } } elseif ($relation instanceof Doctrine_Relation_LocalKey) { foreach ((array) $relation->getLocal() as $foreign) { $fields .= ', ' . $alias . '.' . $foreign; } } } foreach ((array) $relation->getTable()->getIdentifier() as $id) { $fields .= ', ' . $alias . '.' . $id; } if ($deleteActions[$componentName] === 'CASCADE') { $this->buildIntegrityRelations($relation->getTable(), $aliases, $fields, $indexes, $components); } } } } } class Doctrine_FileFinder_NumberCompare { protected $test = ''; public function __construct($test) { $this->test = $test; } public function test($number) { if ( ! preg_match('{^([<>]=?)?(.*?)([kmg]i?)?$}i', $this->test, $matches)) { throw new Doctrine_Exception(sprintf('don\'t understand "%s" as a test.', $this->test)); } $target = array_key_exists(2, $matches) ? $matches[2] : ''; $magnitude = array_key_exists(3, $matches) ? $matches[3] : ''; if (strtolower($magnitude) == 'k') { $target *= 1000; } if (strtolower($magnitude) == 'ki') { $target *= 1024; } if (strtolower($magnitude) == 'm') { $target *= 1000000; } if (strtolower($magnitude) == 'mi') { $target *= 1024*1024; } if (strtolower($magnitude) == 'g') { $target *= 1000000000; } if (strtolower($magnitude) == 'gi') { $target *= 1024*1024*1024; } $comparison = array_key_exists(1, $matches) ? $matches[1] : '=='; if ($comparison == '==' || $comparison == '') { return ($number == $target); } else if ($comparison == '>') { return ($number > $target); } else if ($comparison == '>=') { return ($number >= $target); } else if ($comparison == '<') { return ($number < $target); } else if ($comparison == '<=') { return ($number <= $target); } return false; } }class Doctrine_FileFinder_GlobToRegex { protected static $strictLeadingDot = true; protected static $strictWildcardSlash = true; public static function setStrictLeadingDot($boolean) { self::$strictLeadingDot = $boolean; } public static function setStrictWildcardSlash($boolean) { self::$strictWildcardSlash = $boolean; } public static function globToRegex($glob) { $firstByte = true; $escaping = false; $inCurlies = 0; $regex = ''; for ($i = 0; $i < strlen($glob); $i++) { $car = $glob[$i]; if ($firstByte) { if (self::$strictLeadingDot && $car != '.') { $regex .= '(?=[^\.])'; } $firstByte = false; } if ($car == '/') { $firstByte = true; } if ($car == '.' || $car == '(' || $car == ')' || $car == '|' || $car == '+' || $car == '^' || $car == '$') { $regex .= "\\$car"; } else if ($car == '*') { $regex .= ($escaping ? "\\*" : (self::$strictWildcardSlash ? "[^/]*" : ".*")); } else if ($car == '?') { $regex .= ($escaping ? "\\?" : (self::$strictWildcardSlash ? "[^/]" : ".")); } else if ($car == '{') { $regex .= ($escaping ? "\\{" : "("); if ( ! $escaping) { ++$inCurlies; } } else if ($car == '}' && $inCurlies) { $regex .= ($escaping ? "}" : ")"); if ( ! $escaping) { --$inCurlies; } } else if ($car == ',' && $inCurlies) { $regex .= ($escaping ? "," : "|"); } else if ($car == "\\") { if ($escaping) { $regex .= "\\\\"; $escaping = false; } else { $escaping = true; } continue; } else { $regex .= $car; $escaping = false; } $escaping = false; } return "#^$regex$#"; } }class Doctrine_Inflector { public static function tableize($word) { return strtolower(preg_replace('~(?<=\\w)([A-Z])~', '_$1', $word)); } public static function classify($word) { return preg_replace_callback('~(_?)(_)([\w])~', array("Doctrine_Inflector", "classifyCallback"), ucfirst(strtolower($word))); } public static function classifyCallback($matches) { return $matches[1] . strtoupper($matches[3]); } public static function seemsUtf8($string) { for ($i = 0; $i < strlen($string); $i++) { if (ord($string[$i]) < 0x80) continue; elseif ((ord($string[$i]) & 0xE0) == 0xC0) $n=1; elseif ((ord($string[$i]) & 0xF0) == 0xE0) $n=2; elseif ((ord($string[$i]) & 0xF8) == 0xF0) $n=3; elseif ((ord($string[$i]) & 0xFC) == 0xF8) $n=4; elseif ((ord($string[$i]) & 0xFE) == 0xFC) $n=5; else return false; for ($j=0; $j<$n; $j++) { if ((++$i == strlen($string)) || ((ord($string[$i]) & 0xC0) != 0x80)) return false; } } return true; } public static function unaccent($string) { if ( ! preg_match('/[\x80-\xff]/', $string) ) { return $string; } if (self::seemsUtf8($string)) { $chars = array( chr(195).chr(128) => 'A', chr(195).chr(129) => 'A', chr(195).chr(130) => 'A', chr(195).chr(131) => 'A', chr(195).chr(132) => 'A', chr(195).chr(133) => 'A', chr(195).chr(135) => 'C', chr(195).chr(136) => 'E', chr(195).chr(137) => 'E', chr(195).chr(138) => 'E', chr(195).chr(139) => 'E', chr(195).chr(140) => 'I', chr(195).chr(141) => 'I', chr(195).chr(142) => 'I', chr(195).chr(143) => 'I', chr(195).chr(145) => 'N', chr(195).chr(146) => 'O', chr(195).chr(147) => 'O', chr(195).chr(148) => 'O', chr(195).chr(149) => 'O', chr(195).chr(150) => 'O', chr(195).chr(153) => 'U', chr(195).chr(154) => 'U', chr(195).chr(155) => 'U', chr(195).chr(156) => 'U', chr(195).chr(157) => 'Y', chr(195).chr(159) => 's', chr(195).chr(160) => 'a', chr(195).chr(161) => 'a', chr(195).chr(162) => 'a', chr(195).chr(163) => 'a', chr(195).chr(164) => 'a', chr(195).chr(165) => 'a', chr(195).chr(167) => 'c', chr(195).chr(168) => 'e', chr(195).chr(169) => 'e', chr(195).chr(170) => 'e', chr(195).chr(171) => 'e', chr(195).chr(172) => 'i', chr(195).chr(173) => 'i', chr(195).chr(174) => 'i', chr(195).chr(175) => 'i', chr(195).chr(177) => 'n', chr(195).chr(178) => 'o', chr(195).chr(179) => 'o', chr(195).chr(180) => 'o', chr(195).chr(181) => 'o', chr(195).chr(182) => 'o', chr(195).chr(182) => 'o', chr(195).chr(185) => 'u', chr(195).chr(186) => 'u', chr(195).chr(187) => 'u', chr(195).chr(188) => 'u', chr(195).chr(189) => 'y', chr(195).chr(191) => 'y', chr(196).chr(128) => 'A', chr(196).chr(129) => 'a', chr(196).chr(130) => 'A', chr(196).chr(131) => 'a', chr(196).chr(132) => 'A', chr(196).chr(133) => 'a', chr(196).chr(134) => 'C', chr(196).chr(135) => 'c', chr(196).chr(136) => 'C', chr(196).chr(137) => 'c', chr(196).chr(138) => 'C', chr(196).chr(139) => 'c', chr(196).chr(140) => 'C', chr(196).chr(141) => 'c', chr(196).chr(142) => 'D', chr(196).chr(143) => 'd', chr(196).chr(144) => 'D', chr(196).chr(145) => 'd', chr(196).chr(146) => 'E', chr(196).chr(147) => 'e', chr(196).chr(148) => 'E', chr(196).chr(149) => 'e', chr(196).chr(150) => 'E', chr(196).chr(151) => 'e', chr(196).chr(152) => 'E', chr(196).chr(153) => 'e', chr(196).chr(154) => 'E', chr(196).chr(155) => 'e', chr(196).chr(156) => 'G', chr(196).chr(157) => 'g', chr(196).chr(158) => 'G', chr(196).chr(159) => 'g', chr(196).chr(160) => 'G', chr(196).chr(161) => 'g', chr(196).chr(162) => 'G', chr(196).chr(163) => 'g', chr(196).chr(164) => 'H', chr(196).chr(165) => 'h', chr(196).chr(166) => 'H', chr(196).chr(167) => 'h', chr(196).chr(168) => 'I', chr(196).chr(169) => 'i', chr(196).chr(170) => 'I', chr(196).chr(171) => 'i', chr(196).chr(172) => 'I', chr(196).chr(173) => 'i', chr(196).chr(174) => 'I', chr(196).chr(175) => 'i', chr(196).chr(176) => 'I', chr(196).chr(177) => 'i', chr(196).chr(178) => 'IJ',chr(196).chr(179) => 'ij', chr(196).chr(180) => 'J', chr(196).chr(181) => 'j', chr(196).chr(182) => 'K', chr(196).chr(183) => 'k', chr(196).chr(184) => 'k', chr(196).chr(185) => 'L', chr(196).chr(186) => 'l', chr(196).chr(187) => 'L', chr(196).chr(188) => 'l', chr(196).chr(189) => 'L', chr(196).chr(190) => 'l', chr(196).chr(191) => 'L', chr(197).chr(128) => 'l', chr(197).chr(129) => 'L', chr(197).chr(130) => 'l', chr(197).chr(131) => 'N', chr(197).chr(132) => 'n', chr(197).chr(133) => 'N', chr(197).chr(134) => 'n', chr(197).chr(135) => 'N', chr(197).chr(136) => 'n', chr(197).chr(137) => 'N', chr(197).chr(138) => 'n', chr(197).chr(139) => 'N', chr(197).chr(140) => 'O', chr(197).chr(141) => 'o', chr(197).chr(142) => 'O', chr(197).chr(143) => 'o', chr(197).chr(144) => 'O', chr(197).chr(145) => 'o', chr(197).chr(146) => 'OE',chr(197).chr(147) => 'oe', chr(197).chr(148) => 'R', chr(197).chr(149) => 'r', chr(197).chr(150) => 'R', chr(197).chr(151) => 'r', chr(197).chr(152) => 'R', chr(197).chr(153) => 'r', chr(197).chr(154) => 'S', chr(197).chr(155) => 's', chr(197).chr(156) => 'S', chr(197).chr(157) => 's', chr(197).chr(158) => 'S', chr(197).chr(159) => 's', chr(197).chr(160) => 'S', chr(197).chr(161) => 's', chr(197).chr(162) => 'T', chr(197).chr(163) => 't', chr(197).chr(164) => 'T', chr(197).chr(165) => 't', chr(197).chr(166) => 'T', chr(197).chr(167) => 't', chr(197).chr(168) => 'U', chr(197).chr(169) => 'u', chr(197).chr(170) => 'U', chr(197).chr(171) => 'u', chr(197).chr(172) => 'U', chr(197).chr(173) => 'u', chr(197).chr(174) => 'U', chr(197).chr(175) => 'u', chr(197).chr(176) => 'U', chr(197).chr(177) => 'u', chr(197).chr(178) => 'U', chr(197).chr(179) => 'u', chr(197).chr(180) => 'W', chr(197).chr(181) => 'w', chr(197).chr(182) => 'Y', chr(197).chr(183) => 'y', chr(197).chr(184) => 'Y', chr(197).chr(185) => 'Z', chr(197).chr(186) => 'z', chr(197).chr(187) => 'Z', chr(197).chr(188) => 'z', chr(197).chr(189) => 'Z', chr(197).chr(190) => 'z', chr(197).chr(191) => 's', chr(226).chr(130).chr(172) => 'E', chr(194).chr(163) => ''); $string = strtr($string, $chars); } else { $chars['in'] = chr(128).chr(131).chr(138).chr(142).chr(154).chr(158) .chr(159).chr(162).chr(165).chr(181).chr(192).chr(193).chr(194) .chr(195).chr(196).chr(197).chr(199).chr(200).chr(201).chr(202) .chr(203).chr(204).chr(205).chr(206).chr(207).chr(209).chr(210) .chr(211).chr(212).chr(213).chr(214).chr(216).chr(217).chr(218) .chr(219).chr(220).chr(221).chr(224).chr(225).chr(226).chr(227) .chr(228).chr(229).chr(231).chr(232).chr(233).chr(234).chr(235) .chr(236).chr(237).chr(238).chr(239).chr(241).chr(242).chr(243) .chr(244).chr(245).chr(246).chr(248).chr(249).chr(250).chr(251) .chr(252).chr(253).chr(255); $chars['out'] = "EfSZszYcYuAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy"; $string = strtr($string, $chars['in'], $chars['out']); $doubleChars['in'] = array(chr(140), chr(156), chr(198), chr(208), chr(222), chr(223), chr(230), chr(240), chr(254)); $doubleChars['out'] = array('OE', 'oe', 'AE', 'DH', 'TH', 'ss', 'ae', 'dh', 'th'); $string = str_replace($doubleChars['in'], $doubleChars['out'], $string); } return $string; } public static function urlize($text) { $text = self::unaccent($text); $text = preg_replace('/\W/', ' ', $text); $text = strtolower(preg_replace('/[^A-Z^a-z^0-9^\/]+/', '-', preg_replace('/([a-z\d])([A-Z])/', '\1_\2', preg_replace('/([A-Z]+)([A-Z][a-z])/', '\1_\2', preg_replace('/::/', '/', $text))))); return trim($text, '-'); } }class Doctrine_Cache extends Doctrine_EventListener implements Countable, IteratorAggregate { protected $_options = array('size' => 1000, 'lifeTime' => 3600, 'addStatsPropability' => 0.25, 'savePropability' => 0.10, 'cleanPropability' => 0.01, 'statsFile' => '../data/stats.cache', ); protected $_queries = array(); protected $_driver; protected $_data = array(); protected $_success = false; public function __construct($driver, $options = array()) { if (is_object($driver)) { if ( ! ($driver instanceof Doctrine_Cache_Interface)) { throw new Doctrine_Cache_Exception('Driver should implement Doctrine_Cache_Interface.'); } $this->_driver = $driver; $this->_driver->setOptions($options); } else { $class = 'Doctrine_Cache_' . ucwords(strtolower($driver)); if ( ! class_exists($class)) { throw new Doctrine_Cache_Exception('Cache driver ' . $driver . ' could not be found.'); } $this->_driver = new $class($options); } } public function getDriver() { return $this->_driver; } public function setOption($option, $value) { if ($value === null) { throw new Doctrine_Cache_Exception('Null values not accepted for options.'); } if (isset($this->_options[$option])) { $this->_options[$option] = $value; return true; } return false; } public function getOption($option) { if ( ! isset($this->_options[$option])) { throw new Doctrine_Cache_Exception('Unknown option ' . $option); } return $this->_options[$option]; } public function add($query, $namespace = null) { if (isset($namespace)) { $this->_queries[$namespace][] = $query; } else { $this->_queries[] = $query; } } public function getAll($namespace = null) { if (isset($namespace)) { if ( ! isset($this->_queries[$namespace])) { return array(); } return $this->_queries[$namespace]; } return $this->_queries; } public function pop() { return array_pop($this->_queries); } public function reset() { $this->_queries = array(); } public function count() { return count($this->_queries); } public function getIterator() { return new ArrayIterator($this->_queries); } public function isSuccessful() { return $this->_success; } public function clean() { $rand = (mt_rand() / mt_getrandmax()); if ($rand <= $this->_options['cleanPropability']) { $queries = $this->readStats(); $stats = array(); foreach ($queries as $query) { if (isset($stats[$query])) { $stats[$query]++; } else { $stats[$query] = 1; } } sort($stats); $i = $this->_options['size']; while ($i--) { $element = next($stats); $query = key($stats); $hash = md5($query); $this->_driver->delete($hash); } } } public function readStats() { if ($this->_options['statsFile'] !== false) { $content = file_get_contents($this->_options['statsFile']); $e = explode("\n", $content); return array_map('unserialize', $e); } return array(); } public function appendStats() { if ($this->_options['statsFile'] !== false) { if ( ! file_exists($this->_options['statsFile'])) { throw new Doctrine_Cache_Exception("Couldn't save cache statistics. Cache statistics file doesn't exists!"); } $rand = (mt_rand() / mt_getrandmax()); if ($rand <= $this->_options['addStatsPropability']) { file_put_contents($this->_options['statsFile'], implode("\n", array_map('serialize', $this->_queries))); } } } public function preQuery(Doctrine_Event $event) { $query = $event->getQuery(); $data = false; if (strtoupper(substr(ltrim($query), 0, 6)) != 'SELECT') { return false; } $this->add($query, $event->getInvoker()->getName()); $data = $this->_driver->fetch(md5(serialize($query))); $this->success = ($data) ? true : false; if ( ! $data) { $rand = (mt_rand() / mt_getrandmax()); if ($rand < $this->_options['savePropability']) { $stmt = $event->getInvoker()->getAdapter()->query($query); $data = $stmt->fetchAll(Doctrine::FETCH_ASSOC); $this->success = true; $this->_driver->save(md5(serialize($query)), $data); } } if ($this->success) { $this->_data = $data; return true; } return false; } public function preFetch(Doctrine_Event $event) { $ret = current($this->_data); next($this->_data); return $ret; } public function preFetchAll(Doctrine_Event $event) { return $this->_data; } public function preExecute(Doctrine_Event $event) { $query = $event->getQuery(); $data = false; if (strtoupper(substr(ltrim($query), 0, 6)) != 'SELECT') { return false; } $this->add($query, $event->getInvoker()->getDbh()->getName()); $data = $this->_driver->fetch(md5(serialize(array($query, $event->getParams())))); $this->success = ($data) ? true : false; if ( ! $data) { $rand = (mt_rand() / mt_getrandmax()); if ($rand <= $this->_options['savePropability']) { $stmt = $event->getInvoker()->getStatement(); $stmt->execute($event->getParams()); $data = $stmt->fetchAll(Doctrine::FETCH_ASSOC); $this->success = true; $this->_driver->save(md5(serialize(array($query, $event->getParams()))), $data); } } if ($this->success) { $this->_data = $data; return true; } return false; } }class Doctrine_Collection extends Doctrine_Access implements Countable, IteratorAggregate, Serializable { protected $data = array(); protected $_table; protected $_snapshot = array(); protected $reference; protected $referenceField; protected $relation; protected $keyColumn; protected static $null; public function __construct($table, $keyColumn = null) { if ( ! ($table instanceof Doctrine_Table)) { $table = Doctrine::getTable($table); } $this->_table = $table; if ($keyColumn === null) { $keyColumn = $table->getBoundQueryPart('indexBy'); } if ($keyColumn === null) { $keyColumn = $table->getAttribute(Doctrine::ATTR_COLL_KEY); } if ($keyColumn !== null) { $this->keyColumn = $keyColumn; } } public static function initNullObject(Doctrine_Null $null) { self::$null = $null; } public function getTable() { return $this->_table; } public function setData(array $data) { $this->data = $data; } public function serialize() { $vars = get_object_vars($this); unset($vars['reference']); unset($vars['reference_field']); unset($vars['relation']); unset($vars['expandable']); unset($vars['expanded']); unset($vars['generator']); $vars['_table'] = $vars['_table']->getComponentName(); return serialize($vars); } public function unserialize($serialized) { $manager = Doctrine_Manager::getInstance(); $connection = $manager->getCurrentConnection(); $array = unserialize($serialized); foreach ($array as $name => $values) { $this->$name = $values; } $this->_table = $connection->getTable($this->_table); $keyColumn = isset($array['keyColumn']) ? $array['keyColumn'] : null; if ($keyColumn === null) { $keyColumn = $this->_table->getBoundQueryPart('indexBy'); } if ($keyColumn !== null) { $this->keyColumn = $keyColumn; } } public function setKeyColumn($column) { $this->keyColumn = $column; return $this; } public function getKeyColumn() { return $this->keyColumn; } public function getData() { return $this->data; } public function getFirst() { return reset($this->data); } public function getLast() { return end($this->data); } public function end() { return end($this->data); } public function key() { return key($this->data); } public function setReference(Doctrine_Record $record, Doctrine_Relation $relation) { $this->reference = $record; $this->relation = $relation; if ($relation instanceof Doctrine_Relation_ForeignKey || $relation instanceof Doctrine_Relation_LocalKey) { $this->referenceField = $relation->getForeignFieldName(); $value = $record->get($relation->getLocalFieldName()); foreach ($this->data as $record) { if ($value !== null) { $record->set($this->referenceField, $value, false); } else { $record->set($this->referenceField, $this->reference, false); } } } elseif ($relation instanceof Doctrine_Relation_Association) { } } public function getReference() { return $this->reference; } public function remove($key) { $removed = $this->data[$key]; unset($this->data[$key]); return $removed; } public function contains($key) { return isset($this->data[$key]); } public function search(Doctrine_Record $record) { return array_search($record, $this->data, true); } public function get($key) { if ( ! isset($this->data[$key])) { $record = $this->_table->create(); if (isset($this->referenceField)) { $value = $this->reference->get($this->relation->getLocalFieldName()); if ($value !== null) { $record->set($this->referenceField, $value, false); } else { $record->set($this->referenceField, $this->reference, false); } } if ($key === null) { $this->data[] = $record; } else { $this->data[$key] = $record; } if (isset($this->keyColumn)) { $record->set($this->keyColumn, $key); } return $record; } return $this->data[$key]; } public function getPrimaryKeys() { $list = array(); $name = $this->_table->getIdentifier(); foreach ($this->data as $record) { if (is_array($record) && isset($record[$name])) { $list[] = $record[$name]; } else { $list[] = $record->getIncremented(); } } return $list; } public function getKeys() { return array_keys($this->data); } public function count() { return count($this->data); } public function set($key, $record) { if (isset($this->referenceField)) { $record->set($this->referenceField, $this->reference, false); } $this->data[$key] = $record; } public function add($record, $key = null) { if (isset($this->referenceField)) { $value = $this->reference->get($this->relation->getLocalFieldName()); if ($value !== null) { $record->set($this->referenceField, $value, false); } else { $record->set($this->referenceField, $this->reference, false); } $relations = $this->relation['table']->getRelations(); foreach ($relations as $relation) { if ($this->relation['class'] == $relation['localTable']->getOption('name') && $relation->getLocal() == $this->relation->getForeignFieldName()) { $record->$relation['alias'] = $this->reference; break; } } } foreach ($this->data as $val) { if ($val === $record) { return false; } } if (isset($key)) { if (isset($this->data[$key])) { return false; } $this->data[$key] = $record; return true; } if (isset($this->keyColumn)) { $value = $record->get($this->keyColumn); if ($value === null) { throw new Doctrine_Collection_Exception("Couldn't create collection index. Record field '".$this->keyColumn."' was null."); } $this->data[$value] = $record; } else { $this->data[] = $record; } return true; } public function merge(Doctrine_Collection $coll) { $localBase = $this->getTable()->getComponentName(); $otherBase = $coll->getTable()->getComponentName(); if ($otherBase != $localBase && !is_subclass_of($otherBase, $localBase) ) { throw new Doctrine_Collection_Exception("Can't merge collections with incompatible record types"); } foreach ($coll->getData() as $record) { $this->add($record); } return $this; } public function loadRelated($name = null) { $list = array(); $query = new Doctrine_Query($this->_table->getConnection()); if ( ! isset($name)) { foreach ($this->data as $record) { $value = $record->getIncremented(); if ($value !== null) { $list[] = $value; } } $query->from($this->_table->getComponentName()); $query->where($this->_table->getComponentName() . '.id IN (' . substr(str_repeat("?, ", count($list)),0,-2) . ')'); return $query; } $rel = $this->_table->getRelation($name); if ($rel instanceof Doctrine_Relation_LocalKey || $rel instanceof Doctrine_Relation_ForeignKey) { foreach ($this->data as $record) { $list[] = $record[$rel->getLocal()]; } } else { foreach ($this->data as $record) { $value = $record->getIncremented(); if ($value !== null) { $list[] = $value; } } } $dql = $rel->getRelationDql(count($list), 'collection'); $coll = $query->query($dql, $list); $this->populateRelated($name, $coll); } public function populateRelated($name, Doctrine_Collection $coll) { $rel = $this->_table->getRelation($name); $table = $rel->getTable(); $foreign = $rel->getForeign(); $local = $rel->getLocal(); if ($rel instanceof Doctrine_Relation_LocalKey) { foreach ($this->data as $key => $record) { foreach ($coll as $k => $related) { if ($related[$foreign] == $record[$local]) { $this->data[$key]->setRelated($name, $related); } } } } elseif ($rel instanceof Doctrine_Relation_ForeignKey) { foreach ($this->data as $key => $record) { if ( ! $record->exists()) { continue; } $sub = new Doctrine_Collection($table); foreach ($coll as $k => $related) { if ($related[$foreign] == $record[$local]) { $sub->add($related); $coll->remove($k); } } $this->data[$key]->setRelated($name, $sub); } } elseif ($rel instanceof Doctrine_Relation_Association) { $identifier = $this->_table->getIdentifier(); $asf = $rel->getAssociationFactory(); $name = $table->getComponentName(); foreach ($this->data as $key => $record) { if ( ! $record->exists()) { continue; } $sub = new Doctrine_Collection($table); foreach ($coll as $k => $related) { if ($related->get($local) == $record[$identifier]) { $sub->add($related->get($name)); } } $this->data[$key]->setRelated($name, $sub); } } } public function getNormalIterator() { return new Doctrine_Collection_Iterator_Normal($this); } public function takeSnapshot() { $this->_snapshot = $this->data; return $this; } public function getSnapshot() { return $this->_snapshot; } public function processDiff() { foreach (array_udiff($this->_snapshot, $this->data, array($this, "compareRecords")) as $record) { $record->delete(); } return $this; } public function toArray($deep = false, $prefixKey = false) { $data = array(); foreach ($this as $key => $record) { $key = $prefixKey ? get_class($record) . '_' .$key:$key; $data[$key] = $record->toArray($deep, $prefixKey); } return $data; } public function fromArray($array, $deep = true) { $data = array(); foreach ($array as $rowKey => $row) { $this[$rowKey]->fromArray($row, $deep); } } public function synchronizeWithArray(array $array) { foreach ($this as $key => $record) { if (isset($array[$key])) { $record->synchronizeWithArray($array[$key]); unset($array[$key]); } else { $this->remove($key); } } foreach ($array as $rowKey => $row) { $this[$rowKey]->fromArray($row); } } public function synchronizeFromArray(array $array) { return $this->synchronizeWithArray($array); } public function exportTo($type, $deep = false) { if ($type == 'array') { return $this->toArray($deep); } else { return Doctrine_Parser::dump($this->toArray($deep, true), $type); } } public function importFrom($type, $data) { if ($type == 'array') { return $this->fromArray($data); } else { return $this->fromArray(Doctrine_Parser::load($data, $type)); } } public function getDeleteDiff() { return array_udiff($this->_snapshot, $this->data, array($this, 'compareRecords')); } public function getInsertDiff() { return array_udiff($this->data, $this->_snapshot, array($this, "compareRecords")); } protected function compareRecords($a, $b) { if ($a->getOid() == $b->getOid()) { return 0; } return ($a->getOid() > $b->getOid()) ? 1 : -1; } public function save(Doctrine_Connection $conn = null, $processDiff = true) { if ($conn == null) { $conn = $this->_table->getConnection(); } try { $conn->beginInternalTransaction(); $conn->transaction->addCollection($this); if ($processDiff) { $this->processDiff(); } foreach ($this->getData() as $key => $record) { $record->save($conn); } $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } return $this; } public function delete(Doctrine_Connection $conn = null, $clearColl = true) { if ($conn == null) { $conn = $this->_table->getConnection(); } try { $conn->beginInternalTransaction(); $conn->transaction->addCollection($this); foreach ($this as $key => $record) { $record->delete($conn); } $conn->commit(); } catch (Exception $e) { $conn->rollback(); throw $e; } if ($clearColl) { $this->clear(); } return $this; } public function clear() { $this->data = array(); } public function free($deep = false) { foreach ($this->getData() as $key => $record) { if ( ! ($record instanceof Doctrine_Null)) { $record->free($deep); } } $this->data = array(); if ($this->reference) { $this->reference->free($deep); $this->reference = null; } } public function getIterator() { $data = $this->data; return new ArrayIterator($data); } public function __toString() { return Doctrine_Lib::getCollectionAsString($this); } public function getRelation() { return $this->relation; } } class Doctrine_Collection_Offset extends Doctrine_Collection { private $limit; public function __construct(Doctrine_Table $table) { parent::__construct($table); $this->limit = $table->getAttribute(Doctrine::ATTR_COLL_LIMIT); } public function getLimit() { return $this->limit; } public function getIterator() { return new Doctrine_Collection_Iterator_Expandable($this); } } abstract class Doctrine_Collection_Iterator implements Iterator { protected $collection; protected $keys; protected $key; protected $index; protected $count; public function __construct($collection) { $this->collection = $collection; $this->keys = $this->collection->getKeys(); $this->count = $this->collection->count(); } public function rewind() { $this->index = 0; $i = $this->index; if (isset($this->keys[$i])) { $this->key = $this->keys[$i]; } } public function key() { return $this->key; } public function current() { return $this->collection->get($this->key); } public function next() { $this->index++; $i = $this->index; if (isset($this->keys[$i])) { $this->key = $this->keys[$i]; } } }class Doctrine_Collection_Iterator_Offset extends Doctrine_Collection_Iterator { public function valid() { } }class Doctrine_Collection_Iterator_Normal extends Doctrine_Collection_Iterator { public function valid() { return ($this->index < $this->count); } }class Doctrine_Collection_Iterator_Expandable extends Doctrine_Collection_Iterator { public function valid() { if ($this->index < $this->count) { return true; } elseif ($this->index == $this->count) { $coll = $this->collection->expand($this->index); if ($coll instanceof Doctrine_Collection) { $count = count($coll); if ($count > 0) { $this->keys = array_merge($this->keys, $coll->getKeys()); $this->count += $count; return true; } } return false; } } }class Doctrine_Collection_Exception extends Doctrine_Exception { }class Doctrine_Manager extends Doctrine_Configurable implements Countable, IteratorAggregate { protected $_connections = array(); protected $_bound = array(); protected $_index = 0; protected $_currIndex = 0; protected $_queryRegistry; private function __construct() { Doctrine_Locator_Injectable::initNullObject(new Doctrine_Null); } public function setDefaultAttributes() { static $init = false; if ( ! $init) { $init = true; $attributes = array( Doctrine::ATTR_CACHE => null, Doctrine::ATTR_RESULT_CACHE => null, Doctrine::ATTR_QUERY_CACHE => null, Doctrine::ATTR_LOAD_REFERENCES => true, Doctrine::ATTR_LISTENER => new Doctrine_EventListener(), Doctrine::ATTR_RECORD_LISTENER => new Doctrine_Record_Listener(), Doctrine::ATTR_THROW_EXCEPTIONS => true, Doctrine::ATTR_VALIDATE => Doctrine::VALIDATE_NONE, Doctrine::ATTR_QUERY_LIMIT => Doctrine::LIMIT_RECORDS, Doctrine::ATTR_IDXNAME_FORMAT => "%s_idx", Doctrine::ATTR_SEQNAME_FORMAT => "%s_seq", Doctrine::ATTR_TBLNAME_FORMAT => "%s", Doctrine::ATTR_QUOTE_IDENTIFIER => false, Doctrine::ATTR_SEQCOL_NAME => 'id', Doctrine::ATTR_PORTABILITY => Doctrine::PORTABILITY_NONE, Doctrine::ATTR_EXPORT => Doctrine::EXPORT_ALL, Doctrine::ATTR_DECIMAL_PLACES => 2, Doctrine::ATTR_DEFAULT_PARAM_NAMESPACE => 'doctrine', Doctrine::ATTR_AUTOLOAD_TABLE_CLASSES => false, Doctrine::ATTR_USE_DQL_CALLBACKS => false, Doctrine::ATTR_AUTO_ACCESSOR_OVERRIDE => false, ); foreach ($attributes as $attribute => $value) { $old = $this->getAttribute($attribute); if ($old === null) { $this->setAttribute($attribute,$value); } } return true; } return false; } public static function getInstance() { static $instance; if ( ! isset($instance)) { $instance = new self(); } return $instance; } public function getQueryRegistry() { if ( ! isset($this->_queryRegistry)) { $this->_queryRegistry = new Doctrine_Query_Registry(); } return $this->_queryRegistry; } public function setQueryRegistry(Doctrine_Query_Registry $registry) { $this->_queryRegistry = $registry; return $this; } public static function connection($adapter = null, $name = null) { if ($adapter == null) { return Doctrine_Manager::getInstance()->getCurrentConnection(); } else { return Doctrine_Manager::getInstance()->openConnection($adapter, $name); } } public function openConnection($adapter, $name = null, $setCurrent = true) { if (is_object($adapter)) { if ( ! ($adapter instanceof PDO) && ! in_array('Doctrine_Adapter_Interface', class_implements($adapter))) { throw new Doctrine_Manager_Exception("First argument should be an instance of PDO or implement Doctrine_Adapter_Interface"); } $driverName = $adapter->getAttribute(Doctrine::ATTR_DRIVER_NAME); } else if (is_array($adapter)) { if ( ! isset($adapter[0])) { throw new Doctrine_Manager_Exception('Empty data source name given.'); } $e = explode(':', $adapter[0]); if ($e[0] == 'uri') { $e[0] = 'odbc'; } $parts['dsn'] = $adapter[0]; $parts['scheme'] = $e[0]; $parts['user'] = (isset($adapter[1])) ? $adapter[1] : null; $parts['pass'] = (isset($adapter[2])) ? $adapter[2] : null; $driverName = $e[0]; $adapter = $parts; } else { $parts = $this->parseDsn($adapter); $driverName = $parts['scheme']; $adapter = $parts; } if (is_array($adapter)) { foreach ($adapter as $key => $value) { $adapter[$key] = $value?urldecode($value):null; } } $this->setDefaultAttributes(); if ($name !== null) { $name = (string) $name; if (isset($this->_connections[$name])) { if ($setCurrent) { $this->_currIndex = $name; } return $this->_connections[$name]; } } else { $name = $this->_index; $this->_index++; } $drivers = array('mysql' => 'Doctrine_Connection_Mysql', 'sqlite' => 'Doctrine_Connection_Sqlite', 'pgsql' => 'Doctrine_Connection_Pgsql', 'oci' => 'Doctrine_Connection_Oracle', 'oci8' => 'Doctrine_Connection_Oracle', 'oracle' => 'Doctrine_Connection_Oracle', 'mssql' => 'Doctrine_Connection_Mssql', 'dblib' => 'Doctrine_Connection_Mssql', 'firebird' => 'Doctrine_Connection_Firebird', 'informix' => 'Doctrine_Connection_Informix', 'mock' => 'Doctrine_Connection_Mock'); if ( ! isset($drivers[$driverName])) { throw new Doctrine_Manager_Exception('Unknown driver ' . $driverName); } $className = $drivers[$driverName]; $conn = new $className($this, $adapter); $conn->setName($name); $this->_connections[$name] = $conn; if ($setCurrent) { $this->_currIndex = $name; } return $this->_connections[$name]; } public function parsePdoDsn($dsn) { $parts = array(); $names = array('dsn', 'scheme', 'host', 'port', 'user', 'pass', 'path', 'query', 'fragment', 'unix_socket'); foreach ($names as $name) { if ( ! isset($parts[$name])) { $parts[$name] = null; } } $e = explode(':', $dsn); $parts['scheme'] = $e[0]; $parts['dsn'] = $dsn; $e = explode(';', $e[1]); foreach ($e as $string) { if ($string) { $e2 = explode('=', $string); if (isset($e2[0]) && isset($e2[1])) { list($key, $value) = $e2; $parts[$key] = $value; } } } return $parts; } protected function _buildDsnPartsArray($dsn) { $dsn = str_replace("////", "/", $dsn); $dsn = str_replace("\\", "/", $dsn); $dsn = preg_replace("/\/\/\/(.*):\//", "//$1:/", $dsn); $parts = @parse_url($dsn); $names = array('dsn', 'scheme', 'host', 'port', 'user', 'pass', 'path', 'query', 'fragment', 'unix_socket'); foreach ($names as $name) { if ( ! isset($parts[$name])) { $parts[$name] = null; } } if (count($parts) == 0 || ! isset($parts['scheme'])) { throw new Doctrine_Manager_Exception('Could not parse dsn'); } return $parts; } public function parseDsn($dsn) { $parts = $this->_buildDsnPartsArray($dsn); switch ($parts['scheme']) { case 'sqlite': case 'sqlite2': case 'sqlite3': if (isset($parts['host']) && $parts['host'] == ':memory') { $parts['database'] = ':memory:'; $parts['dsn'] = 'sqlite::memory:'; } else { if (isset($parts['host'])) { $parts['path'] = $parts['host'] . ":" . $parts["path"]; $parts['host'] = null; } $parts['database'] = $parts['path']; $parts['dsn'] = $parts['scheme'] . ':' . $parts['path']; } break; case 'mssql': case 'dblib': if ( ! isset($parts['path']) || $parts['path'] == '/') { throw new Doctrine_Manager_Exception('No database available in data source name'); } if (isset($parts['path'])) { $parts['database'] = substr($parts['path'], 1); } if ( ! isset($parts['host'])) { throw new Doctrine_Manager_Exception('No hostname set in data source name'); } $parts['dsn'] = $parts['scheme'] . ':host=' . $parts['host'] . (isset($parts['port']) ? ':' . $parts['port']:null) . ';dbname=' . $parts['database']; break; case 'mysql': case 'informix': case 'oci8': case 'oci': case 'firebird': case 'pgsql': case 'odbc': case 'mock': case 'oracle': if ( ! isset($parts['path']) || $parts['path'] == '/') { throw new Doctrine_Manager_Exception('No database available in data source name'); } if (isset($parts['path'])) { $parts['database'] = substr($parts['path'], 1); } if ( ! isset($parts['host'])) { throw new Doctrine_Manager_Exception('No hostname set in data source name'); } $parts['dsn'] = $parts['scheme'] . ':host=' . $parts['host'] . (isset($parts['port']) ? ';port=' . $parts['port']:null) . ';dbname=' . $parts['database']; break; default: throw new Doctrine_Manager_Exception('Unknown driver '.$parts['scheme']); } return $parts; } public function getConnection($name) { if ( ! isset($this->_connections[$name])) { throw new Doctrine_Manager_Exception('Unknown connection: ' . $name); } return $this->_connections[$name]; } public function getConnectionName(Doctrine_Connection $conn) { return array_search($conn, $this->_connections, true); } public function bindComponent($componentName, $connectionName) { $this->_bound[$componentName] = $connectionName; } public function getConnectionForComponent($componentName) { Doctrine::autoload($componentName); if (isset($this->_bound[$componentName])) { return $this->getConnection($this->_bound[$componentName]); } return $this->getCurrentConnection(); } public function hasConnectionForComponent($componentName = null) { return isset($this->_bound[$componentName]); } public function closeConnection(Doctrine_Connection $connection) { $connection->close(); $key = array_search($connection, $this->_connections, true); if ($key !== false) { unset($this->_connections[$key]); } $this->_currIndex = key($this->_connections); unset($connection); } public function getConnections() { return $this->_connections; } public function setCurrentConnection($key) { $key = (string) $key; if ( ! isset($this->_connections[$key])) { throw new Doctrine_Connection_Exception("Connection key '$key' does not exist."); } $this->_currIndex = $key; } public function contains($key) { return isset($this->_connections[$key]); } public function count() { return count($this->_connections); } public function getIterator() { return new ArrayIterator($this->_connections); } public function getCurrentConnection() { $i = $this->_currIndex; if ( ! isset($this->_connections[$i])) { throw new Doctrine_Connection_Exception('There is no open connection'); } return $this->_connections[$i]; } public function createDatabases($specifiedConnections = array()) { if ( ! is_array($specifiedConnections)) { $specifiedConnections = (array) $specifiedConnections; } $results = array(); foreach ($this as $name => $connection) { if ( ! empty($specifiedConnections) && ! in_array($name, $specifiedConnections)) { continue; } $results[$name] = $connection->createDatabase(); } return $results; } public function dropDatabases($specifiedConnections = array()) { if ( ! is_array($specifiedConnections)) { $specifiedConnections = (array) $specifiedConnections; } $results = array(); foreach ($this as $name => $connection) { if ( ! empty($specifiedConnections) && ! in_array($name, $specifiedConnections)) { continue; } $results[$name] = $connection->dropDatabase(); } return $results; } public function __toString() { $r[] = "<pre>"; $r[] = "Doctrine_Manager"; $r[] = "Connections : ".count($this->_connections); $r[] = "</pre>"; return implode("\n",$r); } } class Doctrine_Adapter_Exception extends Doctrine_Exception { }class Doctrine_Adapter_Mysqli extends Doctrine_Adapter { protected function _connect() { if ($this->_connection) { return; } @$this->_connection = new mysqli( $this->_config['host'], $this->_config['username'], $this->_config['password'], $this->_config['dbname'] ); if ($this->_connection === false || mysqli_connect_errno()) { throw new Doctrine_Adapter_Exception(mysqli_connect_error()); } } public function closeConnection() { $this->_connection->close(); $this->_connection = null; } public function prepare($sql) { $this->_connect(); $stmt = new Doctrine_Statement_Mysqli($this, $sql); $stmt->setFetchMode($this->_fetchMode); return $stmt; } public function lastInsertId($tableName = null, $primaryKey = null) { $mysqli = $this->_connection; return $mysqli->insert_id; } protected function _beginTransaction() { $this->_connect(); $this->_connection->autocommit(false); } protected function _commit() { $this->_connect(); $this->_connection->commit(); $this->_connection->autocommit(true); } protected function _rollBack() { $this->_connect(); $this->_connection->rollback(); $this->_connection->autocommit(true); } }class Doctrine_Adapter_Statement_Mock implements Doctrine_Adapter_Statement_Interface { private $_mock; public $queryString; public function __construct($mock) { $this->_mock = $mock; } public function bindColumn($column, $param, $type = null) { } public function bindValue($param, $value, $type = null) { } public function bindParam($column, &$variable, $type = null, $length = null, $driverOptions = array()) { } public function closeCursor() { return true; } public function columnCount() { return 0; } public function errorCode() { return array(); } public function errorInfo() { return array(); } public function fetch($fetchStyle = Doctrine::FETCH_BOTH, $cursorOrientation = Doctrine::FETCH_ORI_NEXT, $cursorOffset = null) { return array(); } public function fetchAll($fetchMode = Doctrine::FETCH_BOTH) { return array(); } public function execute($params = null) { if (is_object($this->_mock)) { $this->_mock->addQuery($this->queryString); } return true; } public function fetchColumn($columnIndex = 0) { return 0; } public function fetchObject($className = 'stdClass', $args = array()) { return new $className(); } public function nextRowset() { return true; } public function rowCount() { return 0; } public function getColumnMeta($column) { } public function getAttribute($attribute) { } public function setAttribute($attribute, $value) { } public function setFetchMode($mode, $arg1 = null, $arg2 = null) { } }abstract class Doctrine_Adapter_Statement { public function bindValue($no, $value) { } public function fetch() { } public function nextRowset() { } public function execute() { } public function errorCode() { } public function errorInfo() { } public function rowCount() { } public function setFetchMode($mode) { } public function columnCount() { } }class Doctrine_Adapter_Resource implements Doctrine_Adapter_Interface { protected $resourceUrl; public function __construct($resourceUrl) { $this->resourceUrl = $resourceUrl; } public function prepare($sql) { } public function query($sql) { } public function quote($input) { } public function exec($sql) { } public function lastInsertId() { } public function beginTransaction() { } public function commit() { } public function rollBack() { } public function errorCode() { } public function errorInfo() { } public function getAttribute() { return 'sqlite'; } public function setAttribute() { } public function sqliteCreateFunction() { } }class Doctrine_Adapter_Mock implements Doctrine_Adapter_Interface, Countable { private $_name; private $_queries = array(); private $_exception = array(); private $_lastInsertIdFail = false; public function __construct($name = null) { $this->_name = $name; } public function getName() { return $this->_name; } public function pop() { return array_pop($this->_queries); } public function forceException($name, $message = '', $code = 0) { $this->_exception = array($name, $message, $code); } public function prepare($query) { $mock = new Doctrine_Adapter_Statement_Mock($this, $query); $mock->queryString = $query; return $mock; } public function addQuery($query) { $this->_queries[] = $query; } public function query($query) { $this->_queries[] = $query; $e = $this->_exception; if ( ! empty($e)) { $name = $e[0]; $this->_exception = array(); throw new $name($e[1], $e[2]); } $stmt = new Doctrine_Adapter_Statement_Mock($this, $query); $stmt->queryString = $query; return $stmt; } public function getAll() { return $this->_queries; } public function quote($input) { return "'" . addslashes($input) . "'"; } public function exec($statement) { $this->_queries[] = $statement; $e = $this->_exception; if ( ! empty($e)) { $name = $e[0]; $this->_exception = array(); throw new $name($e[1], $e[2]); } return 0; } public function forceLastInsertIdFail($fail = true) { if ($fail) { $this->_lastInsertIdFail = true; } else { $this->_lastInsertIdFail = false; } } public function lastInsertId() { $this->_queries[] = 'LAST_INSERT_ID()'; if ($this->_lastInsertIdFail) { return null; } else { return 1; } } public function count() { return count($this->_queries); } public function beginTransaction() { $this->_queries[] = 'BEGIN TRANSACTION'; } public function commit() { $this->_queries[] = 'COMMIT'; } public function rollBack() { $this->_queries[] = 'ROLLBACK'; } public function getAttribute($attribute) { if ($attribute == Doctrine::ATTR_DRIVER_NAME) { return strtolower($this->_name); } } public function errorCode() { } public function errorInfo() { } public function setAttribute($attribute, $value) { } public function sqliteCreateFunction() { } }class Doctrine_Pager { protected $_query; protected $_countQuery; protected $_countQueryParams; protected $_numResults; protected $_maxPerPage; protected $_page; protected $_lastPage; protected $_executed; public function __construct($query, $page, $maxPerPage = 0) { $this->_setExecuted(false); $this->_setQuery($query); $this->_setPage($page); $this->setMaxPerPage($maxPerPage); } protected function _initialize($params = array()) { $count = $this->getCountQuery()->count($this->getCountQueryParams($params)); $this->_setNumResults($count); $this->_setExecuted(true); $this->_adjustOffset(); } protected function _adjustOffset() { $this->_setLastPage( max(1, ceil($this->getNumResults() / $this->getMaxPerPage())) ); $offset = ($this->getPage() - 1) * $this->getMaxPerPage(); $p = $this->getQuery(); $p->offset($offset); $p->limit($this->getMaxPerPage()); } public function getExecuted() { return $this->_executed; } protected function _setExecuted($executed) { $this->_executed = $executed; } public function getRange($rangeStyle, $options = array()) { $class = 'Doctrine_Pager_Range_' . ucfirst($rangeStyle); return new $class($options, $this); } public function getNumResults() { if ($this->getExecuted()) { return $this->_numResults; } throw new Doctrine_Pager_Exception( 'Cannot retrieve the number of results of a not yet executed Pager query' ); } protected function _setNumResults($nb) { $this->_numResults = $nb; } public function getFirstPage() { return 1; } public function getLastPage() { if ($this->getExecuted()) { return $this->_lastPage; } throw new Doctrine_Pager_Exception( 'Cannot retrieve the last page number of a not yet executed Pager query' ); } protected function _setLastPage($page) { $this->_lastPage = $page; if ($this->getPage() > $page) { $this->_setPage($page); } } public function getPage() { return $this->_page; } public function getNextPage() { if ($this->getExecuted()) { return min($this->getPage() + 1, $this->getLastPage()); } throw new Doctrine_Pager_Exception( 'Cannot retrieve the last page number of a not yet executed Pager query' ); } public function getPreviousPage() { if ($this->getExecuted()) { return max($this->getPage() - 1, $this->getFirstPage()); } throw new Doctrine_Pager_Exception( 'Cannot retrieve the previous page number of a not yet executed Pager query' ); } public function getFirstIndice() { return ($this->getPage() - 1) * $this->getMaxPerPage() + 1; } public function getLastIndice() { return min($this->getNumResults(), ($this->getPage() * $this->getMaxPerPage())); } public function haveToPaginate() { if ($this->getExecuted()) { return $this->getNumResults() > $this->getMaxPerPage(); } throw new Doctrine_Pager_Exception( 'Cannot know if it is necessary to paginate a not yet executed Pager query' ); } public function setPage($page) { $this->_setPage($page); $this->_setExecuted(false); } private function _setPage($page) { $page = intval($page); $this->_page = ($page <= 0) ? 1 : $page; } public function getMaxPerPage() { return $this->_maxPerPage; } public function setMaxPerPage($max) { if ($max > 0) { $this->_maxPerPage = $max; } else if ($max == 0) { $this->_maxPerPage = 25; } else { $this->_maxPerPage = abs($max); } $this->_setExecuted(false); } public function getResultsInPage() { $page = $this->getPage(); if ($page != $this->getLastPage()) { return $this->getMaxPerPage(); } $offset = ($this->getPage() - 1) * $this->getMaxPerPage(); return abs($this->getNumResults() - $offset); } public function getQuery() { return $this->_query; } protected function _setQuery($query) { if (is_string($query)) { $query = Doctrine_Query::create()->parseQuery($query); } $this->_query = $query; } public function getCountQuery() { return ($this->_countQuery !== null) ? $this->_countQuery : $this->_query; } public function setCountQuery($query, $params = null) { if (is_string($query)) { $query = Doctrine_Query::create()->parseQuery($query); } $this->_countQuery = $query; $this->setCountQueryParams($params); $this->_setExecuted(false); } public function getCountQueryParams($defaultParams = array()) { return ($this->_countQueryParams !== null) ? $this->_countQueryParams : $defaultParams; } public function setCountQueryParams($params = array(), $append = false) { if ($append && is_array($this->_countQueryParams)) { $this->_countQueryParams = array_merge($this->_countQueryParams, $params); } else { if ($params !== null && !is_array($params)) { $params = array($params); } $this->_countQueryParams = $params; } $this->_setExecuted(false); } public function execute($params = array(), $hydrationMode = null) { if (!$this->getExecuted()) { $this->_initialize($params); } return $this->getQuery()->execute($params, $hydrationMode); } }class Doctrine_Migration { protected $_changes = array('created_tables' => array(), 'renamed_tables' => array(), 'created_constraints' => array(), 'dropped_fks' => array(), 'created_fks' => array(), 'dropped_constraints' => array(), 'removed_indexes' => array(), 'dropped_tables' => array(), 'added_columns' => array(), 'renamed_columns' => array(), 'changed_columns' => array(), 'removed_columns' => array(), 'added_indexes' => array()), $_migrationTableName = 'migration_version', $_migrationClassesDirectory = array(), $_migrationClasses = array(), $_loadedMigrations = array(); public function __construct($directory = null) { if ($directory != null) { $this->_migrationClassesDirectory = $directory; $this->loadMigrationClasses(); $this->createMigrationTable(); } } public function getTableName() { return $this->_migrationTableName; } public function setTableName($tableName) { $this->_migrationTableName = Doctrine_Manager::connection() ->formatter->getTableName($tableName); } protected function createMigrationTable() { $conn = Doctrine_Manager::connection(); try { $conn->export->createTable($this->_migrationTableName, array('version' => array('type' => 'integer', 'size' => 11))); return true; } catch(Exception $e) { return false; } } public function loadMigrationClassesFromDirectory() { $classes = get_declared_classes(); foreach ((array) $this->_migrationClassesDirectory as $dir) { $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY); foreach ($it as $file) { $e = explode('.', $file->getFileName()); if (end($e) === 'php' && strpos($file->getFileName(), '.inc') === false) { if ( ! in_array($file->getFileName(), $this->_loadedMigrations)) { require_once($file->getPathName()); $requiredClass = array_diff(get_declared_classes(), $classes); $requiredClass = end($requiredClass); if ($requiredClass) { $this->_loadedMigrations[$requiredClass] = $file->getFileName(); } } } } } } protected function loadMigrationClasses() { if ($this->_migrationClassesDirectory !== null) { $this->loadMigrationClassesFromDirectory(); } $parent = new ReflectionClass('Doctrine_Migration'); foreach ($this->_loadedMigrations as $name => $fileName) { $class = new ReflectionClass($name); while ($class->isSubclassOf($parent)) { $class = $class->getParentClass(); if ($class === false) { break; } } if ($class === false) { continue; } $e = explode('_', $fileName); $classMigrationNum = (int) $e[0]; $this->_migrationClasses[$classMigrationNum] = array('className' => $name, 'fileName' => $fileName); } return $this->_migrationClasses; } public function getMigrationClasses() { return $this->_migrationClasses; } protected function setCurrentVersion($number) { $conn = Doctrine_Manager::connection(); if ($this->hasMigrated()) { $conn->exec("UPDATE " . $this->_migrationTableName . " SET version = $number"); } else { $conn->exec("INSERT INTO " . $this->_migrationTableName . " (version) VALUES ($number)"); } } public function getCurrentVersion() { $conn = Doctrine_Manager::connection(); $result = $conn->fetchColumn("SELECT version FROM " . $this->_migrationTableName); return isset($result[0]) ? $result[0]:0; } public function hasMigrated() { $conn = Doctrine_Manager::connection(); $result = $conn->fetchColumn("SELECT version FROM " . $this->_migrationTableName); return isset($result[0]) ? true:false; } public function getLatestVersion() { $this->loadMigrationClasses(); $versions = array(); foreach (array_keys($this->_migrationClasses) as $classMigrationNum) { $versions[$classMigrationNum] = $classMigrationNum; } rsort($versions); return isset($versions[0]) ? $versions[0]:0; } public function getNextVersion() { return $this->getLatestVersion() + 1; } protected function getMigrationClass($num) { foreach ($this->_migrationClasses as $classMigrationNum => $info) { $className = $info['className']; if ($classMigrationNum == $num) { return new $className(); } } throw new Doctrine_Migration_Exception('Could not find migration class for migration step: '.$num); } protected function doMigrateStep($direction, $num) { $migrate = $this->getMigrationClass($num); $migrate->doMigrate($direction); } protected function doMigrate($direction) { $method = 'pre'.$direction; $this->$method(); if (method_exists($this, $direction)) { $this->$direction(); foreach ($this->_changes as $type => $changes) { $process = new Doctrine_Migration_Process(); $funcName = 'process' . Doctrine_Inflector::classify($type); if ( ! empty($changes)) { $process->$funcName($changes); } } } $method = 'post'.$direction; $this->$method(); } public function migrate($to = null) { $from = $this->getCurrentVersion(); if ($to === null) { $to = $this->getLatestVersion(); } if ($from == $to) { throw new Doctrine_Migration_Exception('Already at version # ' . $to); } $direction = $from > $to ? 'down':'up'; if ($direction === 'up') { for ($i = $from + 1; $i <= $to; $i++) { $this->doMigrateStep($direction, $i); } } else { for ($i = $from; $i > $to; $i--) { $this->doMigrateStep($direction, $i); } } $this->setCurrentVersion($to); return $to; } protected function addChange($type, array $change = array()) { $this->_changes[$type][] = $change; } public function createTable($tableName, array $fields = array(), array $options = array()) { $options = get_defined_vars(); $this->addChange('created_tables', $options); } public function dropTable($tableName) { $options = get_defined_vars(); $this->addChange('dropped_tables', $options); } public function renameTable($oldTableName, $newTableName) { $options = get_defined_vars(); $this->addChange('renamed_tables', $options); } public function createConstraint($tableName, $constraintName, array $definition) { $options = get_defined_vars(); $this->addChange('created_constraints', $options); } public function dropConstraint($tableName, $constraintName, $primary = false) { $options = get_defined_vars(); $this->addChange('dropped_constraints', $options); } public function createForeignKey($tableName, array $definition) { $options = get_defined_vars(); $this->addChange('created_fks', $options); } public function dropForeignKey($tableName, $fkName) { $options = get_defined_vars(); $this->addChange('dropped_fks', $options); } public function addColumn($tableName, $columnName, $type, array $options = array()) { $options = get_defined_vars(); $this->addChange('added_columns', $options); } public function renameColumn($tableName, $oldColumnName, $newColumnName) { $options = get_defined_vars(); $this->addChange('renamed_columns', $options); } public function changeColumn($tableName, $columnName, $type, array $options = array()) { $options = get_defined_vars(); $this->addChange('changed_columns', $options); } public function removeColumn($tableName, $columnName) { $options = get_defined_vars(); $this->addChange('removed_columns', $options); } public function addIndex($tableName, $indexName, array $definition) { $options = get_defined_vars(); $this->addChange('added_indexes', $options); } public function removeIndex($tableName, $indexName) { $options = get_defined_vars(); $this->addChange('removed_indexes', $options); } public function preUp() { return; } public function postUp() { return; } public function preDown() { return; } public function postDown() { return; } }class Doctrine_Template_I18n extends Doctrine_Template { public function __construct(array $options = array()) { $this->_plugin = new Doctrine_I18n($options); } public function setUp() { $this->_plugin->initialize($this->_table); } public function getI18n() { return $this->_plugin; } }class Doctrine_Template_Taggable extends Doctrine_Template { }class Doctrine_Template_SoftDelete extends Doctrine_Template { protected $_options = array('name' => 'deleted', 'type' => 'boolean', 'length' => 1, 'options' => array('default' => false, 'notnull' => true, ), ); public function __construct(array $options = array()) { $this->_options = Doctrine_Lib::arrayDeepMerge($this->_options, $options); } public function setTableDefinition() { $this->hasColumn($this->_options['name'], $this->_options['type'], $this->_options['length'], $this->_options['options']); $this->addListener(new Doctrine_Template_Listener_SoftDelete($this->_options)); } public function getOption($name) { return $this->_options[$name]; } }class Doctrine_Template_Timestampable extends Doctrine_Template { protected $_options = array('created' => array('name' => 'created_at', 'alias' => null, 'type' => 'timestamp', 'format' => 'Y-m-d H:i:s', 'disabled' => false, 'expression' => false, 'options' => array()), 'updated' => array('name' => 'updated_at', 'alias' => null, 'type' => 'timestamp', 'format' => 'Y-m-d H:i:s', 'disabled' => false, 'expression' => false, 'onInsert' => true, 'options' => array())); public function __construct(array $options = array()) { $this->_options = Doctrine_Lib::arrayDeepMerge($this->_options, $options); } public function setTableDefinition() { if( ! $this->_options['created']['disabled']) { $name = $this->_options['created']['name']; if ($this->_options['created']['alias']) { $name .= ' as ' . $this->_options['created']['alias']; } $this->hasColumn($name, $this->_options['created']['type'], null, $this->_options['created']['options']); } if( ! $this->_options['updated']['disabled']) { $name = $this->_options['updated']['name']; if ($this->_options['updated']['alias']) { $name .= ' as ' . $this->_options['updated']['alias']; } $this->hasColumn($name, $this->_options['updated']['type'], null, $this->_options['updated']['options']); } $this->addListener(new Doctrine_Template_Listener_Timestampable($this->_options)); } }class Doctrine_Template_Versionable extends Doctrine_Template { public function __construct(array $options = array()) { $this->_plugin = new Doctrine_AuditLog($options); } public function setUp() { if ($this->_plugin->getOption('auditLog')) { $this->_plugin->initialize($this->_table); } $this->hasColumn('version', 'integer', 8); $this->addListener(new Doctrine_AuditLog_Listener($this->_plugin)); } public function getAuditLog() { return $this->_plugin; } public function revert($version) { $auditLog = $this->_plugin; if ( ! $auditLog->getOption('auditLog')) { throw new Doctrine_Record_Exception('Audit log is turned off, no version history is recorded.'); } $data = $auditLog->getVersion($this->getInvoker(), $version); if ( ! isset($data[0])) { throw new Doctrine_Record_Exception('Version ' . $version . ' does not exist!'); } $this->getInvoker()->merge($data[0]); return $this->getInvoker(); } }class Doctrine_Template_NestedSet extends Doctrine_Template { private $_options; public function __construct(array $options = array()) { $this->_options = Doctrine_Lib::arrayDeepMerge($this->_options, $options); } public function setUp() { $this->_table->setOption('treeOptions', $this->_options); $this->_table->setOption('treeImpl', 'NestedSet'); } public function setTableDefinition() { $this->_table->getTree()->setTableDefinition(); } }class Doctrine_Template_Listener_SoftDelete extends Doctrine_Record_Listener { protected $_options = array(); public function __construct(array $options) { $this->_options = $options; } public function preDelete(Doctrine_Event $event) { $event->skipOperation(); } public function postDelete(Doctrine_Event $event) { $name = $this->_options['name']; $event->getInvoker()->$name = true; $event->getInvoker()->save(); } public function preDqlDelete(Doctrine_Event $event) { $params = $event->getParams(); $field = $params['alias'] . '.' . $this->_options['name']; $query = $event->getQuery(); if ( ! $query->contains($field)) { $query->from('')->update($params['component']['table']->getOption('name') . ' ' . $params['alias']); $query->set($field, '?', array(true)); $query->addWhere($field . ' = ? OR ' . $field . ' IS NULL', array(false)); } } public function preDqlSelect(Doctrine_Event $event) { $params = $event->getParams(); $field = $params['alias'] . '.' . $this->_options['name']; $query = $event->getQuery(); if ( ! $query->contains($field)) { $query->addWhere($field . ' = ? OR ' . $field . ' IS NULL', array(false)); } } }class Doctrine_Template_Listener_Timestampable extends Doctrine_Record_Listener { protected $_options = array(); public function __construct(array $options) { $this->_options = $options; } public function preInsert(Doctrine_Event $event) { if ( ! $this->_options['created']['disabled']) { $createdName = $event->getInvoker()->getTable()->getFieldName($this->_options['created']['name']); $modified = $event->getInvoker()->getModified(); if ( ! isset($modified[$createdName])) { $event->getInvoker()->$createdName = $this->getTimestamp('created'); } } if ( ! $this->_options['updated']['disabled'] && $this->_options['updated']['onInsert']) { $updatedName = $event->getInvoker()->getTable()->getFieldName($this->_options['updated']['name']); $modified = $event->getInvoker()->getModified(); if ( ! isset($modified[$updatedName])) { $event->getInvoker()->$updatedName = $this->getTimestamp('updated'); } } } public function preUpdate(Doctrine_Event $event) { if ( ! $this->_options['updated']['disabled']) { $updatedName = $event->getInvoker()->getTable()->getFieldName($this->_options['updated']['name']); $modified = $event->getInvoker()->getModified(); if ( ! isset($modified[$updatedName])) { $event->getInvoker()->$updatedName = $this->getTimestamp('updated'); } } } public function preDqlUpdate(Doctrine_Event $event) { if ( ! $this->_options['updated']['disabled']) { $params = $event->getParams(); $updatedName = $event->getInvoker()->getTable()->getFieldName($this->_options['updated']['name']); $field = $params['alias'] . '.' . $updatedName; $query = $event->getQuery(); if ( ! $query->contains($field)) { $query->set($field, '?', $this->getTimestamp('updated')); } } } public function getTimestamp($type) { $options = $this->_options[$type]; if ($options['expression'] !== false && is_string($options['expression'])) { return new Doctrine_Expression($options['expression']); } else { if ($options['type'] == 'date') { return date($options['format'], time()); } else if ($options['type'] == 'timestamp') { return date($options['format'], time()); } else { return time(); } } } }class Doctrine_Template_Listener_Sluggable extends Doctrine_Record_Listener { protected $_options = array(); public function __construct(array $options) { $this->_options = $options; } public function preInsert(Doctrine_Event $event) { $record = $event->getInvoker(); $name = $record->getTable()->getFieldName($this->_options['name']); if ( ! $record->$name) { $record->$name = $this->buildSlug($record); } } public function preUpdate(Doctrine_Event $event) { if (false !== $this->_options['unique']) { $record = $event->getInvoker(); $name = $record->getTable()->getFieldName($this->_options['name']); if ( ! $record->$name || (false !== $this->_options['canUpdate'] && array_key_exists($name, $record->getModified()))) { $record->$name = $this->buildSlug($record); } } } protected function buildSlug($record) { if (empty($this->_options['fields'])) { if (method_exists($record, 'getUniqueSlug')) { $value = $record->getUniqueSlug($record); } else { $value = (string) $record; } } else { if ($this->_options['unique'] === true) { $value = $this->getUniqueSlug($record); } else { $value = ''; foreach ($this->_options['fields'] as $field) { $value .= $record->$field . ' '; } } } $value = call_user_func_array($this->_options['builder'], array($value, $record)); return $value; } public function getUniqueSlug($record) { $name = $record->getTable()->getFieldName($this->_options['name']); $slugFromFields = ''; foreach ($this->_options['fields'] as $field) { $slugFromFields .= $record->$field . ' '; } $proposal = $record->$name ? $record->$name : $slugFromFields; $proposal = call_user_func_array($this->_options['builder'], array($proposal, $record)); $slug = $proposal; $whereString = 'r.' . $name . ' LIKE ?'; $whereParams = array($proposal.'%'); if ($record->exists()) { $identifier = $record->identifier(); $whereString .= ' AND r.' . implode(' != ? AND r.', $record->getTable()->getIdentifierColumnNames()) . ' != ?'; $whereParams = array_merge($whereParams, array_values($identifier)); } foreach ($this->_options['uniqueBy'] as $uniqueBy) { if (is_null($record->$uniqueBy)) { $whereString .= ' AND r.'.$uniqueBy.' IS NULL'; } else { $whereString .= ' AND r.'.$uniqueBy.' = ?'; $whereParams[] = $record->$uniqueBy; } } $originalIndexBy = $record->getTable()->getBoundQueryPart('indexBy'); $record->getTable()->bindQueryPart('indexBy', null); $query = Doctrine_Query::create() ->select('r.'.$name) ->from(get_class($record).' r') ->where($whereString , $whereParams) ->setHydrationMode(Doctrine::HYDRATE_ARRAY); if ($record->getTable()->hasTemplate('Doctrine_Template_SoftDelete')) { $softDelete = $record->getTable()->getTemplate('Doctrine_Template_SoftDelete'); $query->addWhere('(r.' . $softDelete->getOption('name') . ' = true OR r.' . $softDelete->getOption('name') . ' IS NOT NULL OR r.' . $softDelete->getOption('name') . ' = false OR r.' . $softDelete->getOption('name') . ' IS NULL)'); } $similarSlugResult = $query->execute(); $record->getTable()->bindQueryPart('indexBy', $originalIndexBy); $similarSlugs = array(); foreach ($similarSlugResult as $key => $value) { $similarSlugs[$key] = $value[$name]; } $i = 1; while (in_array($slug, $similarSlugs)) { $slug = call_user_func_array($this->_options['builder'], array($proposal.'-'.$i, $record)); $i++; } return $slug; } }class Doctrine_Template_Geographical extends Doctrine_Template { protected $_options = array('latitude' => array('name' => 'latitude', 'type' => 'float', 'size' => 4, 'options' => array()), 'longitude' => array('name' => 'longitude', 'type' => 'float', 'size' => 4, 'options' => array())); public function __construct(array $options = array()) { $this->_options = Doctrine_Lib::arrayDeepMerge($this->_options, $options); } public function setTableDefinition() { $this->hasColumn($this->_options['latitude']['name'], $this->_options['latitude']['type'], $this->_options['latitude']['size'], $this->_options['latitude']['options']); $this->hasColumn($this->_options['longitude']['name'], $this->_options['longitude']['type'], $this->_options['longitude']['size'], $this->_options['longitude']['options']); } public function getDistanceQuery() { $invoker = $this->getInvoker(); $query = $invoker->getTable()->createQuery(); $rootAlias = $query->getRootAlias(); $latName = $this->_options['latitude']['name']; $longName = $this->_options['longitude']['name']; $query->addSelect($rootAlias . '.*'); $sql = "((ACOS(SIN(%s * PI() / 180) * SIN(" . $rootAlias . "." . $latName . " * PI() / 180) + COS(%s * PI() / 180) * COS(" . $rootAlias . "." . $latName . " * PI() / 180) * COS((%s - " . $rootAlias . "." . $longName . ") * PI() / 180)) * 180 / PI()) * 60 * %s) as %s"; $milesSql = sprintf($sql, $invoker->get('latitude'), $invoker->get('latitude'), $invoker->get('longitude'), '1.1515', 'miles'); $query->addSelect($milesSql); $kilometersSql = sprintf($sql, $invoker->get('latitude'), $invoker->get('latitude'), $invoker->get('longitude'), '1.1515 * 1.609344', 'kilometers'); $query->addSelect($kilometersSql); return $query; } public function getDistance(Doctrine_Record $record, $kilometers = false) { $query = $this->getDistanceQuery($kilometers); $conditions = array(); $values = array(); foreach ((array) $record->getTable()->getIdentifier() as $id) { $conditions[] = $query->getRootAlias() . '.' . $id . ' = ?'; $values[] = $record->get($id); } $where = implode(' AND ', $conditions); $query->addWhere($where, $values); $query->limit(1); $result = $query->execute()->getFirst(); if (isset($result['kilometers']) && $result['miles']) { return $kilometers ? $result->get('kilometers'):$result->get('miles'); } else { return 0; } } }class Doctrine_Template_Sluggable extends Doctrine_Template { protected $_options = array('name' => 'slug', 'alias' => null, 'type' => 'string', 'length' => 255, 'unique' => true, 'options' => array(), 'fields' => array(), 'uniqueBy' => array(), 'uniqueIndex' => true, 'canUpdate' => false, 'builder' => array('Doctrine_Inflector', 'urlize'), 'indexName' => 'sluggable' ); public function __construct(array $options = array()) { $this->_options = Doctrine_Lib::arrayDeepMerge($this->_options, $options); } public function setTableDefinition() { $name = $this->_options['name']; if ($this->_options['alias']) { $name .= ' as ' . $this->_options['alias']; } $this->hasColumn($name, $this->_options['type'], $this->_options['length'], $this->_options['options']); if ($this->_options['unique'] == true && $this->_options['uniqueIndex'] == true && ! empty($this->_options['fields'])) { $indexFields = array($this->_options['name']); $indexFields = array_merge($indexFields, $this->_options['uniqueBy']); $this->index($this->_options['indexName'], array('fields' => $indexFields, 'type' => 'unique')); } $this->addListener(new Doctrine_Template_Listener_Sluggable($this->_options)); } }class Doctrine_Template_Searchable extends Doctrine_Template { public function __construct(array $options = array()) { $this->_plugin = new Doctrine_Search($options); } public function setUp() { $this->_plugin->initialize($this->_table); $this->addListener(new Doctrine_Search_Listener($this->_plugin)); } public function batchUpdateIndex($limit = null, $offset = null) { $this->_plugin->batchUpdateIndex($limit, $offset); } public function searchTableProxy($string, $query = null) { return $this->_plugin->search($string, $query); } }class Doctrine_RawSql extends Doctrine_Query_Abstract { private $fields = array(); function __construct(Doctrine_Connection $connection = null, Doctrine_Hydrator_Abstract $hydrator = null) { parent::__construct($connection, $hydrator); $this->useQueryCache(false); } public function parseQueryPart($queryPartName, $queryPart, $append = false) { return $this->parseDqlQueryPart($queryPartName, $queryPart, $append); } public function parseDqlQueryPart($queryPartName, $queryPart, $append = false) { if ($queryPartName == 'select') { $this->_parseSelectFields($queryPart); return $this; } if ( ! isset($this->_sqlParts[$queryPartName])) { $this->_sqlParts[$queryPartName] = array(); } if ( ! $append) { $this->_sqlParts[$queryPartName] = array($queryPart); } else { $this->_sqlParts[$queryPartName][] = $queryPart; } return $this; } protected function _addDqlQueryPart($queryPartName, $queryPart, $append = false) { return $this->parseQueryPart($queryPartName, $queryPart, $append); } private function _parseSelectFields($queryPart){ preg_match_all('/{([^}{]*)}/U', $queryPart, $m); $this->fields = $m[1]; $this->_sqlParts['select'] = array(); } public function parseDqlQuery($query) { $this->_parseSelectFields($query); $this->clear(); $tokens = $this->_tokenizer->sqlExplode($query, ' '); $parts = array(); foreach ($tokens as $key => $part) { $partLowerCase = strtolower($part); switch ($partLowerCase) { case 'select': case 'from': case 'where': case 'limit': case 'offset': case 'having': $type = $partLowerCase; if ( ! isset($parts[$partLowerCase])) { $parts[$partLowerCase] = array(); } break; case 'order': case 'group': $i = $key + 1; if (isset($tokens[$i]) && strtolower($tokens[$i]) === 'by') { $type = $partLowerCase . 'by'; $parts[$type] = array(); } else { $parts[$type][] = $part; } break; case 'by': continue; default: if ( ! isset($parts[$type][0])) { $parts[$type][0] = $part; } else { $parts[$type][0] .= ' '.$part; } } } $this->_sqlParts = $parts; $this->_sqlParts['select'] = array(); return $this; } public function getSqlQuery($params = array()) { $select = array(); foreach ($this->fields as $field) { $e = explode('.', $field); if ( ! isset($e[1])) { throw new Doctrine_RawSql_Exception('All selected fields in Sql query must be in format tableAlias.fieldName'); } if ( ! $this->hasSqlTableAlias($e[0])) { try { $this->addComponent($e[0], ucwords($e[0])); } catch (Doctrine_Exception $exception) { throw new Doctrine_RawSql_Exception('The associated component for table alias ' . $e[0] . ' couldn\'t be found.'); } } $componentAlias = $this->getComponentAlias($e[0]); if ($e[1] == '*') { foreach ($this->_queryComponents[$componentAlias]['table']->getColumnNames() as $name) { $field = $e[0] . '.' . $name; $select[$componentAlias][$field] = $field . ' AS ' . $e[0] . '__' . $name; } } else { $field = $e[0] . '.' . $e[1]; $select[$componentAlias][$field] = $field . ' AS ' . $e[0] . '__' . $e[1]; } } if ($this->_sqlParts['distinct'] != true) { foreach ($this->getTableAliasMap() as $tableAlias => $componentAlias) { $map = $this->_queryComponents[$componentAlias]; foreach ((array) $map['table']->getIdentifierColumnNames() as $key) { $field = $tableAlias . '.' . $key; if ( ! isset($this->_sqlParts['select'][$field])) { $select[$componentAlias][$field] = $field . ' AS ' . $tableAlias . '__' . $key; } } } } $q = 'SELECT '; if ($this->_sqlParts['distinct'] == true) { $q .= 'DISTINCT '; } reset($this->_queryComponents); $componentAlias = key($this->_queryComponents); $q .= implode(', ', $select[$componentAlias]); unset($select[$componentAlias]); foreach ($select as $component => $fields) { if ( ! empty($fields)) { $q .= ', ' . implode(', ', $fields); } } $string = $this->getInheritanceCondition($this->getRootAlias()); if ( ! empty($string)) { $this->_sqlParts['where'][] = $string; } $q .= ( ! empty($this->_sqlParts['from']))? ' FROM ' . implode(' ', $this->_sqlParts['from']) : ''; $q .= ( ! empty($this->_sqlParts['where']))? ' WHERE ' . implode(' AND ', $this->_sqlParts['where']) : ''; $q .= ( ! empty($this->_sqlParts['groupby']))? ' GROUP BY ' . implode(', ', $this->_sqlParts['groupby']) : ''; $q .= ( ! empty($this->_sqlParts['having']))? ' HAVING ' . implode(' AND ', $this->_sqlParts['having']) : ''; $q .= ( ! empty($this->_sqlParts['orderby']))? ' ORDER BY ' . implode(', ', $this->_sqlParts['orderby']) : ''; $q .= ( ! empty($this->_sqlParts['limit']))? ' LIMIT ' . implode(' ', $this->_sqlParts['limit']) : ''; $q .= ( ! empty($this->_sqlParts['offset']))? ' OFFSET ' . implode(' ', $this->_sqlParts['offset']) : ''; if ( ! empty($string)) { array_pop($this->_sqlParts['where']); } return $q; } public function getCountQuery($params = array()) { reset($this->_queryComponents); $componentAlias = key($this->_queryComponents); $tableAlias = $this->getSqlTableAlias($componentAlias); $fields = array(); foreach ((array) $this->_queryComponents[$componentAlias]['table']->getIdentifierColumnNames() as $key) { $fields[] = $tableAlias . '.' . $key; } $q = 'SELECT COUNT( DISTINCT '.implode(',',$fields).') as num_results'; $string = $this->getInheritanceCondition($this->getRootAlias()); if ( ! empty($string)) { $this->_sqlParts['where'][] = $string; } $q .= ( ! empty($this->_sqlParts['from']))? ' FROM ' . implode(' ', $this->_sqlParts['from']) : ''; $q .= ( ! empty($this->_sqlParts['where']))? ' WHERE ' . implode(' AND ', $this->_sqlParts['where']) : ''; $q .= ( ! empty($this->_sqlParts['groupby']))? ' GROUP BY ' . implode(', ', $this->_sqlParts['groupby']) : ''; $q .= ( ! empty($this->_sqlParts['having']))? ' HAVING ' . implode(' AND ', $this->_sqlParts['having']) : ''; if ( ! empty($string)) { array_pop($this->_sqlParts['where']); } return $q; } public function count($params = array()) { $q = $this->getCountQuery(); if ( ! is_array($params)) { $params = array($params); } $params = array_merge($this->_params['join'], $this->_params['where'], $this->_params['having'], $params); $results = $this->getConnection()->fetchAll($q, $params); if (count($results) > 1) { $count = count($results); } else { if (isset($results[0])) { $results[0] = array_change_key_case($results[0], CASE_LOWER); $count = $results[0]['num_results']; } else { $count = 0; } } return (int) $count; } public function getFields() { return $this->fields; } public function addComponent($tableAlias, $path) { $tmp = explode(' ', $path); $originalAlias = (count($tmp) > 1) ? end($tmp) : null; $e = explode('.', $tmp[0]); $fullPath = $tmp[0]; $fullLength = strlen($fullPath); $table = null; $currPath = ''; if (isset($this->_queryComponents[$e[0]])) { $table = $this->_queryComponents[$e[0]]['table']; $currPath = $parent = array_shift($e); } foreach ($e as $k => $component) { $length = strlen($currPath); $currPath = ($currPath) ? $currPath . '.' . $component : $component; $delimeter = substr($fullPath, $length, 1); if (strlen($currPath) === $fullLength && isset($originalAlias)) { $componentAlias = $originalAlias; } else { $componentAlias = $currPath; } if ( ! isset($table)) { $conn = Doctrine_Manager::getInstance() ->getConnectionForComponent($component); $table = $conn->getTable($component); $this->_queryComponents[$componentAlias] = array('table' => $table); } else { $relation = $table->getRelation($component); $this->_queryComponents[$componentAlias] = array('table' => $relation->getTable(), 'parent' => $parent, 'relation' => $relation); } $this->addSqlTableAlias($tableAlias, $componentAlias); $parent = $currPath; } return $this; } }interface Doctrine_Log_Filter_Interface { public function accept($event); }interface Doctrine_Log_Formatter_Interface { public function format($event); }interface Doctrine_Node_Interface { public function hasPrevSibling(); public function hasNextSibling(); public function hasChildren(); public function hasParent(); public function getPrevSibling(); public function getNextSibling(); public function getSiblings($includeNode = false); public function getFirstChild(); public function getLastChild(); public function getChildren(); public function getDescendants(); public function getParent(); public function getAncestors(); public function getPath($seperator = ' > ', $includeNode = false); public function getLevel(); public function getNumberChildren(); public function getNumberDescendants(); public function insertAsParentOf(Doctrine_Record $dest); public function insertAsPrevSiblingOf(Doctrine_Record $dest); public function insertAsNextSiblingOf(Doctrine_Record $dest); public function insertAsFirstChildOf(Doctrine_Record $dest); public function insertAsLastChildOf(Doctrine_Record $dest); public function moveAsPrevSiblingOf(Doctrine_Record $dest); public function moveAsNextSiblingOf(Doctrine_Record $dest); public function moveAsFirstChildOf(Doctrine_Record $dest); public function moveAsLastChildOf(Doctrine_Record $dest); public function addChild(Doctrine_Record $record); public function isLeaf(); public function isRoot(); public function isEqualTo(Doctrine_Record $subj); public function isDescendantOf(Doctrine_Record $subj); public function isDescendantOfOrEqualTo(Doctrine_Record $subj); public function isValidNode(); public function delete(); }interface Doctrine_Tree_Interface { public function createRoot(Doctrine_Record $record = null); public function findRoot($root_id = 1); public function fetchTree($options = array(), $hydrationMode = null); public function fetchBranch($pk, $options = array(), $hydrationMode = null); }interface Doctrine_Cache_Interface { public function fetch($id, $testCacheValidity = true); public function contains($id); public function save($id, $data, $lifeTime = false); public function delete($id); }interface Doctrine_EventListener_Interface { public function preTransactionCommit(Doctrine_Event $event); public function postTransactionCommit(Doctrine_Event $event); public function preTransactionRollback(Doctrine_Event $event); public function postTransactionRollback(Doctrine_Event $event); public function preTransactionBegin(Doctrine_Event $event); public function postTransactionBegin(Doctrine_Event $event); public function postConnect(Doctrine_Event $event); public function preConnect(Doctrine_Event $event); public function preQuery(Doctrine_Event $event); public function postQuery(Doctrine_Event $event); public function prePrepare(Doctrine_Event $event); public function postPrepare(Doctrine_Event $event); public function preExec(Doctrine_Event $event); public function postExec(Doctrine_Event $event); public function preError(Doctrine_Event $event); public function postError(Doctrine_Event $event); public function preFetch(Doctrine_Event $event); public function postFetch(Doctrine_Event $event); public function preFetchAll(Doctrine_Event $event); public function postFetchAll(Doctrine_Event $event); public function preStmtExecute(Doctrine_Event $event); public function postStmtExecute(Doctrine_Event $event); } interface Doctrine_Query_Filter_Interface { public function preQuery(Doctrine_Query $query); public function postQuery(Doctrine_Query $query); }interface Doctrine_Record_Listener_Interface { public function preSerialize(Doctrine_Event $event); public function postSerialize(Doctrine_Event $event); public function preUnserialize(Doctrine_Event $event); public function postUnserialize(Doctrine_Event $event); public function preSave(Doctrine_Event $event); public function postSave(Doctrine_Event $event); public function preDelete(Doctrine_Event $event); public function postDelete(Doctrine_Event $event); public function preUpdate(Doctrine_Event $event); public function postUpdate(Doctrine_Event $event); public function preInsert(Doctrine_Event $event); public function postInsert(Doctrine_Event $event); public function preHydrate(Doctrine_Event $event); public function postHydrate(Doctrine_Event $event); } interface Doctrine_Search_Analyzer_Interface { public function analyze($text); }interface Doctrine_Adapter_Statement_Interface { public function bindColumn($column, $param, $type = null); public function bindValue($param, $value, $type = null); public function bindParam($column, &$variable, $type = null, $length = null, $driverOptions = array()); public function closeCursor(); public function columnCount(); public function errorCode(); public function errorInfo(); public function execute($params = null); public function fetch($fetchStyle = Doctrine::FETCH_BOTH, $cursorOrientation = Doctrine::FETCH_ORI_NEXT, $cursorOffset = null); public function fetchAll($fetchStyle = Doctrine::FETCH_BOTH); public function fetchColumn($columnIndex = 0); public function fetchObject($className = 'stdClass', $args = array()); public function getAttribute($attribute); public function getColumnMeta($column); public function nextRowset(); public function rowCount(); public function setAttribute($attribute, $value); public function setFetchMode($mode, $arg1 = null, $arg2 = null); }interface Doctrine_Overloadable { public function __call($m, $a); }interface Doctrine_Adapter_Interface { public function prepare($prepareString); public function query($queryString); public function quote($input); public function exec($statement); public function lastInsertId(); public function beginTransaction(); public function commit(); public function rollBack(); public function errorCode(); public function errorInfo(); }